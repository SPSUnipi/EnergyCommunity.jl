var documenterSearchIndex = {"docs":
[{"location":"examples/configurations/#Optimizing-different-configurations","page":"Optimizing different configurations","title":"Optimizing different configurations","text":"This example aims to shocase the use of EnergyCommunity.jl to optimize the different configurations of energy communities supported by the tool, namely:\n\nNon Cooperative (NC)\nAggregated Non Cooperative (ANC)\nCooperative (CO)\n\nThe energy community considered in this example consists of 3 users, where:\n\nall users can install PV system\nonly the first user cannot install batteries, whereas the others can\nthe third user can install also wind turbines\n\nThe example is based on a subset of users taken from the following article, yet for a subset of users.\n\nD. Fioriti, A. Frangioni, D. Poli, \"Optimal sizing of energy communities with fair revenue sharing and exit clauses: Value, role and business model of aggregators and users,\" in Applied Energy, vol. 299, 2021, 117328,doi: 10.1016/j.apenergy.2021.117328","category":"section"},{"location":"examples/configurations/#Cooperative-(CO)","page":"Optimizing different configurations","title":"Cooperative (CO)","text":"","category":"section"},{"location":"examples/configurations/#Initialization","page":"Optimizing different configurations","title":"Initialization","text":"Import the needed packages\n\nusing EnergyCommunity, JuMP\nusing HiGHS, Plots\n\nCreate a base Energy Community example in the data folder; use the default configuration.\n\nfolder = joinpath(@__DIR__, \"data\")\ncreate_example_data(folder, config_name=\"default\")\n\nInput file to load the structure of the energy community based on a yaml file.\n\ninput_file = joinpath(@__DIR__, \"data/energy_community_model.yml\");\nnothing #hide\n\ndefine optimizer and options\n\noptimizer = optimizer_with_attributes(HiGHS.Optimizer, \"ipm_optimality_tolerance\"=>1e-6)","category":"section"},{"location":"examples/configurations/#Create,-build-and-optimize-the-model","page":"Optimizing different configurations","title":"Create, build and optimize the model","text":"Define the Cooperative model\n\nCO_Model = ModelEC(input_file, EnergyCommunity.GroupCO(), optimizer)\n\nBuild the mathematical model\n\nbuild_model!(CO_Model)\n\nOptimize the model\n\noptimize!(CO_Model)","category":"section"},{"location":"examples/configurations/#Results","page":"Optimizing different configurations","title":"Results","text":"get objective value in M€\n\nobj_CO = objective_value(CO_Model)/1e6\nobj_CO\n\noptionally, print summary of the results\n\nprint_summary(CO_Model)\n\nmoreover, obtain the business plan as DataFrame\n\nbusiness_plan(CO_Model)","category":"section"},{"location":"examples/configurations/#Non-Cooperative-(NC)","page":"Optimizing different configurations","title":"Non Cooperative (NC)","text":"","category":"section"},{"location":"examples/configurations/#Initialization-2","page":"Optimizing different configurations","title":"Initialization","text":"Given that the initialization is the same as for the CO model, we can reuse the input file and the optimizer defined above. So we can directly move to the model creation.","category":"section"},{"location":"examples/configurations/#Create,-build-and-optimize-the-model-2","page":"Optimizing different configurations","title":"Create, build and optimize the model","text":"Define the Non Cooperative model\n\nNC_Model = ModelEC(input_file, EnergyCommunity.GroupNC(), optimizer)\n\nBuild the mathematical model\n\nbuild_model!(NC_Model)\n\nOptimize the model\n\noptimize!(NC_Model)","category":"section"},{"location":"examples/configurations/#Results-2","page":"Optimizing different configurations","title":"Results","text":"get objective value in M€\n\nobj_NC = objective_value(NC_Model)/1e6\nobj_NC","category":"section"},{"location":"examples/configurations/#Aggregated-Non-Cooperative-(ANC)","page":"Optimizing different configurations","title":"Aggregated Non Cooperative (ANC)","text":"","category":"section"},{"location":"examples/configurations/#Initialization-3","page":"Optimizing different configurations","title":"Initialization","text":"Given that the initialization is the same as for the CO model, we can reuse the input file and the optimizer defined above. So we can directly move to the model creation. In this case, we showcase a different approach to define the ANC model by passing directly the configuration name to the ModelEC constructor.","category":"section"},{"location":"examples/configurations/#Create,-build-and-optimize-the-model-3","page":"Optimizing different configurations","title":"Create, build and optimize the model","text":"Define the Aggregated Non Cooperative model\n\nANC_Model = ModelEC(CO_Model, GroupANC())\n\nBuild the mathematical model\n\nbuild_model!(ANC_Model)\n\nOptimize the model\n\noptimize!(ANC_Model)","category":"section"},{"location":"examples/configurations/#Results-3","page":"Optimizing different configurations","title":"Results","text":"get objective value in M€\n\nobj_ANC = objective_value(ANC_Model)/1e6\nobj_ANC","category":"section"},{"location":"examples/configurations/#Comparison-of-the-results","page":"Optimizing different configurations","title":"Comparison of the results","text":"Finally, we can compare the results obtained from the three different configurations of energy communities.\n\nprintln(\"Objective value CO Model [M€]: \", obj_CO)\nprintln(\"Objective value NC Model [M€]: \", obj_NC)\nprintln(\"Objective value ANC Model [M€]: \", obj_ANC)\n\nAs expected, the Cooperative model provides the best objective value, followed by the Aggregated Non Cooperative model, and finally the Non Cooperative model. This showcases the benefits of cooperation within energy communities. We can do that also with a plot:\n\nbar(\n    [\"CO Model\", \"ANC Model\", \"NC Model\"],\n    [obj_CO, obj_ANC, obj_NC],\n    title=\"Comparison of Objective Values\",\n    ylabel=\"Objective Value [M€]\",\n    ylims=[-1.3, -1.1],\n    legend=false,\n)\n\ninfo: Info\nView this file on Github.\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"examples/heating_cooling/#Heating-and-Cooling-Flexibility","page":"Heating and Cooling Flexibility","title":"Heating and Cooling Flexibility","text":"This example demonstrates how to model heating and cooling flexibility in a building using EnergyCommunity.jl using the example provided by the tool named \"energycommunitymodel_thermal\". The example includes 3 users:\n\nUser 1: User with a PV system and an electric load\nUser 2: User with a PV, battery system and an electric load\nUser 3: User with a PV, wind, battery system, as well as a heat pump, boiler, thermal energy storage and thermal Load\n\nThis example showcase how to load and optimize an energy community model with thermal flexibility.","category":"section"},{"location":"examples/heating_cooling/#Initialization","page":"Heating and Cooling Flexibility","title":"Initialization","text":"Import the needed packages\n\nusing EnergyCommunity, JuMP\nusing HiGHS, Plots\n\nCreate a base Energy Community example in the data folder; use the default configuration.\n\nfolder = joinpath(@__DIR__, \"data\")\ncreate_example_data(folder, config_name=\"default\")\n\nInput file to load the structure of the energy community based on a yaml file.\n\ninput_file = joinpath(@__DIR__, \"data/energy_community_model_heat.yml\");\nnothing #hide\n\nOutput path of the plots\n\noutput_plot_isolated = joinpath(@__DIR__, \"./results/Img/plot_user_{:s}_CO.png\");\nnothing #hide\n\ndefine optimizer and options\n\noptimizer = optimizer_with_attributes(HiGHS.Optimizer, \"ipm_optimality_tolerance\"=>1e-6)","category":"section"},{"location":"examples/heating_cooling/#Create,-build-and-optimize-the-model","page":"Heating and Cooling Flexibility","title":"Create, build and optimize the model","text":"Define the Cooperative model\n\nTH_Model = ModelEC(input_file, EnergyCommunity.GroupCO(), optimizer)\n\nBuild the mathematical model\n\nbuild_model!(TH_Model)\n\nOptimize the model\n\noptimize!(TH_Model)","category":"section"},{"location":"examples/heating_cooling/#Results","page":"Heating and Cooling Flexibility","title":"Results","text":"get objective value\n\nobjective_value(TH_Model)","category":"section"},{"location":"examples/heating_cooling/#Plots-of-dispatch","page":"Heating and Cooling Flexibility","title":"Plots of dispatch","text":"Create plots of the dispatch of resources by user and save them to disk\n\nall_plots = plot(TH_Model, output_plot_isolated)\nuser_to_plot = 3  # select user to plot\nplot(all_plots[user_to_plot, 3])  # show the plot of user 3 (top: power dispatch, bottom: battery storage)\n\ninfo: Info\nView this file on Github.\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"installation/#Installation-guide","page":"Installation guide","title":"Installation guide","text":"This guide explains how to install EnergyCommunity.jl and its dependencies.","category":"section"},{"location":"installation/#Install-Julia","page":"Installation guide","title":"Install Julia","text":"EnergyCommunity.jl is a Julia package. To use it, you need to install Julia. You can download Julia from the official website.","category":"section"},{"location":"installation/#Install-EnergyCommunity.jl","page":"Installation guide","title":"Install EnergyCommunity.jl","text":"To install EnergyCommunity.jl, you can use the Julia package manager. Open Julia and run the following commands:\n\njulia> import Pkg\n\njulia> Pkg.add(\"EnergyCommunity\")","category":"section"},{"location":"installation/#Install-a-solver","page":"Installation guide","title":"Install a solver","text":"EnergyCommunity.jl requires an optimization solver to solve the optimization problem. You can use any optimization solver compatible with JuMP.jl. For example, you can use the open-source solver HiGHS. To install HiGHS, run the following command:\n\njulia> Pkg.add(\"HiGHS\")\n\nIt is recommended to use a solver capable of Mixed-Integer Linear Programming. You can find a list of solvers compatible with JuMP.jl here.","category":"section"},{"location":"installation/#Install-input/output-packages","page":"Installation guide","title":"Install input/output packages","text":"EnergyCommunity.jl also supports input/output featurs, such as saving/loading a model to disk or plotting results. To install the plotting package Plots.jl, run the following command:\n\njulia> Pkg.add(\"Plots\")\n\nTo install FileIO.jl that is used to export the model to disk, run the following command:\n\njulia> Pkg.add(\"FileIO\")","category":"section"},{"location":"model/power_model/#User-power-model","page":"User power model","title":"User power model","text":"","category":"section"},{"location":"model/power_model/#User's-goal","page":"User power model","title":"User's goal","text":"","category":"section"},{"location":"model/power_model/#Net-Present-Value","page":"User power model","title":"Net Present Value","text":"The Net Present Value NPV_j of each user j accounts for the cash flows for every year y in Y, where Y is the set of years in the planning horizon, accounting for net revenues R_jy by exchanging energy with the grid, investment costs I_jy, peak charges PP_jy, operating costs OP_jy, replacement costs RP_jy, and residual value RV_jy at the end of the project, discounted at rate r:\n\nmathrmNPV_j = sum_y in Y frac R_jy - I_jy - OF_jy - OV_jy - PP_jy - RP_jy + RV_jy (1+r)^y","category":"section"},{"location":"model/power_model/#Net-Revenues-of-energy-flow-with-the-grid","page":"User power model","title":"Net Revenues of energy flow with the grid","text":"The net revenues are proportional to the energy withdrawn from the grid P^U-_jt, the energy injected into the grid P^U+_jt, and the consumption P^L_jt to the main grid, weighted by the respective prices pi^+_jt, pi^-_jt, and excise pi^ex_jt at each time period t in T, where t is the set of time periods in the planning horizon, and scaled by the time resolution Delta_t and the weighting factor m^T_t of each period to account for the use of representative days:\n\nR_jy = sum_t in T m^T_t Delta_t left( pi^+_jtP^U_jt+ - pi^-_jtP^U_jt- - pi^ex_jtP^L_jt right)","category":"section"},{"location":"model/power_model/#Investment-Costs","page":"User power model","title":"Investment Costs","text":"Investment charges are incurred only at the beginning of the project (y = 0) and account for the all assets A_j owned by the user j. The cost of each asset a in A_j is proportional to the nominal capacity x_aj of that asset and the per-unit cost c^I_aj:\n\nI_j0 = sum_ain A_j c^I_aj x_aj qquad I_jy=0  forall y0","category":"section"},{"location":"model/power_model/#Fixed-Operating-costs","page":"User power model","title":"Fixed Operating costs","text":"Yearly fixed operating costs OP_jy include costs proportional the nominal capacity x_aj of each asset by per-unit cost factor c^M_aj. Fixed operating costs do not apply to fuel-fired generators A^G_j, as their maintenance charges are proportional to the number of dispatched hours and accounted for in the variable operating costs.\n\nOF_jy = sum_ain A_j x_aj c^M_aj quad forall a in A_j  A^G_j","category":"section"},{"location":"model/power_model/#Variable-Operating-costs-(fuel-fired-assets)","page":"User power model","title":"Variable Operating costs (fuel-fired assets)","text":"Variable operating costs OV_jy account for the fuel costs and maintenance charges related to the operation of fuel-fired generators A^G_j and fuel-fired boilers A^boil_j owned by user j. The fuel consumption F_jgt of each generator g in A^G_j at time t is multiplied by the fuel cost pi^F_jg and scaled by the weighting factor m^T_t of each period to account for the use of representative days. The maintenance costs of generators are proportional to the number of hours the units have been dispatched and the per-unit maintenance cost c^M_gj. The fuel costs of boilers o in A^boil_j are proportional to the thermal power output P^boil_jot, the fuel price pi^F_jo, and inversely proportional to the product of the lower heating value PCI_jo and efficiency eta_jo of the boiler:\n\nOV_jy = sum_tin T m^T_t leftsum_g in A^G_j ( pi^F_jg F_jgt + Delta_t c^M_gj s_jgt) + sum_o in A^boil_j Delta_t pi^F_jo dfracP^boil_jotPCI_jo eta_jo  right","category":"section"},{"location":"model/power_model/#Peak-Power-Charges","page":"User power model","title":"Peak Power Charges","text":"The peak-power charges PP_jy describes charges related to the nominal capacity of the connection to the grid, that are modelled proportional the maximum peak power at the POD P^Umax_jw and the per-unit cost c^P_jw for each representative peak period w in W, where W is the set of peak periods, scaled by the weighting factor m^W_w of each period to account for the use of representative days:\n\nPP_jy = sum_win W m^W_w  c^P_jw  P^Umax_jw","category":"section"},{"location":"model/power_model/#Replacement-Costs","page":"User power model","title":"Replacement Costs","text":"The replacement charges RP_jy describe the costs for replacing assets during the project. When an asset a in A_j reaches its end of life N^Y_aj, that is mod(y N^Y_aj) = 0, the asset is replaced thus leading to additional expences. The replacement costs are modelled proportional the nominal capacity x_aj of each asset by per-unit cost factor c^I_aj, as for the investment costs:\n\nRP_jy = begincases\ndisplaystyle\nsum_ain A_j x_aj c^I_aj\n textif  mathrmmod(y N^Y_aj) = 0 \n0  textotherwise\nendcases","category":"section"},{"location":"model/power_model/#Residual-Value","page":"User power model","title":"Residual Value","text":"Finally, the residual value RV_jy accounts for the remaining value of assets at the end of the project (y = Y); for all other years RV_jy = 0. For each asset a in A_j, if the asset has not reached its end of life N^Y_aj, a fraction of the investment cost proportional to the remaining useful life is considered.\n\nRV_jY = sum_ain A_j x_aj c^I_aj frac N^Y_aj - mathrmmod(Y-1 N^Y_aj) N^Y_aj","category":"section"},{"location":"model/power_model/#Power-Balance","page":"User power model","title":"Power Balance","text":"The energy balance of the energy system at each user j and time t is guaranted by the following equation:\n\nP^U+_jt - P^U-_jt + sum_cin A^C_j(P^c-_jt - P^c+_jt) - P^R_jt + sum_g in A^G_jP^g_jt + sum_d in A^D_jP^textadj_jdt + sum_h in A^HP_jP^HPel_jht = - sum_f in A^F_j P^L_jft\n\nwhere:\n\nP^U+U-_jt+ is the power injected (+) into or withdrawn (-) from the grid by user j at time t measured at the Point of Delivery (PoD);\nP^c-c+_jt is the discharging power of converter c;\nP^R_jt is the total renewable generation;\nP^g_jt is the power generated by fuel-fired generator g;\nP^textadj_jdt is the net power exchanged by adjustable load d;\nP^HP_jht is the power consumed by heat pump h whose modelling is described in the section of thermal model;\nP^L_jt is the power consumption of user j at time t.\nA^CGRDF_j is the set of converters (C), fuel-fired generators (G), renewable assets (R) and dispatchable (D) and fixed (F) loads owned by user j;","category":"section"},{"location":"model/power_model/#Peak-Power-Definition","page":"User power model","title":"Peak Power Definition","text":"For each user j and window w, the peak-power P^Umax_jw is defined as the maximum power withdrawn or injected from the grid P^U_jt- over all time periods t in the representative peak-period window T_w:\n\nP^Umax_jw ge maxleft(P^U+_jt P^U-_jtright) quad forall t in T_w\n\nIn linear form, the max is implemented with the following two constraints:\n\nP^Umax_jw ge P^U_jt+ quad forall t in T_w\nP^Umax_jw ge P^U_jt- quad forall t in T_w","category":"section"},{"location":"model/power_model/#Renewable-Generation-Limit","page":"User power model","title":"Renewable Generation Limit","text":"For each user j and time step t, the total renewable generation P^R_jt is limited by the set A^R_j of renewable assets, their nominal capacity x_rj that is a variable optimized by the algorithm and the per-unit renewable production p^r_jt:\n\nP^R_jt le sum_rin A^R_j p^r_jt x_rj","category":"section"},{"location":"model/power_model/#Battery-and-Converter-Constraints","page":"User power model","title":"Battery and Converter Constraints","text":"Each battery b in A^B_j owned by user j, where A^B_j is the set of storage assets owned by user j, must have a corresponding converter c(b) in A^C_j, where A^C_j is the set of converters owned by user j. The converter c(b) is used to charge and discharge the battery b. \n\nFor battery b in A^B_j owned by user j, the energy E_jbt stored in the battery is regulated by the following equation, where P^c(b)+_jt is the charging power of the converter c(b), P^c(b)-_jt is the discharging power of the converter c(b), and eta_b is the round-trip efficiency of the battery b.\n\nE_jbt = E_jbt-1 - Delta_t fracP^c(b)+_jteta_b + Delta_t eta_b P^c(b)-_j t\n\nMaximum and minimum energy limits apply:\n\nbeta^min_bj x_bj le E_jbt le beta^max_bj x_bj\n\nPower limits on the converter c apply as follows, where x_cj is the nominal power capacity of the converter c owned by user j:\n\nMaximum charging P^c+_jt le x_cj\nMaximum discharging P^c-_jt le x_cj","category":"section"},{"location":"model/power_model/#Modular-units","page":"User power model","title":"Modular units","text":"Units where modularity option is enabled are modelled by introducing integer variables n_aj representing the number of installed modules of type A^M_j and constraints linking the total capacity to the number of modules and the capacity per module. n_aj is an integer variable representing the number of modules of asset a owned by user j, and overlineS^a_j is the capacity per module.\n\nx_aj = n_aj overlineS^a_j quad forall a in A^M_j","category":"section"},{"location":"model/power_model/#Fuel-Fired-Generators","page":"User power model","title":"Fuel-Fired Generators","text":"The dispatch of each fuel-fired generator g in A^G_j owned by user j is regulated by unit-commitment constraints and require modularity option, that is the fuel-fired generators are of standardized nominal capacity overlineS^a_j. Minimum and maximum power limitations apply. Accordingly, the generation P^g_jt is limited by the number of dispatched units s_jgt as shown below:\n\nbeta^min_jg overlineS^a_j x_gj le P^g_jt le beta^max_jg overlineS^a_j x_gj\n\nThe number of dispatched units is limited by the number of installed units n_gj:\n\ns_gj le n_gj\n\nThe fuel consumption F_jgt is proportional to the generated power P^g_jt by the using a piece-wise linear function of slope c^FSg_j and intercept c^FIg_j:\n\nF^g_jt = c^FSg_j P^g_jt + Delta c^FIg_j s_jgt","category":"section"},{"location":"model/power_model/#Adjustable-loads","page":"User power model","title":"Adjustable loads","text":"Adjustable loads represent appliances whose electrical consumption can be modulated in time within technical boundaries while still satisfying a mandatory energy trajectory over the planning horizon. Examples include electric vehicles (EVs) or flexible industrial processes. Adjustable loads do have power constraints and energy constraints. The latter ensures that the total energy consumed (or supplied) by the adjustable load over the planning horizon matches a predefined energy trajectory.\n\nEach adjustable load d in A^D_j among the adjustable loads A^D_j owned by the user j is indexed by can absorb (P^textadjN_jdt) or supply (P^textadjP_jdt) power in agreement to specific constraints, where overlineP^textwithdrawal_jdt and overlineP^textsupply_jdt are specific inputs (constants or time series) provided by the user. For simplicity, we denote P^textadj_jdt the net power exchanged by the adjustable load d at time t, defined as the difference between the power withdrawn and supplied.\n\n  0 le P^textadjN_jdt le overlineP^textwithdrawal_jdt\n  0 le P^textadjP_jdt le overlineP^textsupply_jdt\n  P^textadj_jdt = P^textadjN_jdt - P^textadjP_jdt\n\nThe energy trajectory is regulated by the exogenous energy inflow xi_jdt (positive for charging and negative for discharging) that defines the net energy flows to the component. The energy stored in the adjustable load E^textadj_jdt at each time t is modelled as follows, where eta^P_jd and eta^N_jd are the efficiencies related to power supply and withdrawal.\n\n  E^textadj_jdt = E^textadj_jdt-1 - Delta_t fracP^textadjP_jdteta^P_jd + Delta_t P^textadjN_jdteta^N_jd + xi_jdt\n\nMaximum and minimum energy limits also apply:\n\n  underlineE^textadj_jdt le E^textadj_jdt le overlineE^textadj_jdt\n\nThis component can be used to model both energy storage systems (e.g., EV batteries) and flexible loads with specific energy requirements. For example, a charging station for Electric Vehicles can be modelled as an adjustable load where power and energy limits are non-zero when vehicles are connected to the recharging station, and the energy trajectory xi_jdt corresponds to the required state of charge by a specific time (e.g., departure time). In particular, when an EV with a given state of charge connects to the station, xi_jdt in that time step can be positive and match that value, signaling the additional state of charge that is being connected. Conversely, when an EV leaves the station, the station is deprived of energy and thus xi_jdt becomes negative. Energy limits are adapted accordingly to model the total minimum and maximum state of charge of all EVs connected to the station at each time t.","category":"section"},{"location":"model/power_model/#Deferrable-loads-(coming,-help-wanted)","page":"User power model","title":"Deferrable loads (coming, help wanted)","text":"Deferrable loads represent loads that can be shifted in time within certain limits but must be fully served within a specified time window. Examples include certain industrial processes or household appliances like washing machines.\n\nNot implemented yet, help wanted.","category":"section"},{"location":"configuration/market/#market-Section","page":"market Section","title":"market Section","text":"","category":"section"},{"location":"configuration/market/#Scope-and-overview","page":"market Section","title":"Scope and overview","text":"The market block defines tariff rules for different user tariff types.\n\nExample:\n\nmarket:\n  ...\n  tariff1:\n    profile:\n      buy_price: buy_price\n      sell_price: sell_price\n      consumption_price: consumption_price\n      peak_categories: peak_categories\n      peak_tariff:\n        function: parse_peak_quantity_by_time_vectors\n        inputs: [peak_categories, peak_tariff]\n      peak_weight:\n        function: parse_peak_quantity_by_time_vectors\n        inputs: [peak_categories, peak_weight]\n  ...\n  tariffN:\n    profile:\n      buy_price: ...\n      ...\n  ...","category":"section"},{"location":"configuration/market/#Parameters-in-market-Section","page":"market Section","title":"Parameters in market Section","text":"A tariff is defined by its buying price, selling price, consumption price, peak categories, peak tariff, and peak weight. The profile section within each tariff type specifies the relevant parameters. The peak_tariff and peak_weight fields utilize a function called parse_peak_quantity_by_time_vectors, which processes the input vectors based on the defined peak categories. The following table details the list, type and description of each entry that defines a tariff.\n\nusing CSV, DataFrames, Latexify\nprintln(pwd())\ndf = CSV.read(\"../../src/configtables/market_type.csv\", DataFrame)\nmdtable(coalesce.(df, \"\"), latex=false, adjustment=:l)","category":"section"},{"location":"model/community_model/#Shared-Energy-and-Benefits","page":"Shared Energy and Benefits","title":"Shared Energy and Benefits","text":"In cooperative and aggregated-non-cooperative ECs, users can share energy among each other, leading to potential cost savings and increased efficiency. The shared energy exchanged among users is modelled by introducing additional variables and constraints that regulate the energy flows within the community.","category":"section"},{"location":"model/community_model/#Shared-benefits","page":"Shared Energy and Benefits","title":"Shared benefits","text":"In mathematical terms, the shared energy benefits mathrmNPV^sh in cooperative ECs and mathrmNPV^sh_NC in aggregated-non-cooperative ECs are defined based on the discunted value of the yearly net benefit R^sh_y related to the energy shared.\n\nmathrmNPV^sh = sum_y in Y dfrac R^sh_y (1+r)^y\n\nR^sh_y is defined as proportional to the power P^sh_jt that is procuded and consumed among members of the community; pi^sh_jt is the per-unit reward for every unit of energy shared. Quantities are scaled by the time resolution Delta_t and weighted by factor m^T_t similalrly to other terms in the model.\n\nR^sh_y = sum_t in T m^T_t Delta_t pi^sh_jt P^sh_jt","category":"section"},{"location":"model/community_model/#Shared-power","page":"Shared Energy and Benefits","title":"Shared power","text":"The shared power P^sh_jt for each user j and time t is limited by the surplus generation and demand measured at users' PoD:\n\nP^sh_jt = min leftlbrace sum_j in I P^U-_jt    sum_j in I P^U-_jt rightrbrace\n\nIn linear form, the min is implemented with the following two constraints:\n\nP^sh_jt le sum_j in I P^U-_jt\nP^sh_jt le sum_j in I P^U-_jt","category":"section"},{"location":"configuration/assets/#Asset-types","page":"Asset types","title":"Asset types","text":"","category":"section"},{"location":"configuration/assets/#Scope-and-overview","page":"Asset types","title":"Scope and overview","text":"Assets represent the physical or logical components that each user may install or operate in the Energy Community. Each asset is defined by:\n\nits type (renewable, battery, heat pump, storage, etc.)\ntechno-economic parameters (CAPEX, O&M, lifetime)\noperational constraints\na profile section defining time-series inputs","category":"section"},{"location":"configuration/assets/#Example","page":"Asset types","title":"Example","text":"asset_name:\n  PV:\n    type: <asset_type>\n    ...\n    profile:\n      ...\n\nBelow are examples of the most common asset types supported by EnergyCommunity.jl.","category":"section"},{"location":"configuration/assets/#Fixed-Electrical-Loads","page":"Asset types","title":"Fixed Electrical Loads","text":"Fixed electrical loads represent non-flexible electricity demand that must be met exactly at each timestep.   They follow a predefined time-series profile and cannot shift or store energy.","category":"section"},{"location":"configuration/assets/#Example-2","page":"Asset types","title":"Example","text":"load:\n  type: load\n  profile:\n    load: load_user1     # column name representing the electrical demand profile","category":"section"},{"location":"configuration/assets/#Parameters","page":"Asset types","title":"Parameters","text":"The full list of parameters for fixed electrical load assets is shown below:\n\nusing CSV, DataFrames, Latexify\ndf = CSV.read(\"../../src/configtables/load_fixed.csv\", DataFrame)\nmdtable(coalesce.(df, \"\"), latex=false, adjustment=:l)","category":"section"},{"location":"configuration/assets/#Renewable-Assets-(PV,-Wind,-run-of-river,-...)","page":"Asset types","title":"Renewable Assets (PV, Wind, run-of-river, ...)","text":"Renewable generators convert environmental resources into electricity. Their production depends on a per-unit availability profile (ren_pu), typically taken from a time-series dataset such as PV or wind capacity factors.\n\nPV:\n  type: renewable\n  CAPEX_lin: 1700       # €/kW\n  OEM_lin: 30           # €/kW/y\n  lifetime_y: 25        # years\n  max_capacity: 300     # kW\n  profile:\n    ren_pu: pv          # name of column with PV availability\n\nRenewable assets define:\n\ncapital and operating costs,\nlifetime,\ncapacity limit,\na profile: pointing to time-series production.","category":"section"},{"location":"configuration/assets/#Parameters-2","page":"Asset types","title":"Parameters","text":"The full list of parameters for renewable assets is shown below:\n\nusing CSV, DataFrames, Latexify\ndf = CSV.read(\"../../src/configtables/renewable.csv\", DataFrame)\nmdtable(coalesce.(df, \"\"), latex=false, adjustment=:l)","category":"section"},{"location":"configuration/assets/#Battery-Energy-Storage-System-(BESS)","page":"Asset types","title":"Battery Energy Storage System (BESS)","text":"Batteries store electrical energy and are characterized by:\n\nround-trip efficiency,\nminimum/maximum state of charge,\nC-rate limits (charge/discharge),\nlink to a converter that manages AC/DC conversion.","category":"section"},{"location":"configuration/assets/#Example:-Battery","page":"Asset types","title":"Example: Battery","text":"batt:\n  type: battery\n  CAPEX_lin: 400        # €/kWh\n  OEM_lin: 5            # €/kWh/y\n  lifetime_y: 15        # years\n  eta: 0.92             # round-trip efficiency\n  max_SOC: 1.0          # upper SOC limit\n  min_SOC: 0.2          # lower SOC limit\n  max_capacity: 60      # kW power limit\n  max_C_dch: 1.0        # max discharge C-rate\n  max_C_ch: 1.0         # max charge C-rate\n  corr_asset: conv      # associated converter asset","category":"section"},{"location":"configuration/assets/#Parameters-3","page":"Asset types","title":"Parameters","text":"The full list of parameters for battery assets is shown below:\n\nusing CSV, DataFrames, Latexify\ndf = CSV.read(\"../../src/configtables/battery.csv\", DataFrame)\nmdtable(coalesce.(df, \"\"), latex=false, adjustment=:l)","category":"section"},{"location":"configuration/assets/#Converter","page":"Asset types","title":"Converter","text":"Converters interface DC storage (batteries) with the AC electrical system. They enforce power limits, efficiency, and allowable charge/discharge directions.","category":"section"},{"location":"configuration/assets/#Example:-Converter","page":"Asset types","title":"Example: Converter","text":"conv:\n  type: converter\n  CAPEX_lin: 200        # €/kW\n  OEM_lin: 2            # €/kW/y\n  lifetime_y: 10        # years\n  eta: 1.0              # electrical efficiency\n  max_dch: 1.0          # max discharge fraction\n  min_ch: 0.1           # min charge fraction\n  max_capacity: 60      # kW power rating\n  corr_asset: batt      # linked battery","category":"section"},{"location":"configuration/assets/#Parameters-4","page":"Asset types","title":"Parameters","text":"The full list of parameters for converter assets is shown below:\n\nusing CSV, DataFrames, Latexify\ndf = CSV.read(\"../../src/configtables/converter.csv\", DataFrame)\nmdtable(coalesce.(df, \"\"), latex=false, adjustment=:l)","category":"section"},{"location":"configuration/assets/#Heat-Pump","page":"Asset types","title":"Heat Pump","text":"Heat pumps couple the electrical and thermal sectors.   They can operate in:\n\nheating mode (COP > 1),\ncooling mode (EER > 1),\n\nand their performance depends on external and internal temperature profiles.","category":"section"},{"location":"configuration/assets/#Example:-Heat-Pump","page":"Asset types","title":"Example: Heat Pump","text":"hp:\n  type: heat_pump\n  CAPEX_lin: 1300       # €/kW (electrical)\n  OEM_lin: 15           # €/kW/y\n  lifetime_y: 20        # years\n\n  COP_c1: 2.3           # COP at T_c1\n  COP_c2: 2.7           # COP at T_c2\n  EER_h1: 3.0           # EER at T_h1\n  EER_h2: 2.6           # EER at T_h2\n\n  T_c1: 2.0             # reference external temp for COP_c1\n  T_c2: 7.0             # reference external temp for COP_c2\n  T_h: 55.0             # delivery/condensation temp (heating)\n  T_h1: 30.0            # reference external temp for EER_h1\n  T_h2: 35.0            # reference external temp for EER_h2\n  T_c: 7.0              # evaporator temp (cooling mode)\n\n  delta_T_approach: 5.0 # °C, temp approach margin\n  max_capacity: 50      # kW electrical input power\n\n  profile:\n    T_int: T_int        # internal temperature time series\n    T_ext: T_ext        # external temperature time series","category":"section"},{"location":"configuration/assets/#Parameters-5","page":"Asset types","title":"Parameters","text":"The full list of parameters for heat pump assets is shown below:\n\nusing CSV, DataFrames, Latexify\ndf = CSV.read(\"../../src/configtables/heat_pump.csv\", DataFrame)\nmdtable(coalesce.(df, \"\"), latex=false, adjustment=:l)","category":"section"},{"location":"configuration/assets/#Thermal-Energy-Storage-(TES)","page":"Asset types","title":"Thermal Energy Storage (TES)","text":"Thermal storage allows shifting heat production over time.   It is modeled with:\n\nenergy capacity (based on water volume and heat capacity),\nthermal losses depending on temperature gradients,\nheating and cooling operating temperatures.","category":"section"},{"location":"configuration/assets/#Example:-TES-Tank","page":"Asset types","title":"Example: TES Tank","text":"tes:\n  type: storage\n  CAPEX_lin: 1          # €/l\n  OEM_lin: 0.005        # €/l/y\n  lifetime_y: 35        # years\n\n  eta: 0.9              # storage efficiency\n  max_capacity: 50000   # liters\n  cp: 0.00116           # kWh/l°C, specific heat capacity\n  b_tr_x: 0.5           # thermal exposure factor\n  k: 0.0003             # kWh/h°C, heat loss coefficient\n\n  T_ref_heat: 50.0      # °C, reference temperature for heating mode\n  T_ref_cool: 10.0      # °C, reference temperature for cooling mode\n\n  profile:\n    T_int: T_int        # internal air temperature\n    T_ext: T_ext        # external air temperature","category":"section"},{"location":"configuration/assets/#Parameters-6","page":"Asset types","title":"Parameters","text":"The full list of parameters for thermal storage assets is shown below:\n\nusing CSV, DataFrames, Latexify\ndf = CSV.read(\"../../src/configtables/thermal_energy_storage.csv\", DataFrame)\nmdtable(coalesce.(df, \"\"), latex=false, adjustment=:l)","category":"section"},{"location":"configuration/assets/#Boiler-(Fuel-Fired-Thermal-Generator)","page":"Asset types","title":"Boiler (Fuel-Fired Thermal Generator)","text":"Boilers convert fuel (e.g., methane) into heat.   Their operation is modeled through:\n\nthermal efficiency,\nfuel consumption characteristics,\nmaximum thermal output,\noptional commitment-related operating costs.","category":"section"},{"location":"configuration/assets/#Example:-Boiler","page":"Asset types","title":"Example: Boiler","text":"boil:\n  type: boiler\n  CAPEX_lin: 250        # €/kW\n  OEM_lin: 10           # €/kW/y\n  OEM_com: 0.02         # €/kWh/y, variable O&M from commitment\n  lifetime_y: 20        # years\n\n  eta: 0.94             # thermal efficiency\n  PCI: 9.97             # kWh/m³, lower heating value of fuel\n  fuel_price: 0.2       # €/m³\n\n  max_capacity: 60      # kWth maximum thermal output","category":"section"},{"location":"configuration/assets/#Parameters-7","page":"Asset types","title":"Parameters","text":"The full list of parameters for boiler assets is shown below:\n\nusing CSV, DataFrames, Latexify\ndf = CSV.read(\"../../src/configtables/boiler.csv\", DataFrame)\nmdtable(coalesce.(df, \"\"), latex=false, adjustment=:l)","category":"section"},{"location":"configuration/assets/#Thermal-Loads","page":"Asset types","title":"Thermal Loads","text":"Thermal loads represent time-dependent heating or cooling demand. They can be served by:\n\nheat pumps,\nboilers,\nthermal energy storage (TES).\n\nThe operating mode is determined by a profile value:\n\n+1 → heating mode\n−1 → cooling mode","category":"section"},{"location":"configuration/assets/#Example:-Thermal-Load","page":"Asset types","title":"Example: Thermal Load","text":"t_load:\n  type: t_load\n  corr_asset: [hp, boil, tes]   # assets that can satisfy this demand\n  profile:\n    t_load: t_load_u1_heat_cool # time-series for thermal demand\n    mode: mode                  # heating (+1) or cooling (-1)","category":"section"},{"location":"configuration/assets/#Parameters-8","page":"Asset types","title":"Parameters","text":"The full list of parameters for thermal load assets is shown below:\n\nusing CSV, DataFrames, Latexify\ndf = CSV.read(\"../../src/configtables/load_thermal.csv\", DataFrame)\nmdtable(coalesce.(df, \"\"), latex=false, adjustment=:l)","category":"section"},{"location":"configuration/assets/#Adjustable-Electrical-Loads","page":"Asset types","title":"Adjustable Electrical Loads","text":"Adjustable loads behave like a small virtual battery:\n\nthey can withdraw power from the grid,\nthey can feed power back (optional),\nthey track an internal \"energy\" state,\nthey must respect min/max energy and power bounds.\n\nThey allow modeling:\n\nEV charging,\nflexible appliances,\nshiftable industrial loads.","category":"section"},{"location":"configuration/assets/#Example:-Adjustable-Load","page":"Asset types","title":"Example: Adjustable Load","text":"load_adj:\n  type: load_adj\n\n  eta_P: 0.95               # efficiency when supplying (discharging)\n  eta_N: 0.95               # efficiency when absorbing (charging)\n\n  profile:\n    energy_exchange: load_user1_adj   # exogenous energy variations\n    max_supply: max_supply_user1      # max power supplied to grid\n    max_withdrawal: max_withdrawal_user1\n    min_energy: min_energy_user1      # minimum allowed \"energy\" state\n    max_energy: max_energy_user1      # maximum allowed \"energy\" state","category":"section"},{"location":"configuration/assets/#Parameters-9","page":"Asset types","title":"Parameters","text":"The full list of parameters for adjustable load assets is shown below:\n\nusing CSV, DataFrames, Latexify\ndf = CSV.read(\"../../src/configtables/load_adjustable.csv\", DataFrame)\nmdtable(coalesce.(df, \"\"), latex=false, adjustment=:l)","category":"section"},{"location":"theory_of_games/fair_allocation/#Fair-benefit-allocation","page":"Fair benefit allocation","title":"Fair benefit allocation","text":"","category":"section"},{"location":"theory_of_games/fair_allocation/#Scope-of-fair-allocation-in-energy-communities","page":"Fair benefit allocation","title":"Scope of fair allocation in energy communities","text":"EnergyCommunity.jl also provides tools for fair allocation of benefits among participants in an energy community supported by Game Theory. Fair allocation is crucial to ensure that all members are motivated to form, stay and contribute to the community's success. The package implements several well-known methods for fair allocation, including the Shapley value, the nucleolus, FairCore and FairLeastCore, among others, thanks to its interface with TheoryOfGames.jl. While the optimization model described in the previous sections focuses on minimizing the overall costs of the energy community, fair allocation methods ensure that the benefits derived from cost savings are distributed equitably among all participants. For more details, please refer to:\n\nD. Fioriti, A. Frangioni, D. Poli, \"Optimal sizing of energy communities with fair revenue sharing and exit clauses: Value, role and business model of aggregators and users,\" in Applied Energy, vol. 299, 2021, 117328,doi: 10.1016/j.apenergy.2021.117328\nD. Fioriti, G. Bigi, A. Frangioni, M. Passacantando and D. Poli, \"Fair Least Core: Efficient, Stable and Unique Game-Theoretic Reward Allocation in Energy Communities by Row-Generation,\" in IEEE Transactions on Energy Markets, Policy and Regulation, vol. 3, no. 2, pp. 170-181, June 2025, doi: 10.1109/TEMPR.2024.3495237.\n\nLet j in I be the set of participants (also known as \"grand coalition\") in the energy community (including the aggregator A), and let v(J) a generic function that describes the benefit of creating and participating in an energy community for any subgroup J subseteq I of participants. The goal of fair allocation methods is to distribute the total benefit v(I) among all participants in a way that is considered fair according to specific criteria defined by each method. In other words, the goal is to find an allocation vector phi_j    forall j in I where sum_j in I phi_j = v(I) and each phi_j represents the fair share of the benefit allocated to participant j. In the following section, we describe examples of supported fair allocation methods.","category":"section"},{"location":"theory_of_games/fair_allocation/#Benefit-function","page":"Fair benefit allocation","title":"Benefit function","text":"The benefit v(J) is typically calculated as the difference between the objective function SW^group_agg(J) obtained by a cooperative configuration (usually CO) and the value SW^group_base(J) obtained by a base configuration (typically NC). To account for the role of the aggregator, the behavior of the function depends on whether the aggregator A is part of the coalition J or not: when the aggregator is not included in the coalition, the benefit is calculated with respect to an alternative group SW^group_no-agg(J) (e.g., NC or ANC). Formally, the characteristic function v(J) is defined as follows:\n\nv(J) = begincases\n    SW^group_agg(J) - SW^group_base(J)  A in J \n    SW^group_no-agg(J) - SW^group_base(J)  A notin J\nendcases\n\nIn typical scenarios, the cooperative configuration is represented by CO, while the base configuration is NC. When a community is unable to create an EC with no external support, the alternative group without the aggregator can be represented by NC and the characteristic function simplifies to the following typical case:\n\nv(J) = begincases\n    SW^CO(J) - SW^NC(J)  A in J \n    0  A notin J\nendcases","category":"section"},{"location":"theory_of_games/fair_allocation/#Benefit-versus-users'-payoff","page":"Fair benefit allocation","title":"Benefit versus users' payoff","text":"As explained in the previous section, the benefit function v(J) quantifies the total advantage that a coalition of users J with respect to a base case allocation. Accordingly, the fair share of the benefit phi_j allocated to participant j represents the portion of the total benefit v(I) that is fairly assigned to that participant with respect to the base case configuration.\n\nTherefore, let's assume that each user j has a payoff mathrmNPV^base_j in the base case configuration (e.g., NC). The total payoff for user j after fair allocation of the benefit is given by the sum of the base case payoff and the allocated fair share of the benefit:\n\nmathrmNPV^fair_j = mathrmNPV^base_j + phi_j\n\nWhere:\n\nmathrmNPV^fair_j is the total payoff for user j after fair allocation.\nmathrmNPV^base_j is the payoff for user j in the base case configuration (usually NC).","category":"section"},{"location":"model/energy_model/#User-energy-model","page":"User energy model","title":"User energy model","text":"This section describes the mathematical model used to represent the energy system beyond power in EnergyCommunity.jl. The model integrates:\n\nHeat Pumps (HP): devices providing heating and cooling\nThermal Storage (TES): storage tanks with losses and capacity limits for heat and/or cool\nBoilers: fuel-fired boilers\nThermal Loads: time-varying heating/cooling demand","category":"section"},{"location":"model/energy_model/#Heat-Pumps","page":"User energy model","title":"Heat Pumps","text":"Each heat pump h in A^HP_j operated by user j consumes electricity P^HPel_jht to provide thermal power P^HP_jht, where x_jh is the variable of the nominal electrical capacity of the heat pump.\n\n0 le P^HPel_jht le x_jh\n\nThe heat pump can operate in either heating or cooling mode, determined by the variable mode: when mode is greater than or equal to +0.5, the heat pump operates in heating mode; when mode is less than or equal to –0.5, it operates in cooling mode.\n\nHeating power when mode ≥ +0.5\nCooling power when mode ≤ –0.5\n\nAccordingly, the thermal output P^HP_jht of the heat pump is defined based on the mode of operation using temperature-dependent COP/EER values:\n\nP^HP_jht =\nbegincases\n P^HPel_jht cdot COP_jht  text(heating mode)\n- P^HPel_jht cdot EER_jht  text(cooling mode)\nendcases\n\nThe performances of heat pump are modelled using a second-law efficiency multiplied by the Carnot efficiency:\n\nCOP_jht\n= eta^IIheat_jht\ncdot\nfracT_sinkT_sink - T_source(t)\n\nEER_jht\n= eta^IIcool_jht\ncdot\nfracT_source(t)T_sink - T_source(t)\n\nwhere:\n\neta^IIheat_jht and eta^IIcool_jht are the second-law efficiencies for heating and cooling, respectively.\nT_sink is the temperature of the heat sink (e.g., indoor temperature for heating, outdoor temperature for cooling).\nT_source(t) is the time-varying temperature of the heat source (e.g., outdoor temperature).","category":"section"},{"location":"model/energy_model/#Thermal-Storage-(TES)","page":"User energy model","title":"Thermal Storage (TES)","text":"Each thermal energy storage s in A^TES_j has volumetric capacity x_js and supports storing heat and/or cool depending on the input parameters and operation mode. The thermal energy E^TES_jst stored in the storage s at time step t is modelled depending on the specific heat capacity of the fluid cp_js, the reference temperature of the fluid in the storage in heating/cooling mode T^refheatcool_jst, and the input temperature of the fluid T^inheatcool_jst:\n\nWhen in heating mode (mode ≥ +0.5):\n\n0 le E^TES_jst le cp_js x_js left(T^refheat_jst - T^inheat_jst right)\n\nWhen in cooling mode (mode ≤ –0.5):\n\ncp_js x_js left(T^incool_jst - T^refcool_jst right) le E^TES_jst le 0\n\nTES loses heat proportionally by factor k_js to stored energy and to the temperature difference between the reference heating or cooling temperature of the fluid T^refheatcool_jst, in the storage and the unheated-zone temperature T^U_jst:\n\nWhen in heating mode (mode ≥ +0.5):\n\nL^TES_jst = k_js E^TES_jst-1 left(T^refheat_jst - T^U_jstright)\n\nWhen in cooling mode (mode ≤ –0.5):\n\nL^TES_jst = k_js E^TES_jst-1 left(T^U_jst - T^refcool_jstright)\n\nThe effective temperature T^U_jst is modelled as a fraction of the indoor–outdoor temperature gradient:\n\nT^U_jst = T^int_jst - b^tr_js left( T^int_jst - T^ext_jst right)\n\nwhere:\n\nT^int_jst = indoor reference temperature (user profile \"T_int\")\nT^ext_jst = external ambient temperature (user profile \"T_ext\")\nb^tr_js = thermal transmittance factor (\"b_tr_x\") controlling how much of the indoor–outdoor gradient affects the TES","category":"section"},{"location":"model/energy_model/#Boilers","page":"User energy model","title":"Boilers","text":"Boilers o in A^BOIL_j are fuel-fired heating units producing thermal power P^boil_jot. Their nominal capacity is represented by variable x_jo and limits the thermal power output:\n\n0 le P^boil_jot le x_jo","category":"section"},{"location":"model/energy_model/#Thermal-Energy-Balance","page":"User energy model","title":"Thermal Energy Balance","text":"For each user j at every time step t, the thermal balance equation ensures that thermal demand for each thermal load l is met by thermal technologies that feed to it:\n\nsum_s in A^TES_j(l) left E^TES_jst - E^TES_jst-1 + L^TES_jst right\n+\nP^th_jlt Delta_t\n=\nsum_h in A^HP_j(l) P^HP_jht Delta t\n+\nsum_o in A^BOIL_j(l) P^boil_jotDelta t\n quad forall l in A^TL_j\n\nwhere:\n\nA^TL_j is the set of thermal loads for user j\nA^TESHPBOIL_j is the set of thermal storages, heat pumps and boilers for user j that feed to the thermal load l\nP^th_jlt is the thermal power demand of load l at time t (positive for heating, negative for cooling)\nDelta_t is the time step duration\nL^TES_jst are the thermal losses from TES\nP^HP_jht is the thermal power provided by heat pumps\nP^boil_jot is the thermal power provided by boilers\nE^TES_jst is the energy stored in TES at time t","category":"section"},{"location":"API reference/#API-Reference","page":"API reference","title":"API Reference","text":"","category":"section"},{"location":"API reference/#Base.copy-Tuple{ModelEC}","page":"API reference","title":"Base.copy","text":"Base.copy(model_copy::ModelEC)\n\nCreate a copy of a ModelEC opject\n\nArguments\n\nmodel_copy::ModelEC: model to copy\n\n\n\n\n\n","category":"method"},{"location":"API reference/#Base.deepcopy-Tuple{ModelEC}","page":"API reference","title":"Base.deepcopy","text":"Base.deepcopy(model_copy::ModelEC)\n\nCreate a deepcopy of a ModelEC opject\n\nArguments\n\nmodel_copy::ModelEC: model to copy\n\n\n\n\n\n","category":"method"},{"location":"API reference/#Base.zero-Tuple{ModelEC}","page":"API reference","title":"Base.zero","text":"Base.zero(::ModelEC)\n\nFunction zero to represent the empty ModelEC\n\n\n\n\n\n","category":"method"},{"location":"API reference/#EnergyCommunity._jump_to_dict-Tuple{JuMP.Model}","page":"API reference","title":"EnergyCommunity._jump_to_dict","text":"_jump_to_dict\n\nFunction to turn a JuMP model to a dictionary\n\n\n\n\n\n","category":"method"},{"location":"API reference/#EnergyCommunity._print_summary-Tuple{IO, AbstractEC}","page":"API reference","title":"EnergyCommunity._print_summary","text":"_print_summary(io::IO, model::AbstractEC)\n\nPrint a plain-text summary of model to io.\n\n\n\n\n\n","category":"method"},{"location":"API reference/#EnergyCommunity._verify_data-Tuple{Dict}","page":"API reference","title":"EnergyCommunity._verify_data","text":"_verify_data(data::Dict)\n\nFunction to verify the data loaded from the disk (Not yet implemented)\n\n\n\n\n\n","category":"method"},{"location":"API reference/#EnergyCommunity._verify_users_data-Tuple{Dict}","page":"API reference","title":"EnergyCommunity._verify_users_data","text":"_verify_users_data(users_data::Dict)\n\nFunction to verify the users data loaded from the disk\n\n\n\n\n\n","category":"method"},{"location":"API reference/#EnergyCommunity.add_EC_economics_summary!-Tuple{Vector, AbstractEC}","page":"API reference","title":"EnergyCommunity.add_EC_economics_summary!","text":"add_EC_economics_summary!(output_list::Vector, ECModel::AbstractEC)\n\nFunction to create the output dataframe of the economics of the EC\n\n\n\n\n\n","category":"method"},{"location":"API reference/#EnergyCommunity.add_EC_peak_summary!-Tuple{Vector, AbstractEC}","page":"API reference","title":"EnergyCommunity.add_EC_peak_summary!","text":"add_EC_peak_summary!(output_list::Vector, ECModel::AbstractEC)\n\nFunction to create the output dataframe of peak power for the EC\n\n\n\n\n\n","category":"method"},{"location":"API reference/#EnergyCommunity.add_branching_priorities!-Tuple{AbstractEC, Any}","page":"API reference","title":"EnergyCommunity.add_branching_priorities!","text":"add_branching_priorities!(ECModel::AbstractEC, ::Any) end\n\nGeneral fallback for branching priorities\n\n\n\n\n\n","category":"method"},{"location":"API reference/#EnergyCommunity.add_info_solution_summary!-Tuple{Vector, AbstractEC}","page":"API reference","title":"EnergyCommunity.add_info_solution_summary!","text":"add_info_solution_summary!(output_list::Vector, ECModel::AbstractEC)\n\nUtility function to create the dataframe to report the status of the optimization. It adds a dataframe named info_solution to output_list with the solve time and the termination status of the optimization.\n\nArguments\n\noutput_list::Vector: The list of dataframes to be saved\nECModel::AbstractEC: The EC model to be built\n\n\n\n\n\n","category":"method"},{"location":"API reference/#EnergyCommunity.add_notations!-Tuple{AbstractEC, Any}","page":"API reference","title":"EnergyCommunity.add_notations!","text":"add_notations!(ECModel::AbstractEC, ::Any)\n\nGeneral fallback for notations\n\n\n\n\n\n","category":"method"},{"location":"API reference/#EnergyCommunity.add_users_design_summary!-Tuple{Vector, AbstractEC, AbstractVector}","page":"API reference","title":"EnergyCommunity.add_users_design_summary!","text":"add_users_design_summary!(output_list::Vector, ECModel::AbstractEC, user_set::AbstractVector)\n\nUtility function to create the output dataframe of design capacity. It adds a dataframe with the peak demand, yearly demand, and optimal size of the system for each user.\n\nArguments\n\noutput_list::Vector: The list of dataframes to be saved\nECModel::AbstractEC: The EC model to be built\nuser_set::AbstractVector: The user set to be considered\n\n\n\n\n\n","category":"method"},{"location":"API reference/#EnergyCommunity.add_users_economics_summary!-Tuple{Vector, AbstractEC, AbstractVector}","page":"API reference","title":"EnergyCommunity.add_users_economics_summary!","text":"add_users_economics_summary!(output_list::Vector, ECModel::AbstractEC, user_set::AbstractVector)\n\nFunction to create the output dataframe of the users' economics. It adds a dataframe with the NPV, CAPEX, OPEX, yearly revenues, and other economic indicators for each user.\n\nArguments\n\noutput_list::Vector: The list of dataframes to be saved\nECModel::AbstractEC: The EC model to be built\nuser_set::AbstractVector: The user set to be considered\n\n\n\n\n\n","category":"method"},{"location":"API reference/#EnergyCommunity.add_users_peak_summary!-Tuple{Vector, AbstractEC, AbstractVector}","page":"API reference","title":"EnergyCommunity.add_users_peak_summary!","text":"add_users_peak_summary!(output_list::Vector, ECModel::AbstractEC, user_set::AbstractVector)\n\nFunction to create the output dataframe of peak power. It adds a dataframe with the peak power of each user for each peak period.\n\nArguments\n\noutput_list::Vector: The list of dataframes to be saved\nECModel::AbstractEC: The EC model to be built\nuser_set::AbstractVector: The user set to be considered\n\n\n\n\n\n","category":"method"},{"location":"API reference/#EnergyCommunity.asset_names-Tuple{Any, ASSET_TYPE}","page":"API reference","title":"EnergyCommunity.asset_names","text":"Function to get the list of the assets for a user\n\n\n\n\n\n","category":"method"},{"location":"API reference/#EnergyCommunity.asset_names-Tuple{Any, Vector{ASSET_TYPE}}","page":"API reference","title":"EnergyCommunity.asset_names","text":"Function to get the list of the assets for a user in a list of elements\n\n\n\n\n\n","category":"method"},{"location":"API reference/#EnergyCommunity.asset_names-Tuple{Any}","page":"API reference","title":"EnergyCommunity.asset_names","text":"Function to get the list of the assets for a user\n\n\n\n\n\n","category":"method"},{"location":"API reference/#EnergyCommunity.asset_names_ex-Tuple{Any, Vector{ASSET_TYPE}}","page":"API reference","title":"EnergyCommunity.asset_names_ex","text":"Function to get the list of the assets for a user in a list of elements except a list of given types\n\n\n\n\n\n","category":"method"},{"location":"API reference/#EnergyCommunity.asset_type-Tuple{Any, Any}","page":"API reference","title":"EnergyCommunity.asset_type","text":"Function to get the asset type of a component\n\n\n\n\n\n","category":"method"},{"location":"API reference/#EnergyCommunity.build_base_model!-Tuple{AbstractEC, Any}","page":"API reference","title":"EnergyCommunity.build_base_model!","text":"build_base_model!(ECModel::AbstractEC, optimizer)\n\nCreates the base optimization model for all the EC models\n\nArguments\n\nECModel: EC model object\noptimizer: optimizer object; any optimizer from JuMP\nuse_notations: boolean; if true, the model will be created using the direct mode to create the JuMP model\n\nReturns\n\nIt returns the ECModel object with the base model created\n\n\n\n\n\n","category":"method"},{"location":"API reference/#EnergyCommunity.build_base_utility!-Tuple{AbstractEC, AbstractGroupANC}","page":"API reference","title":"EnergyCommunity.build_base_utility!","text":"build_base_utility!(ECModel::AbstractEC, base_group::AbstractGroupANC; base_model=nothing)\n\nWhen in the CO case the ANC model is used as base case, then this function builds the corresponding constraint\n\nArguments\n\nECModel::AbstractEC: Cooperative EC Model of the EC to study.\nbase_group::AbstractGroupANC: Type of the base case to consider\nbase_model::ModelEC: Model of the base case to consider\n\nReturns\n\nBaseUtility: JuMP expression of the base utility\n\n\n\n\n\n","category":"method"},{"location":"API reference/#EnergyCommunity.build_base_utility!-Tuple{AbstractEC, AbstractGroupNC}","page":"API reference","title":"EnergyCommunity.build_base_utility!","text":"build_base_utility!(ECModel::AbstractEC, base_group::AbstractGroupNC; base_model=nothing)\n\nWhen in the CO case the NC model is used as base case, then this function builds the corresponding constraint\n\nArguments\n\nECModel::AbstractEC: Cooperative EC Model of the EC to study.\nbase_group::AbstractGroupNC: Type of the base case to consider\nbase_model::ModelEC: Model of the base case to consider\n\nReturns\n\nBaseUtility: JuMP expression of the base utility\n\n\n\n\n\n","category":"method"},{"location":"API reference/#EnergyCommunity.build_base_utility!-Tuple{AbstractEC, Vararg{Any}}","page":"API reference","title":"EnergyCommunity.build_base_utility!","text":"build_base_utility!(ECModel::AbstractEC, no_aggregator_group::AbstractGroupANC)\n\nWhen in the CO case the ANC model is used as reference case for when the aggregator is not in the group, then this function builds the corresponding constraint\n\nNot implemented\n\n\n\n\n\n","category":"method"},{"location":"API reference/#EnergyCommunity.build_least_profitable!-Tuple{AbstractEC, AbstractGroup}","page":"API reference","title":"EnergyCommunity.build_least_profitable!","text":"build_least_profitable!(\n    ECModel::AbstractEC, base_group::AbstractGroup;\n    no_aggregator_group::AbstractGroup=GroupNC(),\n    add_EC=true,\n    relax_combinatorial=false,\n    use_notations=false,\n    base_model=nothing,\n)\n\nFunction to build the model to identify the least profitable coalition. This function builds the model in the ECModel object to identify the least profitable coalition using a MILP model.\n\nArguments\n\nECModel::AbstractEC: EC Model of the EC to study.\nbase_group::AbstractGroup: Type of the base case to consider\nno_aggregator_group::AbstractGroup=GroupNC(): Type of the base case to consider when no aggregator is in the coalition\nadd_EC::Bool=true: Flag to include the EC in the coalition\nrelax_combinatorial::Bool=false: Flag to relax the combinatorial part of the MILP model\nuse_notations::Bool=false: Flag to use notations in the model\nbase_model::ModelEC=nothing: Model of the base case to consider\n\n\n\n\n\n","category":"method"},{"location":"API reference/#EnergyCommunity.build_model!-Tuple{AbstractEC}","page":"API reference","title":"EnergyCommunity.build_model!","text":"build_model!(ECModel::AbstractEC; kwargs...)\n\nBuild the mathematical problem for the EC.\n\n\n\n\n\n","category":"method"},{"location":"API reference/#EnergyCommunity.build_model!-Tuple{AbstractGroup, AbstractEC, Any}","page":"API reference","title":"EnergyCommunity.build_model!","text":"build_model!(group_type::AbstractGroup, ECModel::AbstractEC, optimizer; use_notations=false)\n\nBuild function model for generic EnergyCommunity model. This functions triggers specific functions for the different aggregation types.\n\nIn particular, first the function build_base_model! is called to build the base model of the EC. Then, the function build_specific_model! is called to build the specific model of the EC dependin on the group type. Finally, the function set_objective! is called to set the objective of the EC, based on their group type.\n\n\n\n\n\n","category":"method"},{"location":"API reference/#EnergyCommunity.build_no_agg_utility!-Tuple{AbstractEC, AbstractGroupANC}","page":"API reference","title":"EnergyCommunity.build_no_agg_utility!","text":"build_no_agg_utility!(ECModel::AbstractEC, no_aggregator_group::AbstractGroupANC; base_model=nothing)\n\nWhen in the CO case the ANC model is used as reference case for when the aggregator is not in the group, then this function builds the corresponding constraint\n\nArguments\n\nECModel::AbstractEC: Cooperative EC Model of the EC to study.\nno_aggregator_group::AbstractGroupANC: Type of the base case to consider\nbase_model::ModelEC: Model of the base case to consider\n\nReturns\n\nSW: JuMP expression of the Social Welfare\n\n\n\n\n\n","category":"method"},{"location":"API reference/#EnergyCommunity.build_no_agg_utility!-Tuple{AbstractEC, AbstractGroupNC}","page":"API reference","title":"EnergyCommunity.build_no_agg_utility!","text":"buildnoaggutility!(ECModel::AbstractEC, noaggregator_group::AbstractGroupNC; kwargs...)\n\nWhen the NC case is the reference value when no aggregator is available, then no changes in the model are required\n\nArguments\n\nECModel::AbstractEC: Cooperative EC Model of the EC to study.\nno_aggregator_group::AbstractGroupNC: Type of the base case to consider\n\nReturns\n\nSW: JuMP expression of the Social Welfare; the same as in the input model\n\n\n\n\n\n","category":"method"},{"location":"API reference/#EnergyCommunity.build_no_agg_utility!-Tuple{AbstractEC, Any}","page":"API reference","title":"EnergyCommunity.build_no_agg_utility!","text":"build_no_agg_utility!(ECModel::AbstractEC, no_aggregator_group::Any)\n\nNot implemented case\n\n\n\n\n\n","category":"method"},{"location":"API reference/#EnergyCommunity.build_noagg_least_profitable!-Tuple{ModelEC}","page":"API reference","title":"EnergyCommunity.build_noagg_least_profitable!","text":"build_noagg_least_profitable(ECModel::ModelEC; use_notations=false, optimizer=nothing, base_model=nothing)\n\nFunction to create a specialized model to identify the least profitable coalition for an energy community of ANC type.\n\nArguments\n\nECModel::ModelEC: Model of the community\nuse_notations::Bool=false: Flag to use notations in the model\noptimizer::Optimizer=nothing: Optimizer to use\nbase_model::ModelEC=nothing: Model of the base case to consider\n\n\n\n\n\n","category":"method"},{"location":"API reference/#EnergyCommunity.build_specific_model!-Tuple{AbstractGroupANC, AbstractEC}","page":"API reference","title":"EnergyCommunity.build_specific_model!","text":"build_specific_model!(::AbstractGroupANC, ECModel::AbstractEC)\n\nSet the ANC-specific model for the EC\n\n\n\n\n\n","category":"method"},{"location":"API reference/#EnergyCommunity.build_specific_model!-Tuple{AbstractGroupCO, AbstractEC}","page":"API reference","title":"EnergyCommunity.build_specific_model!","text":"build_specific_model!(::AbstractGroupCO, ECModel::AbstractEC)\n\nSet the CO-specific model for the EC\n\n\n\n\n\n","category":"method"},{"location":"API reference/#EnergyCommunity.build_specific_model!-Tuple{AbstractGroupNC, AbstractEC}","page":"API reference","title":"EnergyCommunity.build_specific_model!","text":"build_specific_model!(::AbstractGroupNC, ECModel::AbstractEC)\n\nSet the NC-specific model for the EC. It adds the P_agg expression only being equal to the sum of the power supplied by the users to the grid.\n\nArguments\n\ngroup_type::AbstractGroupNC: The type of group model\nECModel::AbstractEC: The EC model to be built\n\nReturns\n\nECModel::AbstractEC: The EC model with the specific model built\n\n\n\n\n\n","category":"method"},{"location":"API reference/#EnergyCommunity.business_plan","page":"API reference","title":"EnergyCommunity.business_plan","text":"business_plan(ECModel::AbstractEC, profit_distribution=nothing, user_set_financial=nothing)\n\nFunction to describe the business plan\n\nArguments\n\nECModel::AbstractEC: Energy Community model\nprofit_distribution: (optional) DenseAxisArray with the profit distribution by user\nuser_set_financial: (optional) User set to be considered for the financial analysis\n\nReturns\n\nThe output value is a DataFrame with the business plan information\n\n\n\n\n\n","category":"function"},{"location":"API reference/#EnergyCommunity.business_plan_plot","page":"API reference","title":"EnergyCommunity.business_plan_plot","text":"business_plan_plot(ECModel::AbstractEC, ...)\n\nFunction to plot the business plan of the EnergyCommunity.\n\nArguments\n\nECModel::AbstractEC: Energy Community model\nprofit_distribution: (optional) Dictionary with the profit distribution by user\nuser_set_financial: (optional) User set to be considered for the financial analysis\nplot_struct: (optional) Dictionary with the structure of the plot. The keys are the labels of the bars and the values are a list of tuples with the sign and the name of the variable to be plotted. Example is Dict(\"CAPEX\" => [(-1, :CAPEX)]) for plotting the CAPEX with a negative sign.\nxlabel: (optional) Label for the x-axis\nylabel: (optional) Label for the y-axis\ntitle: (optional) Title of the plot\nlegend: (optional) Position of the legend\ncolor: (optional) Color of the bars\nxrotation: (optional) Rotation of the x-axis labels\nbar_width: (optional) Width of the bars\ngrid: (optional) Grid visibility\nframestyle: (optional) Style of the frame\nbarmode: (optional) Mode of the bars\nscaling_factor: (optional) Scaling factor for the values\nkwargs: (optional) Additional arguments to be passed to Plots.bar function\n\n\n\n\n\n","category":"function"},{"location":"API reference/#EnergyCommunity.calculate_demand-Tuple{AbstractEC}","page":"API reference","title":"EnergyCommunity.calculate_demand","text":"calculate_demand(ECModel::AbstractEC)\n\nFunction to calculate the demand by user\n\nArguments\n\nECModel: EC model object\n\nReturns\n\nIt returns the demand by user and the whole EC as a DenseAxisArray\n\n\n\n\n\n","category":"method"},{"location":"API reference/#EnergyCommunity.calculate_grid_export-Tuple{AbstractEC}","page":"API reference","title":"EnergyCommunity.calculate_grid_export","text":"calculate_grid_export(ECModel::AbstractEC; per_unit::Bool=true)\n\nCalculate grid export for the energy community and users. Output is normalized with respect to the demand when per_unit is true\n\nReturns\n\nIt returns a DenseAxisArray containing the power fed to the grid for each user and the whole aggregate\n\n\n\n\n\n","category":"method"},{"location":"API reference/#EnergyCommunity.calculate_grid_export-Tuple{AbstractGroupANC, AbstractEC}","page":"API reference","title":"EnergyCommunity.calculate_grid_export","text":"calculate_grid_export(::AbstractGroupANC, ECModel::AbstractEC; per_unit::Bool=true)\n\nCalculate grid export for the Aggregated Non Cooperative case. Output is normalized with respect to the demand when per_unit is true\n\nReturns\n\nIt returns a DenseAxisArray containing the power fed to the grid for each user and the whole aggregate\n\n\n\n\n\n","category":"method"},{"location":"API reference/#EnergyCommunity.calculate_grid_export-Tuple{AbstractGroupCO, AbstractEC}","page":"API reference","title":"EnergyCommunity.calculate_grid_export","text":"calculate_grid_export(::AbstractGroupCO, ECModel::AbstractEC; per_unit::Bool=true)\n\nCalculate grid export for the Cooperative case. Output is normalized with respect to the demand when per_unit is true\n\nReturns\n\nReturns a DenseAxisArray that contains the reliance on the grid supply for each user and the aggregation\n\n\n\n\n\n","category":"method"},{"location":"API reference/#EnergyCommunity.calculate_grid_export-Tuple{AbstractGroupNC, AbstractEC}","page":"API reference","title":"EnergyCommunity.calculate_grid_export","text":"calculate_grid_export(::AbstractGroupNC, ECModel::AbstractEC; per_unit::Bool=true)\n\nCalculate grid export for the Non-Cooperative case Output is normalized with respect to the demand when per_unit is true\n\nReturns\n\nReturns a DenseAxisArray that contains the reliance on the grid supply for each user and the aggregation\n\n\n\n\n\n","category":"method"},{"location":"API reference/#EnergyCommunity.calculate_grid_import-Tuple{AbstractEC}","page":"API reference","title":"EnergyCommunity.calculate_grid_import","text":"calculate_grid_import(ECModel::AbstractEC; per_unit::Bool=true)\n\nCalculate grid usage for the energy community and users. Output is normalized with respect to the demand when per_unit is true\n\nReturns\n\nIt returns a DenseAxisArray containing the power withdrawn from the grid for each user and the whole aggregate\n\n\n\n\n\n","category":"method"},{"location":"API reference/#EnergyCommunity.calculate_grid_import-Tuple{AbstractGroupANC, AbstractEC}","page":"API reference","title":"EnergyCommunity.calculate_grid_import","text":"calculate_grid_import(::AbstractGroupANC, ECModel::AbstractEC; per_unit::Bool=true)\n\nCalculate grid usage for the Aggregated Non Cooperative case. Output is normalized with respect to the demand when per_unit is true\n\nReturns\n\nIt returns a DenseAxisArray containing the power withdrawn from the grid for each user and the whole aggregate\n\n\n\n\n\n","category":"method"},{"location":"API reference/#EnergyCommunity.calculate_grid_import-Tuple{AbstractGroupCO, AbstractEC}","page":"API reference","title":"EnergyCommunity.calculate_grid_import","text":"calculate_grid_import(::AbstractGroupCO, ECModel::AbstractEC; per_unit::Bool=true)\n\nCalculate grid usage for the Cooperative case. Output is normalized with respect to the demand when per_unit is true\n\nReturns\n\nReturns a DenseAxisArray that describes the reliance on the grid withdrawal for each user and the aggregation\n\n\n\n\n\n","category":"method"},{"location":"API reference/#EnergyCommunity.calculate_grid_import-Tuple{AbstractGroupNC, AbstractEC}","page":"API reference","title":"EnergyCommunity.calculate_grid_import","text":"calculate_grid_import(::AbstractGroupNC, ECModel::AbstractEC; per_unit::Bool=true)\n\nCalculate grid usage for the Non Cooperative case. Output is normalized with respect to the demand when per_unit is true\n\nReturns\n\nReturns a DenseAxisArray that describes the reliance on the grid withdrawal for each user and the aggregation\n\n\n\n\n\n","category":"method"},{"location":"API reference/#EnergyCommunity.calculate_production-Tuple{AbstractEC}","page":"API reference","title":"EnergyCommunity.calculate_production","text":"calculate_production(ECModel::AbstractEC)\n\nFunction to calculate the energy production by user\n\nArguments\n\nECModel: EC model object\n\nReturns\n\nIt returns the production by user and the whole EC as a DenseAxisArray\n\n\n\n\n\n","category":"method"},{"location":"API reference/#EnergyCommunity.calculate_production_shares-Tuple{AbstractEC}","page":"API reference","title":"EnergyCommunity.calculate_production_shares","text":"calculate_production_shares(ECModel::AbstractEC; per_unit::Bool=true)\n\nCalculate energy ratio by energy production resource for a generic group Output is normalized with respect to the demand when per_unit is true\n\nArguments\n\nECModel: EC model object\nper_unit: boolean; if true, the output is normalized with respect to the demand\n\nReturns\n\nIt returns a DenseAxisArray describing the share of energy production by  energy resource by user and the entire system, optionally normalized with respect to the demand of the corresponding group, when per_unit is true\n\n\n\n\n\n","category":"method"},{"location":"API reference/#EnergyCommunity.calculate_self_consumption-Tuple{AbstractEC}","page":"API reference","title":"EnergyCommunity.calculate_self_consumption","text":"calculate_self_consumption(ECModel::AbstractEC; per_unit::Bool=true)\n\nCalculate the demand that each user meets using its own sources, or self consumption. Output is normalized with respect to the demand when per_unit is true\n\nArguments\n\nECModel: EC model object\nper_unit: boolean; if true, the output is normalized with respect to the demand\n\nReturns\n\nIt returns a DenseAxisArray describing the self consumption for each user and the aggregation, optionally normalized with respect to the demand of the corresponding group, when per_unit is true\n\n\n\n\n\n","category":"method"},{"location":"API reference/#EnergyCommunity.calculate_self_production-Tuple{AbstractEC}","page":"API reference","title":"EnergyCommunity.calculate_self_production","text":"calculate_self_production(ECModel::AbstractEC; per_unit::Bool=true)\n\nCalculate the self production for each user. Output is normalized with respect to the demand when per_unit is true\n\nArguments\n\nECModel: EC model object\nper_unit: boolean; if true, the output is normalized with respect to the demand\n\nReturns\n\nIt returns a DenseAxisArray describing the self production for each user and the aggregation, optionally normalized with respect to the demand of the corresponding group, when per_unit is true\n\n\n\n\n\n","category":"method"},{"location":"API reference/#EnergyCommunity.calculate_shared_consumption-Tuple{AbstractEC}","page":"API reference","title":"EnergyCommunity.calculate_shared_consumption","text":"calculate_shared_consumption(ECModel::AbstractEC; per_unit::Bool=true)\n\nCalculate the demand that each user meets using its own sources or other users. When onlyshared is false, also self consumption is considered, otherwise only shared consumption. Output is normalized with respect to the demand when perunit is true\n\nReturns\n\nIt returns a DenseAxisArray containing the time-dependent share of power withdrawn from the grid but consumed by another user for each user and the whole aggregate\n\n\n\n\n\n","category":"method"},{"location":"API reference/#EnergyCommunity.calculate_shared_consumption-Tuple{AbstractGroupANC, AbstractEC}","page":"API reference","title":"EnergyCommunity.calculate_shared_consumption","text":"calculate_shared_consumption(::AbstractGroupANC, ECModel::AbstractEC; per_unit::Bool=true, only_shared::Bool=false)\n\nCalculate the demand that each user meets using its own sources or other users for the Aggregated Non Cooperative case. In this case, there can be shared energy, non only self consumption. When onlyshared is false, also self consumption is considered, otherwise only shared energy. Shared energy means energy that is shared between  Output is normalized with respect to the demand when perunit is true\n\nReturns\n\nIt returns a DenseAxisArray containing the time-dependent share of power withdrawn from the grid but produced by another user for each user and the whole aggregate\n\n\n\n\n\n","category":"method"},{"location":"API reference/#EnergyCommunity.calculate_shared_consumption-Tuple{AbstractGroupCO, AbstractEC}","page":"API reference","title":"EnergyCommunity.calculate_shared_consumption","text":"calculate_shared_consumption(::AbstractGroupCO, ECModel::AbstractEC; per_unit::Bool=true, only_shared::Bool=false)\n\nCalculate the demand that each user meets using its own sources or other users for the Cooperative case. In the Cooperative case, there can be shared energy, non only self consumption. When onlyshared is false, also self consumption is considered, otherwise only shared energy. Shared energy means energy that is shared between  Output is normalized with respect to the demand when perunit is true\n\nReturns\n\nIt returns the shared consumption for each user and the aggregation\n\n\n\n\n\n","category":"method"},{"location":"API reference/#EnergyCommunity.calculate_shared_consumption-Tuple{AbstractGroupNC, AbstractEC}","page":"API reference","title":"EnergyCommunity.calculate_shared_consumption","text":"calculate_shared_consumption(::AbstractGroupNC, ECModel::AbstractEC; kwargs...)\n\nCalculate the demand that each user meets using its own sources or other users for the Non-Cooperative case. In the Non-Cooperative case, there is no shared energy, only self consumption. Shared energy means energy that is shared between  Output is normalized with respect to the demand when per_unit is true\n\nReturns\n\nIt returns the shared consumption for each user and the aggregation\n\n\n\n\n\n","category":"method"},{"location":"API reference/#EnergyCommunity.calculate_shared_production-Tuple{AbstractEC}","page":"API reference","title":"EnergyCommunity.calculate_shared_production","text":"calculate_shared_production(ECModel::AbstractEC; per_unit::Bool=true)\n\nCalculate the energy that each user produces and uses in its own POD or it is commercially consumed within the EC, when creaded. When onlyshared is false, also self production is considered, otherwise only shared energy. Output is normalized with respect to the demand when perunit is true\n\nReturns\n\nIt returns a DenseAxisArray containing the time-dependent share of power fed to the grid but consumed by another user for each user and the whole aggregate\n\n\n\n\n\n","category":"method"},{"location":"API reference/#EnergyCommunity.calculate_shared_production-Tuple{AbstractGroupANC, AbstractEC}","page":"API reference","title":"EnergyCommunity.calculate_shared_production","text":"calculate_shared_production(::AbstractGroupANC, ECModel::AbstractEC; per_unit::Bool=true, only_shared::Bool=false)\n\nCalculate the shared produced energy for the Aggregated Non Cooperative case. In this case, there can be shared energy between users, not only self production. When onlyshared is false, also self production is considered, otherwise only shared energy. Shared energy means energy that is shared between  Output is normalized with respect to the demand when perunit is true\n\nReturns\n\nIt returns a DenseAxisArray containing the time-dependent share of power fed to the grid but consumed by another user for each user and the whole aggregate\n\n\n\n\n\n","category":"method"},{"location":"API reference/#EnergyCommunity.calculate_shared_production-Tuple{AbstractGroupCO, AbstractEC}","page":"API reference","title":"EnergyCommunity.calculate_shared_production","text":"calculate_shared_production(::AbstractGroupCO, ECModel::AbstractEC; per_unit::Bool=true, only_shared::Bool=false)\n\nCalculate the shared produced energy for the Cooperative case. In the Cooperative case, there can be shared energy between users, not only self production. When onlyshared is false, also self production is considered, otherwise only shared energy. Shared energy means energy that is shared between  Output is normalized with respect to the demand when perunit is true\n\nReturns\n\nIt returns a DenseAxisArray that contains the shared energy for each user and the aggregation\n\n\n\n\n\n","category":"method"},{"location":"API reference/#EnergyCommunity.calculate_shared_production-Tuple{AbstractGroupNC, AbstractEC}","page":"API reference","title":"EnergyCommunity.calculate_shared_production","text":"calculate_shared_production(::AbstractGroupNC, ECModel::AbstractEC; kwargs...)\n\nCalculate the shared produced energy for the Non-Cooperative case. In the Non-Cooperative case, there is no shared energy between users, only self production. Output is normalized with respect to the demand when per_unit is true\n\nReturns\n\nIt returns a DenseAxisArray that contains the shared energy for each user and the aggregation\n\n\n\n\n\n","category":"method"},{"location":"API reference/#EnergyCommunity.calculate_tes_losses-Tuple{AbstractEC}","page":"API reference","title":"EnergyCommunity.calculate_tes_losses","text":"calculate_tes_losses(ECModel::AbstractEC)\n\nFunction to calculate the thermal energy losses by thermal storage by user\n\nArguments\n\nECModel: EC model object\n\nReturns\n\nIt returns the thermal energy losses by user /and the whole EC/ as a DenseAxisArray\n\n\n\n\n\n","category":"method"},{"location":"API reference/#EnergyCommunity.calculate_th_consumption-Tuple{AbstractEC}","page":"API reference","title":"EnergyCommunity.calculate_th_consumption","text":"calculate_th_consumption(ECModel::AbstractEC)\n\nFunction to calculate the economic thermal energy consumption by user\n\nArguments\n\nECModel: EC model object\n\nReturns\n\nIt returns the thermal economic consumption by user /and the whole EC/ as a DenseAxisArray\n\n\n\n\n\n","category":"method"},{"location":"API reference/#EnergyCommunity.calculate_th_demand-Tuple{AbstractEC}","page":"API reference","title":"EnergyCommunity.calculate_th_demand","text":"calculate_th_demand(ECModel::AbstractEC)\n\nFunction to calculate the thermal demand by user\n\nArguments\n\nECModel: EC model object\n\nReturns\n\nIt returns the thermal demand by user /and the whole EC/ as a DenseAxisArray\n\n\n\n\n\n","category":"method"},{"location":"API reference/#EnergyCommunity.calculate_th_production-Tuple{AbstractEC}","page":"API reference","title":"EnergyCommunity.calculate_th_production","text":"calculate_th_production(ECModel::AbstractEC)\n\nFunction to calculate the thermal energy production by user\n\nArguments\n\nECModel: EC model object\n\nReturns\n\nIt returns the thermal production by user /and the whole EC/ as a DenseAxisArray\n\n\n\n\n\n","category":"method"},{"location":"API reference/#EnergyCommunity.calculate_time_shared_consumption-Tuple{AbstractEC}","page":"API reference","title":"EnergyCommunity.calculate_time_shared_consumption","text":"calculate_time_shared_consumption(ECModel::AbstractEC)\n\nCalculate the time series of the shared consumed energy for the Energy Community.\n\nFor every time step and user, this time series highlight the quantity of load that is met by using shared energy.\n\nReturns\n\nIt returns a DenseAxisArray containing the time-dependent share of power withdrawn from the grid but produced by another user for each user and the whole aggregate\n\n\n\n\n\n","category":"method"},{"location":"API reference/#EnergyCommunity.calculate_time_shared_consumption-Tuple{AbstractGroupANC, AbstractEC}","page":"API reference","title":"EnergyCommunity.calculate_time_shared_consumption","text":"calculate_time_shared_consumption(::AbstractGroupANC, ECModel::AbstractEC; add_EC=true, kwargs...)\n\nCalculate the time series of the shared consumed energy for the Aggregated Non Cooperative case. In the Aggregated Non Cooperative case, there can be shared energy between users, not only self production.\n\nFor every time step and user, this time series highlight the quantity of load that is met by using shared energy.\n\nReturns\n\nIt returns a DenseAxisArray containing the time-dependent share of power withdrawn from the grid but produced by another user for each user and the whole aggregate\n\n\n\n\n\n","category":"method"},{"location":"API reference/#EnergyCommunity.calculate_time_shared_consumption-Tuple{AbstractGroupCO, AbstractEC}","page":"API reference","title":"EnergyCommunity.calculate_time_shared_consumption","text":"calculate_time_shared_consumption(::AbstractGroupCO, ECModel::AbstractEC; add_EC=true, kwargs...)\n\nCalculate the time series of the shared consumed energy for the Cooperative case. In the Cooperative case, there can be shared energy between users, not only self production.\n\nFor every time step and user, this time series highlight the quantity of load that is met by using shared energy.\n\nReturns\n\nIt returns a DenseAxisArray that quantifies the shared consumption for each user and the aggregation and time step\n\n\n\n\n\n","category":"method"},{"location":"API reference/#EnergyCommunity.calculate_time_shared_consumption-Tuple{AbstractGroupNC, AbstractEC}","page":"API reference","title":"EnergyCommunity.calculate_time_shared_consumption","text":"calculate_time_shared_consumption(::AbstractGroupNC, ECModel::AbstractEC; add_EC=true, kwargs...)\n\nCalculate the time series of the shared consumed energy for the Cooperative case. In the Cooperative case, there can be shared energy between users, not only self production.\n\nFor every time step and user, this time series highlight the quantity of load that is met by using shared energy.\n\nReturns\n\nIt returns a DenseAxisArray that quantifies the shared consumption for each user and the aggregation and time step\n\n\n\n\n\n","category":"method"},{"location":"API reference/#EnergyCommunity.calculate_time_shared_production-Tuple{AbstractEC}","page":"API reference","title":"EnergyCommunity.calculate_time_shared_production","text":"calculate_time_shared_production(ECModel::AbstractEC; kwargs...)\n\nCalculate the time series of the shared consumed energy for the Energy Community.\n\nFor every time step and user, this time series highlight the quantity of production that meets needs by other users.\n\nReturns\n\nIt returns a DenseAxisArray containing the time-dependent share of power fed to the grid but consumed by another user for each user and the whole aggregate\n\n\n\n\n\n","category":"method"},{"location":"API reference/#EnergyCommunity.calculate_time_shared_production-Tuple{AbstractGroupANC, AbstractEC}","page":"API reference","title":"EnergyCommunity.calculate_time_shared_production","text":"calculate_time_shared_production(::AbstractGroupANC, ECModel::AbstractEC; add_EC=true, kwargs...)\n\nCalculate the time series of the shared produced energy for the Aggregated Non Cooperative case. In the Aggregated Non Cooperative case, there can be shared energy between users, not only self production.\n\nFor every time step and user, this time series highlight the quantity of production that meets needs by other users.\n\nReturns\n\nIt returns a DenseAxisArray containing the time-dependent share of power fed to the grid but consumed by another user for each user and the whole aggregate\n\n\n\n\n\n","category":"method"},{"location":"API reference/#EnergyCommunity.calculate_time_shared_production-Tuple{AbstractGroupCO, AbstractEC}","page":"API reference","title":"EnergyCommunity.calculate_time_shared_production","text":"calculate_time_shared_production(::AbstractGroupCO, ECModel::AbstractEC; add_EC=true, kwargs...)\n\nCalculate the time series of the shared produced energy for the Cooperative case. In the Cooperative case, there can be shared energy between users, not only self production.\n\nFor every time step and user, this time series highlight the quantity of production that meets needs by other users.\n\nReturns\n\nReturns a DenseAxisArray that contains the shared production for each user and the aggregation and time step\n\n\n\n\n\n","category":"method"},{"location":"API reference/#EnergyCommunity.calculate_time_shared_production-Tuple{AbstractGroupNC, AbstractEC}","page":"API reference","title":"EnergyCommunity.calculate_time_shared_production","text":"calculate_time_shared_production(::AbstractGroupNC, ECModel::AbstractEC; add_EC=true, kwargs...)\n\nCalculate the time series of the shared produced energy for the Cooperative case. In the Cooperative case, there can be shared energy between users, not only self production.\n\nFor every time step and user, this time series highlight the quantity of production that meets needs by other users.\n\nReturns\n\nReturns a DenseAxisArray that contains the shared production for each user and the aggregation and time step\n\n\n\n\n\n","category":"method"},{"location":"API reference/#EnergyCommunity.check_valid_data_dict-Tuple{Dict}","page":"API reference","title":"EnergyCommunity.check_valid_data_dict","text":"check_valid_data_dict(raw_dict_data::Dict)\n\nCheck whether the dictionary data has the needed components. The dictionary must have the keys \"general\", \"users\", and \"market\".\n\n\n\n\n\n","category":"method"},{"location":"API reference/#EnergyCommunity.component-Tuple{Any, Any}","page":"API reference","title":"EnergyCommunity.component","text":"Function to get the components value of a dictionary\n\n\n\n\n\n","category":"method"},{"location":"API reference/#EnergyCommunity.components-Tuple{AbstractDict}","page":"API reference","title":"EnergyCommunity.components","text":"Function to get the components list of a dictionary\n\n\n\n\n\n","category":"method"},{"location":"API reference/#EnergyCommunity.create_example_data-Tuple{Any}","page":"API reference","title":"EnergyCommunity.create_example_data","text":"create_example_data(parent_folder, config_name::String = \"default\")\n\nCreate an example data for the Energy Community model. This function creates in the specified folder the necessary data to run the Energy Community model, based on the specified configuration name.\n\nArguments\n\nparent_folder: Parent folder where the example data will be created\nconfig_name: Configuration name to be used to create the example data   Supported values: \"default\"\n\n\n\n\n\n","category":"method"},{"location":"API reference/#EnergyCommunity.create_output_data-Tuple{ModelEC, Any}","page":"API reference","title":"EnergyCommunity.create_output_data","text":"create_output_data(ecm_copy::ModelEC, number_of_solutions)\n\nFunction to create output data after the optimization for TheoryOfGames.jl. This functions obtains multiple solutions out of the optimization.\n\nArguments\n\necm_copy::ModelEC: Model of the community\nnumber_of_solutions::Int: Number of solutions to return\n\nReturns\n\noutput_data::Vector{NamedTuple}: Output data\n\n\n\n\n\n","category":"method"},{"location":"API reference/#EnergyCommunity.data_sankey-Tuple{AbstractEC}","page":"API reference","title":"EnergyCommunity.data_sankey","text":"data_sankey(ECModel::AbstractEC; name_units=nothing, norm_value=nothing, market_color = palette(:rainbow)[2], community_color = palette(:rainbow)[5], users_colors = palette(:default))\n\nFunction to create the input data for plotting any Sankey diagram representing the energy flows across the energy community\n\nArguments\n\nECModel::AbstractEC: Energy Community model\nname_units: (optional) Labels used for the sankey diagram with the following order:   \"Market buy\", [users labels], \"Community\", \"Market sell\", [users labels]\nnorm_value: (optional) Normalization value for the flows\nmarket_color: (optional) Color of the market\ncommunity_color: (optional) Color of the community\nusers_colors: (optional) Colors of the users\n\nReturns\n\nsank_data: Dictionary containing the data to plot the Sankey diagram, in agreement to SankeyPlots.jl package\n\"source\": sources of the Sankey\n\"target\": targets of the Sankey\n\"value\": value of each flow\n\"labels\": labels of the Sankey\n\"colors\": colors of the Sankey\n\"layer\": layer of the Sankey\n\"order\": order of the Sankey\n\n\n\n\n\n","category":"method"},{"location":"API reference/#EnergyCommunity.delta_t_tes_lb-NTuple{4, Any}","page":"API reference","title":"EnergyCommunity.delta_t_tes_lb","text":"delta_t_tes_lb(users_data, u, s, t)\n\nFunction to compute the lower bound of the temperature difference for a thermal energy storage (TES) at time t. When the thermal load the TES is linked to is in cooling mode, the lower bound is the difference between the reference temperature (Trefcool) and the input temperature (Tinputcool) for cooling. When the load is in heating mode, the lower bound is 0.0. The corresponding thermal load is identified by the corr_asset field in the load component.\n\nArguments\n\nusers_data: dictionary with the users data\nu: user index\ns: name of the thermal energy storage\nt: time index\n\nReturns\n\n[°C] The lower bound of the temperature difference for the TES at time t\n\n\n\n\n\n","category":"method"},{"location":"API reference/#EnergyCommunity.delta_t_tes_ub-NTuple{4, Any}","page":"API reference","title":"EnergyCommunity.delta_t_tes_ub","text":"delta_t_tes_ub(users_data, u, s, t)\n\nFunction to compute the upper bound of the temperature difference for a thermal energy storage (TES) at time t. When the thermal load the TES is linked to is in heating mode, the upper bound is the difference between the reference temperature (Trefheat) and the input temperature (Tinputheat) for heating. When the load is in cooling mode, the upper bound is 0.0. The corresponding thermal load is identified by the corr_asset field in the first load component that contains the object.\n\nArguments\n\nusers_data: dictionary with the users data\nu: user index\ns: name of the thermal energy storage\nt: time index\n\nReturns\n\n[°C] The lower bound of the temperature difference for the TES at time t\n\n\n\n\n\n","category":"method"},{"location":"API reference/#EnergyCommunity.device_names-Tuple{Any}","page":"API reference","title":"EnergyCommunity.device_names","text":"Function to get the list of devices for a user\n\n\n\n\n\n","category":"method"},{"location":"API reference/#EnergyCommunity.explode_data-Tuple{AbstractEC}","page":"API reference","title":"EnergyCommunity.explode_data","text":"explode_data(ECModel::AbstractEC)\n\nReturn main data elements of the dataset of the ECModel: general parameters, users data and market data, retrieved from the data dictionary of the ECModel.\n\nArguments\n\nECModel::AbstractEC: Energy Community model\n\nReturns\n\ngeneral_data::Dict: General data of the ECModel\nusers_data::Dict: Users data of the ECModel\nmarket_data::Dict: Market data of the ECModel\n\n\n\n\n\n","category":"method"},{"location":"API reference/#EnergyCommunity.explode_data-Tuple{Any}","page":"API reference","title":"EnergyCommunity.explode_data","text":"Return main data elements of the dataset: general parameters, users data and market data\n\n\n\n\n\n","category":"method"},{"location":"API reference/#EnergyCommunity.field","page":"API reference","title":"EnergyCommunity.field","text":"Function get field that throws an error if the field is not found\n\n\n\n\n\n","category":"function"},{"location":"API reference/#EnergyCommunity.field_component-NTuple{4, Any}","page":"API reference","title":"EnergyCommunity.field_component","text":"Function to get the components value of a dictionary, with default value\n\n\n\n\n\n","category":"method"},{"location":"API reference/#EnergyCommunity.field_component-Tuple{Any, Any, Any}","page":"API reference","title":"EnergyCommunity.field_component","text":"Function to get the components value of a dictionary\n\n\n\n\n\n","category":"method"},{"location":"API reference/#EnergyCommunity.field_d","page":"API reference","title":"EnergyCommunity.field_d","text":"Function to safely get a field of a dictionary with default value\n\n\n\n\n\n","category":"function"},{"location":"API reference/#EnergyCommunity.finalize_results!-Tuple{AbstractGroupANC, AbstractEC}","page":"API reference","title":"EnergyCommunity.finalize_results!","text":"finalize_results!(::AbstractGroupANC, ECModel::AbstractEC)\n\nFunction to finalize the results of the Aggregated Non Cooperative model after the execution\n\n\n\n\n\n","category":"method"},{"location":"API reference/#EnergyCommunity.finalize_results!-Tuple{AbstractGroupCO, AbstractEC}","page":"API reference","title":"EnergyCommunity.finalize_results!","text":"finalize_results!(::AbstractGroupCO, ECModel::AbstractEC)\n\nFunction to finalize the results of the Cooperative model after the execution Nothing to do\n\n\n\n\n\n","category":"method"},{"location":"API reference/#EnergyCommunity.finalize_results!-Tuple{AbstractGroupNC, AbstractEC}","page":"API reference","title":"EnergyCommunity.finalize_results!","text":"finalize_results!(::AbstractGroupNC, ECModel::AbstractEC)\n\nFunction to finalize the results of the Non Cooperative model after the execution Many of the variables are set to zero due to the absence of cooperation between users\n\n\n\n\n\n","category":"method"},{"location":"API reference/#EnergyCommunity.general-Tuple{AbstractDict}","page":"API reference","title":"EnergyCommunity.general","text":"Function to get the general parameters\n\n\n\n\n\n","category":"method"},{"location":"API reference/#EnergyCommunity.generator_names-Tuple{Any}","page":"API reference","title":"EnergyCommunity.generator_names","text":"Function to get the list of generators for a user\n\n\n\n\n\n","category":"method"},{"location":"API reference/#EnergyCommunity.get_annotations-Tuple{AbstractEC}","page":"API reference","title":"EnergyCommunity.get_annotations","text":"get_annotations(ECModel::AbstractEC)\n\nGet annotations for Benders decomposition\n\n\n\n\n\n","category":"method"},{"location":"API reference/#EnergyCommunity.get_group_type-Tuple{AbstractEC}","page":"API reference","title":"EnergyCommunity.get_group_type","text":"get_group_type(ECModel::AbstractEC)\n\nReturns the EC group type\n\n\n\n\n\n","category":"method"},{"location":"API reference/#EnergyCommunity.get_subproblem_vars_by_user-Union{Tuple{T}, Tuple{JuMP.Containers.DenseAxisArray{T, N} where N, Any}} where T<:JuMP.VariableRef","page":"API reference","title":"EnergyCommunity.get_subproblem_vars_by_user","text":"get_subproblem_vars_by_user(var::Containers.DenseAxisArray{T}, u_name) where T <: VariableRef\n\nGet variables related to the user u_name for a DenseAxisArray\n\n\n\n\n\n","category":"method"},{"location":"API reference/#EnergyCommunity.get_subproblem_vars_by_user-Union{Tuple{T}, Tuple{JuMP.Containers.SparseAxisArray{T, N} where N, Any}} where T<:JuMP.VariableRef","page":"API reference","title":"EnergyCommunity.get_subproblem_vars_by_user","text":"get_subproblem_vars_by_user(var::Containers.SparseAxisArray{T}, u_name) where T <: VariableRef\n\nGet variables related to the user u_name for a SparseAxisArray\n\n\n\n\n\n","category":"method"},{"location":"API reference/#EnergyCommunity.get_user_set-Tuple{AbstractEC}","page":"API reference","title":"EnergyCommunity.get_user_set","text":"get_user_set(ECModel::AbstractEC)\n\nReturns the EC user set\n\n\n\n\n\n","category":"method"},{"location":"API reference/#EnergyCommunity.has_any_asset","page":"API reference","title":"EnergyCommunity.has_any_asset","text":"Function to check whether an user has any asset\n\n\n\n\n\n","category":"function"},{"location":"API reference/#EnergyCommunity.has_asset-Tuple{Any, ASSET_TYPE}","page":"API reference","title":"EnergyCommunity.has_asset","text":"Function to check whether an user has an asset type\n\n\n\n\n\n","category":"method"},{"location":"API reference/#EnergyCommunity.has_asset-Tuple{Any, AbstractString}","page":"API reference","title":"EnergyCommunity.has_asset","text":"Function to check whether an user has an asset given its name\n\n\n\n\n\n","category":"method"},{"location":"API reference/#EnergyCommunity.has_component-Tuple{Any, Any, Any}","page":"API reference","title":"EnergyCommunity.has_component","text":"Function to know if a dictionary has a particular component\n\n\n\n\n\n","category":"method"},{"location":"API reference/#EnergyCommunity.has_type-Tuple{AbstractDict}","page":"API reference","title":"EnergyCommunity.has_type","text":"Auxiliary function to check if the key 'type' is available in the dictionary d, otherwise false\n\n\n\n\n\n","category":"method"},{"location":"API reference/#EnergyCommunity.load!-Tuple{AbstractString, AbstractEC}","page":"API reference","title":"EnergyCommunity.load!","text":"load!(output_file::AbstractString, ECModel::AbstractEC)\n\nLoads the Energy Community model stored in the file specified by output_file and updates the relevant fields of ECModel. This function performs basic checks on the loaded data, verifying the existence of the necessary keys (\"data\", \"userset\", \"grouptype\", \"results\"), and restores the model components (such as data, users_data, and results) accordingly.\n\n\n\n\n\n","category":"method"},{"location":"API reference/#EnergyCommunity.market-Tuple{AbstractDict}","page":"API reference","title":"EnergyCommunity.market","text":"Function to get the market configuration\n\n\n\n\n\n","category":"method"},{"location":"API reference/#EnergyCommunity.market_profile_by_user-Tuple{AbstractEC, Any, Any}","page":"API reference","title":"EnergyCommunity.market_profile_by_user","text":"market_profile_by_user(ECModel::AbstractEC, u_name, profile_name)\n\nFunction to retrieve the market profile of each user, according to their market type (e.g. commercial, domestic, etc.)\n\nArguments\n\nECModel: EC model object\nu_name: user name\nprofile_name: profile name\n\nReturns\n\nIt returns the vector of data corresponding to the profile of the user according to the market type\n\n\n\n\n\n","category":"method"},{"location":"API reference/#EnergyCommunity.name-Tuple{AbstractEC}","page":"API reference","title":"EnergyCommunity.name","text":"name(model::AbstractEC)\n\nReturn the name of the model.\n\n\n\n\n\n","category":"method"},{"location":"API reference/#EnergyCommunity.name-Tuple{ModelEC}","page":"API reference","title":"EnergyCommunity.name","text":"name(model::ModelEC)\n\nReturn the name of the model.\n\n\n\n\n\n","category":"method"},{"location":"API reference/#EnergyCommunity.objective_by_user-Tuple{AbstractEC}","page":"API reference","title":"EnergyCommunity.objective_by_user","text":"objective_by_user(ECModel::AbstractEC; add_EC=true)\n\nReturns the objective function by user; when add_EC is true, the EC is added to the user set\n\n\n\n\n\n","category":"method"},{"location":"API reference/#EnergyCommunity.objective_by_user-Tuple{AbstractGroupANC, AbstractEC}","page":"API reference","title":"EnergyCommunity.objective_by_user","text":"Function to return the objective function by user in the Aggregated Non Cooperative case\n\n\n\n\n\n","category":"method"},{"location":"API reference/#EnergyCommunity.objective_by_user-Tuple{AbstractGroupCO, AbstractEC}","page":"API reference","title":"EnergyCommunity.objective_by_user","text":"Function to return the objective function by user in the Cooperative case\n\n\n\n\n\n","category":"method"},{"location":"API reference/#EnergyCommunity.objective_by_user-Tuple{AbstractGroupNC, AbstractEC}","page":"API reference","title":"EnergyCommunity.objective_by_user","text":"Function to return the objective function by user in the NonCooperative case\n\n\n\n\n\n","category":"method"},{"location":"API reference/#EnergyCommunity.parse_dataprofile-NTuple{4, Any}","page":"API reference","title":"EnergyCommunity.parse_dataprofile","text":"Function to throw error for unformatted data\n\n\n\n\n\n","category":"method"},{"location":"API reference/#EnergyCommunity.parse_dataprofile-Tuple{Any, Any, Any, AbstractString}","page":"API reference","title":"EnergyCommunity.parse_dataprofile","text":"Function to parse a string value of a profile to load the corresponding dataframe\n\n\n\n\n\n","category":"method"},{"location":"API reference/#EnergyCommunity.parse_dataprofile-Tuple{Any, Any, Any, Dict}","page":"API reference","title":"EnergyCommunity.parse_dataprofile","text":"Function to parse a personalized processing to generate the data When profile_value is a dictionary, then the user is asking a custom processing of data by a function\n\n\n\n\n\n","category":"method"},{"location":"API reference/#EnergyCommunity.parse_dataprofile-Union{Tuple{T}, Tuple{Any, Any, Any, AbstractVector{T}}} where T<:Real","page":"API reference","title":"EnergyCommunity.parse_dataprofile","text":"Function to parse a string value of a profile to load the corresponding dataframe\n\n\n\n\n\n","category":"method"},{"location":"API reference/#EnergyCommunity.parse_dataprofile-Union{Tuple{T}, Tuple{Any, Any, Any, T}} where T<:Real","page":"API reference","title":"EnergyCommunity.parse_dataprofile","text":"Function to parse a string value of a profile to load the corresponding dataframe\n\n\n\n\n\n","category":"method"},{"location":"API reference/#EnergyCommunity.parse_peak_quantity_by_time_vectors-NTuple{5, Any}","page":"API reference","title":"EnergyCommunity.parse_peak_quantity_by_time_vectors","text":"Function to parse the peak power categories and tariff\n\n\n\n\n\n","category":"method"},{"location":"API reference/#EnergyCommunity.plot_sankey-Tuple{AbstractEC, Dict}","page":"API reference","title":"EnergyCommunity.plot_sankey","text":"plot_sankey(ECModel::AbstractEC, sank_data::Dict; label_size = 10)\n\nFunction to plot the Sankey diagram representing the energy flows across the energy community. This function can be used to plot the sankey diagram of already processed data sank_data.\n\nArguments\n\nECModel::AbstractEC: Energy Community model\nsank_data::Dict: Dictionary containing the data to plot the Sankey diagram, in agreement to SankeyPlots.jl package\n\n\n\n\n\n","category":"method"},{"location":"API reference/#EnergyCommunity.plot_sankey-Tuple{AbstractEC}","page":"API reference","title":"EnergyCommunity.plot_sankey","text":"function plot_sankey(ECModel::AbstractEC; name_units=nothing, norm_value=nothing, market_color=palette(:rainbow)[2], community_color=palette(:rainbow)[5], users_colors=palette(:default), label_size=10)\n\nFunction to plot the Sankey diagram representing the energy flows across the energy community\n\nArguments\n\nECModel::AbstractEC: Energy Community model\nname_units: (optional) Labels used for the sankey diagram with the following order:   \"Market buy\", [users labels], \"Community\", \"Market sell\", [users labels]\nnorm_value: (optional) Normalization value for the flows\nmarket_color: (optional) Color of the market\ncommunity_color: (optional) Color of the community\nusers_colors: (optional) Colors of the users\nlabel_size: (optional) Size of the labels in the Sankey diagram\n\n\n\n\n\n","category":"method"},{"location":"API reference/#EnergyCommunity.prepare_summary-Tuple{AbstractGroupANC, AbstractEC}","page":"API reference","title":"EnergyCommunity.prepare_summary","text":"prepare_summary(::AbstractGroupANC, ECModel::AbstractEC;\n    user_set::Vector=Vector())\n\nSave base excel file with a summary of the results for the Aggregated Non Cooperative case\n\n\n\n\n\n","category":"method"},{"location":"API reference/#EnergyCommunity.prepare_summary-Tuple{AbstractGroupCO, AbstractEC}","page":"API reference","title":"EnergyCommunity.prepare_summary","text":"prepare_summary(::AbstractGroupCO, ECModel::AbstractEC; user_set::Vector=Vector())\n\nSave base excel file with a summary of the results for the Cooperative case\n\n\n\n\n\n","category":"method"},{"location":"API reference/#EnergyCommunity.prepare_summary-Tuple{AbstractGroupNC, AbstractEC}","page":"API reference","title":"EnergyCommunity.prepare_summary","text":"prepare_summary(::AbstractGroupNC, ECModel::AbstractEC, file_summary_path::AbstractString;\n    user_set::Vector=Vector())\n\nPrepare the dataframe lists to be saved in an excel file.\n\nArguments\n\ngroup_type::AbstractGroupNC: The type of group model\nECModel::AbstractEC: The EC model to be built\nfile_summary_path::AbstractString: The file path where to save the excel file\nuser_set::AbstractVector: The user set to be considered\n\nReturns\n\noutput_list::Vector: The list of dataframes to be saved in the excel file\n\n\n\n\n\n","category":"method"},{"location":"API reference/#EnergyCommunity.print_summary-Tuple{AbstractEC}","page":"API reference","title":"EnergyCommunity.print_summary","text":"print_summary(ECModel::AbstractEC; kwargs...)\n\nFunction to print a summary of the results of the model. The function dispatches the execution to the appropriate function depending on the Aggregation type of the EC\n\n\n\n\n\n","category":"method"},{"location":"API reference/#EnergyCommunity.print_summary-Tuple{AbstractGroupANC, AbstractEC}","page":"API reference","title":"EnergyCommunity.print_summary","text":"print_summary(::AbstractGroupANC, ECModel::AbstractEC)\n\nFunction to print the main results of the model\n\n\n\n\n\n","category":"method"},{"location":"API reference/#EnergyCommunity.print_summary-Tuple{AbstractGroupCO, AbstractEC}","page":"API reference","title":"EnergyCommunity.print_summary","text":"print_summary(::AbstractGroupCO, ECModel::AbstractEC)\n\nFunction to print the main results of the model\n\n\n\n\n\n","category":"method"},{"location":"API reference/#EnergyCommunity.print_summary-Tuple{AbstractGroupNC, AbstractEC}","page":"API reference","title":"EnergyCommunity.print_summary","text":"print_summary(::AbstractGroupNC, ECModel::AbstractEC)\n\nFunction to print the main results of the model\n\nArguments\n\ngroup_type::AbstractGroupNC: The type of group model\nECModel::AbstractEC: The EC model to be built\n\n\n\n\n\n","category":"method"},{"location":"API reference/#EnergyCommunity.profile-Tuple{Any, Any}","page":"API reference","title":"EnergyCommunity.profile","text":"Function to get a specific profile\n\n\n\n\n\n","category":"method"},{"location":"API reference/#EnergyCommunity.profile_component-Tuple{Any, Any, Any}","page":"API reference","title":"EnergyCommunity.profile_component","text":"Function to get a specific profile\n\n\n\n\n\n","category":"method"},{"location":"API reference/#EnergyCommunity.profiles-Tuple{AbstractDict}","page":"API reference","title":"EnergyCommunity.profiles","text":"Function to get the profile dictionary\n\n\n\n\n\n","category":"method"},{"location":"API reference/#EnergyCommunity.read_input-Tuple{AbstractString}","page":"API reference","title":"EnergyCommunity.read_input","text":"Function to read the input of the optimization model described as a yaml file\n\n\n\n\n\n","category":"method"},{"location":"API reference/#EnergyCommunity.reset_user_set!-Tuple{AbstractEC}","page":"API reference","title":"EnergyCommunity.reset_user_set!","text":"reset_user_set!(ECModel::AbstractEC)\n\nReset the EC user set to match the stored user_set of the ECModel data\n\n\n\n\n\n","category":"method"},{"location":"API reference/#EnergyCommunity.save_summary-Tuple{AbstractEC, AbstractString}","page":"API reference","title":"EnergyCommunity.save_summary","text":"save_summary(ECModel::AbstractEC, output_file::AbstractString; kwargs...)\n\nFunction to save a summary of the results of the model. The function dispatches the execution to the appropriate function depending on the Aggregation type of the EC\n\n\n\n\n\n","category":"method"},{"location":"API reference/#EnergyCommunity.set_group_type!-Tuple{AbstractEC, AbstractGroup}","page":"API reference","title":"EnergyCommunity.set_group_type!","text":"set_group_type!(ECModel::AbstractEC)\n\nSets the EC group type\n\n\n\n\n\n","category":"method"},{"location":"API reference/#EnergyCommunity.set_least_profitable_profit!-Tuple{AbstractEC, Any}","page":"API reference","title":"EnergyCommunity.set_least_profitable_profit!","text":"set_least_profitable_profit!(ECModel::AbstractEC, profit_distribution)\n\nFunction to set the profit distribution of the least profitable problem.\n\nArguments\n\nECModel::AbstractEC: Model of the community\nprofit_distribution::AbstractDict: Profit distribution per user\n\n\n\n\n\n","category":"method"},{"location":"API reference/#EnergyCommunity.set_objective!-Tuple{AbstractGroupANC, AbstractEC}","page":"API reference","title":"EnergyCommunity.set_objective!","text":"Function to set the objective function of the model of the Aggregated-Non-Cooperative model\n\n\n\n\n\n","category":"method"},{"location":"API reference/#EnergyCommunity.set_objective!-Tuple{AbstractGroupCO, AbstractEC}","page":"API reference","title":"EnergyCommunity.set_objective!","text":"set_objective!(::AbstractGroupCO, ECModel::AbstractEC)\n\nSet the objective for the cooperative approach\n\n\n\n\n\n","category":"method"},{"location":"API reference/#EnergyCommunity.set_objective!-Tuple{AbstractGroupNC, AbstractEC}","page":"API reference","title":"EnergyCommunity.set_objective!","text":"set_objective!(::AbstractGroupNC, ECModel::AbstractEC)\n\nFunction to set the objective function of the model of the Non-Cooperative model, which is to maximize the annual profits of all users.\n\nArguments\n\ngroup_type::AbstractGroupNC: The type of group model\nECModel::AbstractEC: The EC model to be built\n\nReturns\n\nECModel::AbstractEC: The EC model with the objective set\n\n\n\n\n\n","category":"method"},{"location":"API reference/#EnergyCommunity.set_user_set!-Tuple{AbstractEC, Any}","page":"API reference","title":"EnergyCommunity.set_user_set!","text":"set_user_set(ECModel::AbstractEC)\n\nSets the EC user set\n\n\n\n\n\n","category":"method"},{"location":"API reference/#EnergyCommunity.split_financial_terms","page":"API reference","title":"EnergyCommunity.split_financial_terms","text":"split_financial_terms(ECModel::AbstractEC, profit_distribution=nothing)\n\nFunction to describe the cost term distributions for each user. Each entry that follows is DenseAxisArray for an economic parameter by user.\n\nArguments\n\nECModel::AbstractEC: Energy Community model\nprofit_distribution: (optional) DenseAxisArray with the profit distribution by user\n\nReturns\n\nThe output value is a NamedTuple with the following elements:\n\nNPV: the NPV of each user given the final profit_distribution adjustment by game theory\nCAPEX: the annualized CAPEX\nOPEX: the annualized operating costs (yearly maintenance and yearly peak and energy grid charges)\nREP: the annualized replacement costs\nRV: the annualized recovery charges\nREWARD: the annualized reward distribution by user\nPEAK: the annualized peak costs\nEN_SELL: the annualized revenues from energy sales\nEN_BUY: the annualized costs from energy consumption and buying\nEN_NET: the annualized net energy costs\n\n\n\n\n\n","category":"function"},{"location":"API reference/#EnergyCommunity.split_yearly_financial_terms","page":"API reference","title":"EnergyCommunity.split_yearly_financial_terms","text":"splityearlyfinancialterms(ECModel::AbstractEC, profitdistribution)\n\nFunction to describe the cost term distributions by all users for year. It returns major economic inputs summed across users and the community by year.\n\nArguments\n\nECModel::AbstractEC: Energy Community model\nprofit_distribution: (optional) DenseAxisArray with the profit distribution by user\n\nReturns\n\nThe output value is a NamedTuple with the following elements:\n\nNPV: the NPV of each user given the final profit_distribution adjustment by game theory\nCAPEX: the CAPEX by year\nOPEX: the operating costs by year (yearly maintenance and yearly peak and energy grid charges)\nREP: the replacement costs by year\nRV: the recovery charges by year\nREWARD: the reward distribution by year\nPEAK: the peak costs by year\nEN_SELL: the revenues from energy sales by year\nEN_BUY: the costs from energy consumption and buying by year\nEN_NET: the net energy costs by year\nyear_set: the list of years under consideration\n\n\n\n\n\n","category":"function"},{"location":"API reference/#EnergyCommunity.to_least_profitable_coalition_callback-Tuple{AbstractEC, AbstractGroup}","page":"API reference","title":"EnergyCommunity.to_least_profitable_coalition_callback","text":"to_least_profitable_coalition_callback(\n    ECModel::AbstractEC,\n    base_group::AbstractGroup;\n    no_aggregator_group::AbstractGroup=GroupNC(),\n    optimizer=nothing,\n    raw_outputs=false,\n    number_of_solutions=1,\n    relax_combinatorial=false,\n    use_notations=false,\n    callback_solution=Dict(),\n    branching_priorities=true,\n    decompose_ANC=true,\n    decompose_rel_tolerance=0.05,\n    decompose_abs_tolerance=1e-2,\n    kwargs...\n)\n\nFunction that returns a callback function that, given as input a profit distribution scheme, returns the coalition that has the least benefit in remaining in the grand coalition. The returned function least_profitable_coalition_callback accepts an AbstractDict as argument that specifies the profit distribution by user that is used to compute the least benefit procedure.\n\nArguments\n\nECModel::AbstractEC: Cooperative EC Model of the EC to study. When the model is not cooperative an error is thrown.\nbase_group::AbstractGroup: Base group with respect the benefit is calculated\nno_aggregator_group::AbstractGroup=GroupNC(): Type of aggregation group of the community when no aggregator is available\noptimizer::Optimizer=nothing: Optimizer to use\nraw_outputs::Bool=false: Flag to return raw outputs; see return section for more details\nnumber_of_solutions::Int=1: Number of solutions to return from each iteration; when number_of_solutions <= 0 all solutions are returned\nrelax_combinatorial::Bool=false: Flag to relax the combinatorial part of the MILP model\nuse_notations::Bool=false: Flag to use notations in the model\ncallback_solution::Dict(): Dictionary of callbacks depending on the termination status of the optimization. Keys shall be of type JuMP.TerminationStatusCode, and outputs a function with as argument a ModelEC\nbranching_priorities::Bool=true: Option to specify if add the branching priorities\ndecompose_ANC::Bool=true: When True, if the noaggregatorgroup is ANC and, then the main optimization model is decomposed into two models: (a) when no Aggregator is in the coalition and (b) when the aggregator is in the coalition. In this case, (a) is optimized first and if the optimization is beyond a given threshold, the execution is terminated without optimizing (b). The threshold is provided as an optional input in the callback function returned by the function. Otherwise the optimization continues with (b).\ndecompose_rel_tolerance=0.05: Relative tolerance of the decompose_ANC procedure\ndecompose_abs_tolerance=1e-2: Absolute tolerance of the decompose_ANC procedure\n\nReturns\n\nleast_profitable_coalition_callback: Function that accepts as input an AbstractDict representing the benefit distribution by user\necm_copy: (when raw_outputs=true) ModelEC copy of the ECModel, used in the callback function\n\n\n\n\n\n","category":"method"},{"location":"API reference/#EnergyCommunity.to_objective_callback_by_subgroup-Tuple{AbstractEC}","page":"API reference","title":"EnergyCommunity.to_objective_callback_by_subgroup","text":"to_objective_callback_by_subgroup(ECModel::AbstractEC)\n\nFunction that returns a callback function that quantifies the objective of a given subgroup of users The returned function objective_func accepts as arguments an AbstractVector of users and returns the objective of the aggregation for any model\n\nArguments\n\nECModel::AbstractEC: Cooperative EC Model of the EC to study.   When the model is not cooperative an error is thrown.\n\nReturns\n\nobjective_callback_by_subgroup: Function that accepts as input an AbstractVector (or Set) of users and returns   as output the benefit of the specified community\n\n\n\n\n\n","category":"method"},{"location":"API reference/#EnergyCommunity.to_objective_callback_by_subgroup-Tuple{AbstractGroupANC, AbstractEC}","page":"API reference","title":"EnergyCommunity.to_objective_callback_by_subgroup","text":"to_objective_callback_by_subgroup(::AbstractGroupANC, ECModel::AbstractEC; base_model=nothing, kwargs...)\n\nFunction that returns a callback function that quantifies the objective of a given subgroup of users The returned function objective_func accepts as arguments an AbstractVector of users and returns the objective of the aggregation for Aggregated Non Cooperative models\n\nArguments\n\ngroup_type: The type of group model\nECModel: EC Model of the EC to study. When the model is not cooperative an error is thrown.\nbase_model: EC Model (optional). When provided, it represents the base model used to perform the calculations\n\nReturns\n\nIt returns a function that accepts as input an AbstractVector (or Set) of users and returns as output the benefit of the specified community\n\n\n\n\n\n","category":"method"},{"location":"API reference/#EnergyCommunity.to_objective_callback_by_subgroup-Tuple{AbstractGroupCO, AbstractEC}","page":"API reference","title":"EnergyCommunity.to_objective_callback_by_subgroup","text":"to_objective_callback_by_subgroup(::AbstractGroupCO, ECModel::AbstractEC)\n\nFunction that returns a callback function that quantifies the objective of a given subgroup of users The returned function objective_func accepts as arguments an AbstractVector of users and returns the objective of the aggregation for Aggregated Cooperative models\n\nArguments\n\ngroup_type: The type of group model\nECModel : Cooperative EC Model of the EC to study. When the model is not cooperative an error is thrown.\nno_aggregator_group (optional, default NonCooperative): EC group type when no aggregator is considered\n\nReturns\n\nIt returns a function that accepts as input an AbstractVector (or Set) of users and returns as output the benefit of the specified community\n\n\n\n\n\n","category":"method"},{"location":"API reference/#EnergyCommunity.to_objective_callback_by_subgroup-Tuple{AbstractGroupNC, AbstractEC}","page":"API reference","title":"EnergyCommunity.to_objective_callback_by_subgroup","text":"to_objective_callback_by_subgroup(::AbstractGroupNC, ECModel::AbstractEC)\n\nFunction that returns a callback function that quantifies the objective of a given subgroup of users The returned function objective_func accepts as arguments an AbstractVector of users and returns the objective of the aggregation for Non Cooperative models\n\nArguments\n\ngroup_type: The type of group model\nECModel : Cooperative EC Model of the EC to study. When the model is not cooperative an error is thrown.\n\nReturns\n\nIt returns a function that accepts as input an AbstractVector (or Set) of users and returns as output the benefit of the specified community\n\n\n\n\n\n","category":"method"},{"location":"API reference/#EnergyCommunity.to_utility_callback_by_subgroup-Tuple{AbstractEC, AbstractGroup}","page":"API reference","title":"EnergyCommunity.to_utility_callback_by_subgroup","text":"to_utility_callback_by_subgroup(\n    ECModel::AbstractEC, base_group_type::AbstractGroup;\n    no_aggregator_group::AbstractGroup=GroupNC(),\n    kwargs...\n)\n\nFunction that returns a callback function that quantifies the benefit of a given subgroup of users The returned function utility_func accepts as arguments an AbstractVector of users and returns the benefit with respect to the base case of the users optimized independently\n\nArguments\n\nECModel::AbstractEC: Cooperative EC Model of the EC to study.\nbase_group_type::AbstractGroup: Type of the base case to consider\nno_aggregator_group::AbstractGroup=GroupNC(): EC group type for when no aggregator is considered\n\nReturns\n\nutility_callback_by_subgroup::Function: Function that accepts as input an AbstractVector (or Set) of users and returns as output the benefit of the specified community\n\n\n\n\n\n","category":"method"},{"location":"API reference/#EnergyCommunity.user_names-Tuple{Any, Any}","page":"API reference","title":"EnergyCommunity.user_names","text":"Get the list of users\n\n\n\n\n\n","category":"method"},{"location":"API reference/#EnergyCommunity.users-Tuple{AbstractDict}","page":"API reference","title":"EnergyCommunity.users","text":"Function to get the users configuration\n\n\n\n\n\n","category":"method"},{"location":"API reference/#FileIO.load-Tuple{AbstractString, AbstractEC}","page":"API reference","title":"FileIO.load","text":"load(output_file::AbstractString, ECModel::AbstractEC)\n\nFunction to save the results and the model to the hard drive; ECModel is not modified. The function saves data, userset, grouptype and results of the ECModel in a dictionary and then saves the dictionary in the output_file.\n\n\n\n\n\n","category":"method"},{"location":"API reference/#FileIO.save-Tuple{AbstractString, AbstractEC}","page":"API reference","title":"FileIO.save","text":"save(output_file::AbstractString, ECModel::AbstractEC)\n\nFunction to save the results and the model to the hard drive. The function saves data, userset, grouptype and results of the ECModel in a dictionary and then saves the dictionary in the output_file.\n\n\n\n\n\n","category":"method"},{"location":"API reference/#JuMP.objective_function-Tuple{AbstractEC}","page":"API reference","title":"JuMP.objective_function","text":"objective_function(ECModel::AbstractEC)\n\nGets the objective function of the model\n\n\n\n\n\n","category":"method"},{"location":"API reference/#JuMP.objective_value-Tuple{AbstractEC}","page":"API reference","title":"JuMP.objective_value","text":"JuMP.objective_value(ECModel::AbstractEC)\n\nReturns the objective value of the EC model\n\n\n\n\n\n","category":"method"},{"location":"API reference/#JuMP.optimize!-Tuple{AbstractEC}","page":"API reference","title":"JuMP.optimize!","text":"JuMP.optimize!(ECModel::AbstractEC)\n\nSolve the optimization problem for the EC. It optimizes the model of the EC and stores the results in the results attribute of the ECModel.\n\n\n\n\n\n","category":"method"},{"location":"API reference/#JuMP.result_count-Tuple{AbstractEC}","page":"API reference","title":"JuMP.result_count","text":"JuMP.result_count(ECModel::AbstractEC)\n\nReturns the result count of the JuMP model of the EC model\n\n\n\n\n\n","category":"method"},{"location":"API reference/#JuMP.termination_status-Tuple{AbstractEC}","page":"API reference","title":"JuMP.termination_status","text":"termination_status(ECModel::AbstractEC)\n\nCalculates the optimization status of the model\n\n\n\n\n\n","category":"method"},{"location":"API reference/#RecipesBase.plot","page":"API reference","title":"RecipesBase.plot","text":"Plots.plot(ECModel::ModelEC, output_plot_file::AbstractString=\"\")\n\nFunction to plot the EC model\n\n\n\n\n\n","category":"function"},{"location":"API reference/#RecipesBase.plot-Tuple{AbstractGroupANC, AbstractEC, AbstractString}","page":"API reference","title":"RecipesBase.plot","text":"Plots.plot(::AbstractGroupANC, ECModel::AbstractEC, output_plot_file::AbstractString;\nuser_set::AbstractVector = Vector(), line_width = 2.0)\n\nFunction to plot the results of the Aggregated non cooperative configuration\n\n\n\n\n\n","category":"method"},{"location":"API reference/#RecipesBase.plot-Tuple{AbstractGroupCO, AbstractEC, AbstractString}","page":"API reference","title":"RecipesBase.plot","text":"Plots.plot(::AbstractGroupCO, ECModel::AbstractEC, output_plot_file::AbstractString;\nuser_set::AbstractVector = Vector(), line_width = 2.0, dpi = 300)\n\nFunction to plot the results of the Cooperative EC\n\n\n\n\n\n","category":"method"},{"location":"API reference/#RecipesBase.plot-Tuple{AbstractGroupNC, AbstractEC, AbstractString}","page":"API reference","title":"RecipesBase.plot","text":"Plots.plot(::AbstractGroupNC, ECModel::AbstractEC, output_plot_file::AbstractString;\n    user_set::Vector=Vector(), line_width=2.0)\n\nFunction to plot the results of the user model\n\nArguments\n\ngroup_type::AbstractGroupNC: The type of group model\nECModel::AbstractEC: The EC model to be built\noutput_plot_file::AbstractString: The file path where to save the plots\nuser_set::Vector: The user set to plot\nline_width::Float64: The width of the lines in the plot\n\n\n\n\n\n","category":"method"},{"location":"API reference/#EnergyCommunity.AbstractEC","page":"API reference","title":"EnergyCommunity.AbstractEC","text":"AbstractEC\n\nAbstract type for an EnergyCommunity model.\n\n\n\n\n\n","category":"type"},{"location":"API reference/#EnergyCommunity.AbstractGroup","page":"API reference","title":"EnergyCommunity.AbstractGroup","text":"AbstractGroup\n\nAbstract type for the group model; it is the parent of the three types of group models: Cooperative, Non-Cooperative, and Aggregated Non-Cooperative.\n\n\n\n\n\n","category":"type"},{"location":"API reference/#EnergyCommunity.GroupANC","page":"API reference","title":"EnergyCommunity.GroupANC","text":"GroupANC <: AbstractGroupANC\n\nConcrete type for the Aggregated Non-Cooperative group model.\n\n\n\n\n\n","category":"type"},{"location":"API reference/#EnergyCommunity.GroupCO","page":"API reference","title":"EnergyCommunity.GroupCO","text":"GroupCO <: AbstractGroupCO\n\nConcrete type for the Cooperative group model.\n\n\n\n\n\n","category":"type"},{"location":"API reference/#EnergyCommunity.GroupNC","page":"API reference","title":"EnergyCommunity.GroupNC","text":"GroupNC <: AbstractGroupNC\n\nConcrete type for the Non-Cooperative group model.\n\n\n\n\n\n","category":"type"},{"location":"API reference/#EnergyCommunity.ModelEC","page":"API reference","title":"EnergyCommunity.ModelEC","text":"ModelEC(file_name::AbstractString, group_type, optimizer=nothing)\n\nLoad EnergyCommunity model from disk\n\nArguments\n\nfile_name::AbstractString: name of the file to load the data\ngroup_type: aggregation type of model\noptimizer: optimizer of the JuMP model\n\n\n\n\n\n","category":"type"},{"location":"API reference/#EnergyCommunity.ModelEC-2","page":"API reference","title":"EnergyCommunity.ModelEC","text":"ModelEC(data::Dict=ZERO_DD, group_type=GroupNC(), optimizer=nothing, user_set::Vector=Vector())\n\nConstructor of a ModelEC.\n\nArguments\n\ndata::Dict=ZERO_DD: All data; a dictionary with the keys \"general\", \"users\", and \"market\"\ngroup_type: aggregation type of model\noptimizer: optimizer of the JuMP model\nuser_set::Vector: desired user set\n\n\n\n\n\n","category":"type"},{"location":"API reference/#EnergyCommunity.ModelEC-3","page":"API reference","title":"EnergyCommunity.ModelEC","text":"ModelEC(model_copy::ModelEC, group_type=nothing, optimizer=nothing, user_set=nothing)\n\nCopy constructor; it copies the data from model_copy and changes the group type, optimizer, and user set if specified.\n\nArguments\n\nmodel_copy::ModelEC: model to copy\ngroup_type=nothing: aggregation type of model; default is the same as model_copy\noptimizer=nothing: optimizer of the JuMP model; default is the same as model_copy\nuser_set=nothing: desired user set; default is the same as model_copy\n\n\n\n\n\n","category":"type"},{"location":"API reference/#EnergyCommunity.ModelEC-4","page":"API reference","title":"EnergyCommunity.ModelEC","text":"ModelEC <: AbstractEC\n\nConcrete type for an EnergyCommunity model.\n\nAttributes\n\ndata::Dict: All data\ngen_data::Dict: general data\nmarket_data::Dict: market data\nusers_data::Dict: users data\ngroup_type: aggregation type of model\nuser_set::Vector: desired user set\nmodel::Model: JuMP model\noptimizer: optimizer of the JuMP model\nresults::Dict: results of the model in Dictionary format\n\n\n\n\n\n","category":"type"},{"location":"API reference/#TheoryOfGames.EnumMode-Tuple{AbstractEC, AbstractGroup}","page":"API reference","title":"TheoryOfGames.EnumMode","text":"TheoryOfGames.EnumMode(ECModel::AbstractEC, base_group::AbstractGroup; verbose::Bool=true, kwargs...)\n\nFunction to create the EnumMode item for the TheoryOfGames.jl package.\n\nArguments\n\nECModel::AbstractEC: Cooperative EC Model of the EC to study.\nbase_group::AbstractGroup: Type of the base case to consider\nverbose::Bool=true: Flag to print the results\nkwargs...: Additional arguments\n\nReturns\n\nenum_mode: TheoryOfGames.EnumMode object\n\n\n\n\n\n","category":"method"},{"location":"API reference/#TheoryOfGames.IterMode-Tuple{AbstractEC, AbstractGroup}","page":"API reference","title":"TheoryOfGames.IterMode","text":"TheoryOfGames.IterMode(\n    ECModel::AbstractEC,\n    base_group_type::AbstractGroup; \n    no_aggregator_type::AbstractGroup=GroupNC(),\n    optimizer=nothing,\n    number_of_solutions=0,\n    use_notations=false,\n    decompose_ANC=true,\n    decompose_abs_tolerance=1e-4,\n    decompose_rel_tolerance=1e-4,\n    kwargs...\n)\n\nFunction to create the IterMode item for the TheoryOfGames.jl package\n\nArguments\n\nECModel::AbstractEC: Cooperative EC Model of the EC to study.\nbase_group_type::AbstractGroup: Type of the base case to consider\nno_aggregator_type::AbstractGroup=GroupNC(): Type of the base case to consider when no aggregator is available\noptimizer::Optimizer=nothing: Optimizer to use\nnumber_of_solutions::Int=0: Number of solutions to return from each iteration; when number_of_solutions <= 0 all solutions are returned\nuse_notations::Bool=false: Flag to use notations in the model\ndecompose_ANC::Bool=true: When True, if the noaggregatorgroup is ANC and, then the main optimization model is decomposed into two models. See to_least_profitable_coalition_callback for more details\ndecompose_rel_tolerance=0.05: Relative tolerance of the decompose_ANC procedure\ndecompose_abs_tolerance=1e-2: Absolute tolerance of the decompose_ANC procedure\nkwargs...: Additional arguments\n\nReturns\n\niter_mode: TheoryOfGames.IterMode object\n\n\n\n\n\n","category":"method"},{"location":"examples/plotting/#Plotting","page":"Plotting","title":"Plotting","text":"This example showcase the plotting capabilities native to the EnergyCommunity.jl package. The package allows to create various plots to visualize the results of the energy community optimization problems, such as time series plots of energy production and consumption, as well as sankey diagrams to illustrate the flow of energy within the community. Moreover, by leveraging on additional packages, it is possible to extend the functionalities and perform additional plots.","category":"section"},{"location":"examples/plotting/#Initialization-of-the-model","page":"Plotting","title":"Initialization of the model","text":"Import the needed packages\n\nusing EnergyCommunity, JuMP\nusing HiGHS, Plots\n\nCreate a base Energy Community example in the data folder; use the default configuration.\n\nfolder = joinpath(@__DIR__, \"data\")\ncreate_example_data(folder, config_name=\"default\")\n\nInput file to load the structure of the energy community based on a yaml file.\n\ninput_file = joinpath(@__DIR__, \"data/energy_community_model.yml\");\nnothing #hide\n\nOutput path of the plots\n\noutput_plot_isolated = joinpath(@__DIR__, \"./results/Img/plot_user_{:s}_CO.png\");\nnothing #hide\n\ndefine optimizer and options\n\noptimizer = optimizer_with_attributes(HiGHS.Optimizer, \"ipm_optimality_tolerance\"=>1e-6)\n\nDefine the Non Cooperative model\n\nCO_Model = ModelEC(input_file, EnergyCommunity.GroupCO(), optimizer)\n\nBuild the mathematical model\n\nbuild_model!(CO_Model)\n\nOptimize the model\n\noptimize!(CO_Model)\n\nget objective value\n\nobjective_value(CO_Model)","category":"section"},{"location":"examples/plotting/#Plots-of-dispatch","page":"Plotting","title":"Plots of dispatch","text":"Create plots of the dispatch of resources by user and save them to disk\n\nall_plots = plot(CO_Model, output_plot_isolated)\nuser_to_plot = 3  # select user to plot\nplot(all_plots[user_to_plot, 3])  # show the plot of user 3 (top: power dispatch, bottom: battery storage)","category":"section"},{"location":"examples/plotting/#Sankey-plots","page":"Plotting","title":"Sankey plots","text":"Plot the sankey plot of resources\n\nplot_sankey(CO_Model)","category":"section"},{"location":"examples/plotting/#Plot-of-business","page":"Plotting","title":"Plot of business","text":"plot business plan\n\nbusiness_plan_plot(CO_Model)\n\ninfo: Info\nView this file on Github.\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"examples/io/#Input/Ouput-to/from-disk","page":"Input/Ouput to/from disk","title":"Input/Ouput to/from disk","text":"This example showcase the input/output capabilities of the EnergyCommunity.jl package on writing and reading the model and outputs to/from disk. EnergyCommunity.jl supports:\n\nInput from yaml files defining the structure of the energy community\nOutput of summaries and plots to files\nSaving and loading the model to/from jld2 files, so that any intermediate results can be stored and retrieved later on without the need to re-optimize the model.\n\nIn the example below, we consider a Cooperative (CO) energy community optimization problem and showcase the opportunities related to input/output operations; for plotting, see the other example.","category":"section"},{"location":"examples/io/#Initialization-of-the-model","page":"Input/Ouput to/from disk","title":"Initialization of the model","text":"Import the needed packages\n\nusing EnergyCommunity, JuMP\nusing HiGHS, FileIO\n\nCreate a base Energy Community example in the data folder; use the default configuration.\n\nfolder = joinpath(@__DIR__, \"data\")\ncreate_example_data(folder, config_name=\"default\")\n\nInput file to load the structure of the energy community based on a yaml file.\n\ninput_file = joinpath(@__DIR__, \"data/energy_community_model.yml\");\nnothing #hide\n\nOutput path of the summary\n\noutput_file_isolated = joinpath(@__DIR__, \"./results/output_file_CO.xlsx\");\nnothing #hide\n\ndefine optimizer and options\n\noptimizer = optimizer_with_attributes(HiGHS.Optimizer, \"ipm_optimality_tolerance\"=>1e-6)\n\nDefine the Non Cooperative model\n\nCO_Model = ModelEC(input_file, EnergyCommunity.GroupCO(), optimizer)\n\nBuild the mathematical model\n\nbuild_model!(CO_Model)\n\nOptimize the model\n\noptimize!(CO_Model)\n\nget objective value\n\nobjective_value(CO_Model)","category":"section"},{"location":"examples/io/#Print-and-save-summaries","page":"Input/Ouput to/from disk","title":"Print and save summaries","text":"Print summaries of the results\n\nprint_summary(CO_Model)\n\nSave summaries\n\nsave_summary(CO_Model, output_file_isolated)\n\nDataFrame of the business plan\n\nbusiness_plan(CO_Model)","category":"section"},{"location":"examples/io/#Save-the-model-to-disk","page":"Input/Ouput to/from disk","title":"Save the model to disk","text":"save the model to a jld2 file, to store the whole object\n\nsave(\"co_model.jld2\", CO_Model)","category":"section"},{"location":"examples/io/#Load-the-model-from-disk","page":"Input/Ouput to/from disk","title":"Load the model from disk","text":"read the loaded model from the jld2 file\n\nCO_Model_loaded = load!(\"co_model.jld2\", ModelEC())\n\nget the objective value of the loaded model\n\nobjective_value(CO_Model_loaded)\n\ncompare the objective values of the two models\n\nobjective_value(CO_Model) == objective_value(CO_Model_loaded)\n\ninfo: Info\nView this file on Github.\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"theory_of_games/supported_allocations/#Supported-fair-allocation-methods","page":"Supported fair allocation methods","title":"Supported fair allocation methods","text":"","category":"section"},{"location":"theory_of_games/supported_allocations/#Supported-fair-allocation-methods-2","page":"Supported fair allocation methods","title":"Supported fair allocation methods","text":"All allocation methods supported by TheoryOfGames.jl are available in EnergyCommunity.jl. Some of the most relevant methods for energy communities include:\n\nShapley Value: This method allocates benefits based on each participant's marginal contribution to all possible coalitions. It ensures that participants are rewarded fairly according to their contributions.\nNucleolus: This method focuses on minimizing the maximum dissatisfaction among participants. It aims to find an allocation that is as fair as possible by reducing the largest grievances.\nFair Core: This method ensures that no participant receives less than what they would get by acting alone. It guarantees that the allocation is stable and acceptable to all members.\nFair Least Core: This method relaxes the core concept to allow for some level of dissatisfaction, aiming to find an allocation that is as fair as possible while still being feasible.","category":"section"},{"location":"theory_of_games/supported_allocations/#Shapely-Value","page":"Supported fair allocation methods","title":"Shapely Value","text":"The Shapley Value is one of the most widely used methods for fair allocation in cooperative game theory. It provides a way to distribute the total benefit of a coalition among its members based on their individual contributions. The Shapley Value for each participant j is calculated as follows:\n\nphi_j = dfrac1I sum_J subseteq IbinomI-1J^-1 left v(J) - v(J setminus j) right\n\nWhere:\n\nphi_j is the Shapley Value allocated to participant j.\nv(J) is the characteristic function representing the benefit of coalition J.\nJ is the number of participants in coalition J.\nI is the total number of participants in the grand coalition I.\nbinomI-1J is the binomial coefficient representing the number of ways to choose J participants from I-1 participants.\n\nThe Shapley Value ensures that each participant is rewarded fairly based on their contributions to all possible coalitions, making it a robust method for fair allocation in energy communities. However, it requires the evaluation of the characteristic function for all possible coalitions, which can be computationally intensive for large communities, unless efficient algorithms or approximations are employed.","category":"section"},{"location":"theory_of_games/supported_allocations/#Nucleolus","page":"Supported fair allocation methods","title":"Nucleolus","text":"The Nucleolus is another important method for fair allocation in cooperative game theory. It aims to find the unique allocation that lexicographically maximizes the satisfaction of the least satisfied group of participants in joining and staying into the whole community, thus ensuring that the allocation is as fair as possible. The Nucleolus is determined by solving a series of linear programming problems that focus on minimizing the largest excesses (dissatisfactions) of coalitions. The Nucleolus allocation phi is found by iteratively solving the following optimization problem:\n\nbeginarrayll\nmax  theta \ntextst  sum_j in J phi_j - v(J) ge theta quad forall J notin Gamma \n             sum_j in J phi_j - v(J) ge bartheta_j quad forall J in Gamma \nendarray\n\nWhere:\n\ntheta is the maximum dissatisfaction to be minimized in the current iteration.\nbartheta_j are the dissatisfaction levels fixed from previous iterations for coalitions already considered in previous iterations.\nGamma is the set of coalitions whose dissatisfaction levels have been fixed in previous iterations.\n\nThe Nucleolus ensures that the allocation is stable and acceptable to all members by minimizing the maximum dissatisfaction among participants. It is unique, however , it can be computationally intensive to compute, especially for large communities, as it requires solving multiple linear programming problems iteratively and calculate the function v(J) for all coalitions.","category":"section"},{"location":"theory_of_games/supported_allocations/#Variance-Core-and-Variance-Least-Core","page":"Supported fair allocation methods","title":"Variance Core and Variance Least Core","text":"The Variance Core and Variance Least Core are methods that ensure stability and fairness in the allocation of benefits among participants in a cooperative game.\n\nThe Variance Core distributes benefits to minimize the variance of redistribution, provided that that each participant and group of participats receive no less than the benefits they provide. In mathematical terms, Variance Core identifies the allocation that minimizes the variance of the allocations while satisfying the core constraints.\n\nLet phi be the allocation vector for all participants, Variance Core allocation is determined by solving the following optimization problem:\n\nbeginarrayll\nmin  sum_j in I left( phi_j - dfracv(I)I right)^2 \ntextst  sum_j in J phi_j - v(J) ge 0 quad forall J subseteq I  \n             sum_j in I phi_j = v(I)\nendarray\n\nWhere:\n\nThe objective function minimizes the variance of the allocations among participants, promoting fairness.\nThe first constraint ensures that no coalition J receives less than its value.\nThe second constraint ensures that the total allocation equals the total value of the grand coalition.\n\nThe Variance Least Core is a variation of the Variance Core that allows for a minimum satisfaction level bartheta for each coalition, where bartheta represents the minimum additional benefit that each coalition should receive beyond its standalone value. Its value is computed by executing the first iteration of the Nucleolus algorithm. The Variance Least Core allocation is determined by solving the following optimization problem:\n\nbeginarrayll\nmin  sum_j in I left( sum_j in J dfracphi_j - dfracv(I)II right)^2 \ntextst  sum_j in J phi_j - v(J) ge bartheta quad forall J subseteq I \n             sum_j in I phi_j = v(I)\nendarray\n\nWhere:\n\nThe objective function minimizes the variance of the allocations among participants, promoting fairness.\nThe first constraint ensures that no coalition J receives less than its value plus the minimum satisfaction level bartheta.\nThe second constraint ensures that the total allocation equals the total value of the grand coalition.\n\nBoth the Variance Core and Variance Least Core aim to provide fair and stable allocations among participants, with the latter allowing for a degree of dissatisfaction to ensure feasibility in cases where the core may be empty.\n\nIn its form, the Variance Least Core is simpler than the Nucleolus, however, it still requires the evaluation of the characteristic function for all possible coalitions, which can be computationally intensive for large communities, unless efficient algorithms or approximations are employed. Alternative techniques adopting row-generation techniques are available in TheoryOfGames.jl to efficiently compute these allocations for larger games.\n\nSee more details about these allocation methods in the TheoryOfGames.jl documentation and the original references:\n\nD. Fioriti, G. Bigi, A. Frangioni, M. Passacantando and D. Poli, \"Fair Least Core: Efficient, Stable and Unique Game-Theoretic Reward Allocation in Energy Communities by Row-Generation,\" in IEEE Transactions on Energy Markets, Policy and Regulation, vol. 3, no. 2, pp. 170-181, June 2025, doi: 10.1109/TEMPR.2024.3495237.","category":"section"},{"location":"examples/theory_of_games/#Fair-reward-allocations","page":"Fair reward allocations","title":"Fair reward allocations","text":"This example showcase the capabilities of estimating fair reward allocations within energy communities using concepts from cooperative game theory. By leveraging on TheoryOfGames.jl, the package provides functionalities to compute various allocation methods, such as the Variance (Least) Core, Shapley value, the Nucleolus, and more. These methods help in distributing the benefits of cooperation among the members of the energy community in a fair manner. In the following, we showcase how to set up an energy community optimization problem and compute fair reward allocations based on the results. More information are also available at:\n\nD. Fioriti, G. Bigi, A. Frangioni, M. Passacantando and D. Poli, \"Fair Least Core: Efficient, Stable and Unique Game-Theoretic Reward Allocation in Energy Communities by Row-Generation,\" in IEEE Transactions on Energy Markets, Policy and Regulation, vol. 3, no. 2, pp. 170-181, June 2025, doi: 10.1109/TEMPR.2024.3495237.\nD. Fioriti, A. Frangioni, D. Poli, \"Optimal sizing of energy communities with fair revenue sharing and exit clauses: Value, role and business model of aggregators and users,\" in Applied Energy, vol. 299, 2021, 117328,doi: 10.1016/j.apenergy.2021.117328","category":"section"},{"location":"examples/theory_of_games/#Initialization-of-the-model","page":"Fair reward allocations","title":"Initialization of the model","text":"Import the needed packages\n\nusing EnergyCommunity, JuMP, HiGHS\nusing TheoryOfGames\nusing DataFrames, StatsPlots\n\nCreate a base Energy Community example in the data folder; use the default configuration.\n\nfolder = joinpath(@__DIR__, \"data\")\ncreate_example_data(folder, config_name=\"default\")\n\nInput file to load the structure of the energy community based on a yaml file.\n\ninput_file = joinpath(@__DIR__, \"data/energy_community_model.yml\");\nnothing #hide\n\ndefine optimizer and options\n\noptimizer = optimizer_with_attributes(\n    HiGHS.Optimizer,\n    \"log_to_console\"=>false,  # suppress solver output\n    \"ipm_optimality_tolerance\"=>1e-6,  # set optimality tolerance\n)\n\nDefine the Non Cooperative model\n\nCO_Model = ModelEC(input_file, EnergyCommunity.GroupCO(), optimizer)","category":"section"},{"location":"examples/theory_of_games/#Enumerative-method-for-reward-allocations","page":"Fair reward allocations","title":"Enumerative method for reward allocations","text":"Define the enumerative mode for cooperative games\n\nenum_mode = EnumMode(\n    CO_Model,\n    EnergyCommunity.GroupNC(),  # Base group is the Non Cooperative group\n    no_aggregator_type=EnergyCommunity.GroupNC(),  # when the aggregator is not in the community, use Non Cooperative group\n)","category":"section"},{"location":"examples/theory_of_games/#Shapley","page":"Fair reward allocations","title":"Shapley","text":"Calculate fair allocation using Shapley value\n\ndst_sh = shapley_value(enum_mode)\ndst_sh","category":"section"},{"location":"examples/theory_of_games/#Nucleolus","page":"Fair reward allocations","title":"Nucleolus","text":"Calculate fair allocation using Nucleolus\n\ndst_nuc = nucleolus(enum_mode, optimizer)\ndst_nuc","category":"section"},{"location":"examples/theory_of_games/#Variance-Core","page":"Fair reward allocations","title":"Variance Core","text":"Calculate fair allocation using Variance Core\n\ndst_vc = var_in_core(enum_mode, optimizer)\ndst_vc","category":"section"},{"location":"examples/theory_of_games/#Variance-Least-Core","page":"Fair reward allocations","title":"Variance Least Core","text":"Calculatefair allocation using Variance Least Core\n\ndst_vlc = var_least_core(enum_mode, optimizer)\ndst_vlc","category":"section"},{"location":"examples/theory_of_games/#Verify-stability-of-the-allocations","page":"Fair reward allocations","title":"Verify stability of the allocations","text":"Check if the Shapley value is in the Core\n\nsh_in_core = verify_in_core(dst_sh, enum_mode, optimizer)\nprintln(\"Shapley value in Core: \", sh_in_core)\n\nCheck if the Nucleolus is in the Core\n\nnuc_in_core = verify_in_core(dst_nuc, enum_mode, optimizer)\nprintln(\"Nucleolus in Core: \", nuc_in_core)\n\nCheck if the Variance Core allocation is in the Core\n\nvc_in_core = verify_in_core(dst_vc, enum_mode, optimizer)\nprintln(\"Variance Core allocation in Core: \", vc_in_core)\n\nCheck if the Variance Least Core allocation is in the Core\n\nvlc_in_core = verify_in_core(dst_vlc, enum_mode, optimizer)\nprintln(\"Variance Least Core allocation in Core: \", vlc_in_core)","category":"section"},{"location":"examples/theory_of_games/#Compare-reward-allocations","page":"Fair reward allocations","title":"Compare reward allocations","text":"Create a DataFrame to compare the different allocations\n\ndf = DataFrame(\n    Member = collect(keys(dst_sh)),\n    Shapley = collect(values(dst_sh)),\n    Nucleolus = collect(values(dst_nuc)),\n    Variance_Core = collect(values(dst_vc)),\n    Variance_Least_Core = collect(values(dst_vlc)),\n)\nprintln(df)\n\nPlot the comparison\n\ngroupedbar(\n    df.Member,\n    [df.Shapley df.Nucleolus df.Variance_Core df.Variance_Least_Core],\n    label = [\"Shapley\" \"Nucleolus\" \"Variance Core\" \"Variance Least Core\"],\n    title = \"Comparison of Fair Reward Allocations\",\n    xlabel = \"Community Members\",\n    ylabel = \"Allocated Reward [€]\",\n    bar_position = :dodge,\n)","category":"section"},{"location":"examples/theory_of_games/#Iterative-method-for-reward-allocations","page":"Fair reward allocations","title":"Iterative method for reward allocations","text":"For large energy communities, the enumerative method may become computationally expensive as it implies the calculation of the utility function for all possible coalitions. In such cases, an iterative method employing row-generation can be employed to estimate fair reward allocations more efficiently. This example showcases how to set up an iterative method for computing the Nucleolus allocation.\n\nDefine the iterative mode for cooperative games\n\niter_mode = IterMode(\n    CO_Model,\n    EnergyCommunity.GroupNC(),  # Base group is the Non Cooperative group\n    no_aggregator_type=EnergyCommunity.GroupNC(),  # when the aggregator is not in the community, use Non Cooperative group\n    optimizer=optimizer,\n)\n\nCalculate Variance Least Core with iterative method\n\ndst_vlc_iter = var_least_core(iter_mode, optimizer)\ndst_vlc_iter\n\nCompare the distributions from the enumerative and iterative methods\n\nprintln(\"Difference between enumerative and iterative Variance Least Core allocations:\")\nfor member in keys(dst_vlc)\n    diff = dst_vlc[member] - dst_vlc_iter[member]\n    println(\"Member: \", member, \", Absolute Difference [%]: \", 100*abs(diff)/dst_vlc[member])\nend\n\ninfo: Info\nView this file on Github.\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"configuration/configuration/#Configuration","page":"Configuration","title":"Configuration","text":"","category":"section"},{"location":"configuration/configuration/#Introduction","page":"Configuration","title":"Introduction","text":"EnergyCommunity.jl uses a structured YAMLbased configuration system to define the properties of:\n\nthe simulation environment (time horizon, discount rate, user list),\nthe market environment (tariffs, peak categories, price signals),\nthe users and their assets (loads, generators, storage, heat pumps, converters, etc.).","category":"section"},{"location":"configuration/configuration/#Obtaining-Example-Configurations","page":"Configuration","title":"Obtaining Example Configurations","text":"To locally obtain example configurations, it is possible to obtain default sample configuration files by running the following command:\n\njulia> using EnergyCommunity\n\njulia> create_example_data(\".\", config_name=\"default\")\n\nThis code creates a folder named data in the current directory with the following files:\n\nenergy_community_model.yaml: a sample configuration file for a Energy Community system.\nmarket_data.csv: a csv file with quantities related to the market prices, such as time-varying electricity prices and more.\ninput_resource.csv: a csv file with data related to the demand by each user and specific renewable production by time step of the simulation.\nenergy_community_model_thermal.yaml: another sample configuration file for a Energy Community that contains also dispatchable fuel-fired generators.\n\nTo easily view the files, please explore the default folder online","category":"section"},{"location":"configuration/configuration/#Overview-of-the-Configuration-Structure","page":"Configuration","title":"Overview of the Configuration Structure","text":"A typical EnergyCommunity.jl configuration file contains three top-level sections:\n\ngeneral:\n  ...\n\nmarket:\n  ...\n\nusers:\n  ...\n\nEach section has a specific purpose:\n\nSection Purpose\ngeneral Defines project-wide settings such as number of users, time horizon, discount rate, global profiles, and optional datasets\nmarket Defines tariff structures, buy/sell/consumption prices, peak-tariff processing functions, and user-specific market types\nusers Defines the list of users and, for each user, the set of installed or installable assets with their parameters and profiles\n\nIn the following sections, we describe them in detail.","category":"section"},{"location":"configuration/configuration/#Customizing-time-series-through-the-profile-field","page":"Configuration","title":"Customizing time-series through the profile field","text":"Many components in EnergyCommunity.jl (loads, renewable generators, heat pumps, thermal storage, market tariffs, etc.) require time-series inputs.   These inputs are specified in a profile sub-field within each component or market type.\n\nThe profile mechanism is intentionally flexible and customizable, allowing users to provide data in several formats depending on convenience and dataset availability.\n\nEnergyCommunity.jl supports four modes for specifying profile values.","category":"section"},{"location":"configuration/configuration/#1.-Strings-—-Reference-a-Column-Name","page":"Configuration","title":"1. Strings — Reference a Column Name","text":"If the value is a string, it is interpreted as the name of a column in an external time-series CSV file (for example market_data.csv or input_resource.csv).","category":"section"},{"location":"configuration/configuration/#Example","page":"Configuration","title":"Example","text":"profile:\n  buy_price: buy_price\n  sell_price: sell_price\n  ren_pu: pv\n\nMeaning:\n\nThe value of buy_price is read from the \"buy_price\" column.\nThe value of ren_pu is read from the \"pv\" column.\nThis is the most common mode when time-series data are already available.","category":"section"},{"location":"configuration/configuration/#2.-Float-Numbers-—-Constant-Values","page":"Configuration","title":"2. Float Numbers — Constant Values","text":"If the value is a number, it is interpreted as a constant time series, meaning the same value applies to every timestep.","category":"section"},{"location":"configuration/configuration/#Example-2","page":"Configuration","title":"Example","text":"profile:\n  COP: 3.0\n\nMeaning:\n\nCOP is equal to 3.0 for all timesteps in the simulation horizon.\n\nThis option is convenient when:\n\na constant performance value is adequate,\nbuilding simplified test cases,\nor when detailed time-series data are unavailable.","category":"section"},{"location":"configuration/configuration/#3.-Lists-—-Inline-Time-Series","page":"Configuration","title":"3. Lists — Inline Time Series","text":"If a YAML list is provided, it is interpreted as a direct time-series vector.","category":"section"},{"location":"configuration/configuration/#Example-3","page":"Configuration","title":"Example","text":"profile:\n  load: [2.1, 2.3, 2.0, 2.5, 2.6]\n\nMeaning:\n\nAt timestep 1, load = 2.1\nAt timestep 2, load = 2.3\n... and so on.\n\nThis mode is useful for:\n\nsmall demonstration cases,\nmanually defined time-series,\nsynthetic or placeholder data.","category":"section"},{"location":"configuration/configuration/#4.-Dictionaries-—-Custom-Julia-Functions","page":"Configuration","title":"4. Dictionaries — Custom Julia Functions","text":"A dictionary allows you to specify a custom Julia function that constructs the time series.\n\nThis is the most flexible option and is used when the time-series data cannot be taken directly from a column, or when additional processing is needed.","category":"section"},{"location":"configuration/configuration/#General-Structure","page":"Configuration","title":"General Structure","text":"profile:\n  some_quantity:\n    function: <function_name>\n    inputs:\n      - input1\n      - input2\n\nEnergyCommunity.jl will:\n\nLook up the function <function_name>.\nCollect the inputs listed under inputs.\nCall the function with those inputs.\nStore the returned vector as the time series for some_quantity.","category":"section"},{"location":"configuration/configuration/#Application-to-market","page":"Configuration","title":"Application to market","text":"This method is widely used in the market section to define complex tariff structures. For example, the peak tariff peak_tariff of each market tariff is associated with each peak category. However, the input csv files are generally indexed by time steps, and so are peak_tariff and peak_categories columns in the input csv files. To overcome this, the dictionary-based functionality is adopted to apply the custom function parse_peak_quantity_by_time_vectors and remap the time series accordingly.\n\npeak_tariff:\n    function: parse_peak_quantity_by_time_vectors\n    inputs: \n    - peak_categories\n    - peak_tariff","category":"section"},{"location":"examples/electric_vehicle/#Electric-Vehicle","page":"Electric Vehicle","title":"Electric Vehicle","text":"This example demonstrates how to model heating and cooling flexibility in a building using EnergyCommunity.jl using the example provided by the tool named \"energycommunitymodel_flexibility\". The example includes 3 users:\n\nUser 1: User with a PV system, an electric load and an adjustable load representing the user's recharging station with an electric vehicle with 53kWh battery\nUser 2: User with a PV, battery system and an electric load\nUser 3: User with a PV, wind, battery system\n\nThis example showcase how to load and optimize an energy community model with the flexibility offered by a single electric vehicle.\n\nIn particular, the electric vehicle is modeled as an adjustable load with the following quantities retrieved from the file \"data/flexibility_resources.csv\":\n\nenergy_exchange: vector of energy exchange towards the recharging station: when positive with value X, it denotes a new EV to be connected with state of charge X; when negative with value -Y, it denotes an EV to be disconnected with state of charge Y\nmax_supply: maximum discharging power of the recharging station, depending on the available EVs; if no power-to-grid is allowed, this value must be 0\nmax_withdrawal: maximum charging power of the recharging station, depending on the available EVs\nmin_energy: minimum state of charge of the recharging station, accounting for all connected EVs\nmax_energy: maximum state of charge of the recharging station, accounting for all connected EVs","category":"section"},{"location":"examples/electric_vehicle/#Initialization","page":"Electric Vehicle","title":"Initialization","text":"Import the needed packages\n\nusing EnergyCommunity, JuMP\nusing HiGHS, Plots\n\nCreate a base Energy Community example in the data folder; use the default configuration.\n\nfolder = joinpath(@__DIR__, \"data\")\ncreate_example_data(folder, config_name=\"default\")\n\nInput file to load the structure of the energy community based on a yaml file.\n\ninput_file = joinpath(@__DIR__, \"data/energy_community_model_flexibility.yml\");\nnothing #hide\n\nOutput path of the plots\n\noutput_plot_isolated = joinpath(@__DIR__, \"./results/Img/plot_user_{:s}_CO.png\");\nnothing #hide\n\ndefine optimizer and options\n\noptimizer = optimizer_with_attributes(HiGHS.Optimizer, \"ipm_optimality_tolerance\"=>1e-6)","category":"section"},{"location":"examples/electric_vehicle/#Create,-build-and-optimize-the-model","page":"Electric Vehicle","title":"Create, build and optimize the model","text":"Define the Cooperative model\n\nEV_Model = ModelEC(input_file, EnergyCommunity.GroupCO(), optimizer)\n\nBuild the mathematical model\n\nbuild_model!(EV_Model)\n\nOptimize the model\n\noptimize!(EV_Model)","category":"section"},{"location":"examples/electric_vehicle/#Results","page":"Electric Vehicle","title":"Results","text":"get objective value\n\nobjective_value(EV_Model)","category":"section"},{"location":"examples/electric_vehicle/#Plots-of-dispatch","page":"Electric Vehicle","title":"Plots of dispatch","text":"Create plots of the dispatch of resources by user and save them to disk\n\nall_plots = plot(EV_Model, output_plot_isolated)\nuser_to_plot = 3  # select user to plot\nplot(all_plots[user_to_plot, 3])  # show the plot of user 3 (top: power dispatch, bottom: battery storage)\n\ninfo: Info\nView this file on Github.\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"configuration/users/#users-Section","page":"users Section","title":"users Section","text":"The users section defines all participating users and their asset portfolios, as shown below:\n\nusers:\n  ...\n  user1:\n    tariff_name: <tariff_type>\n    asset1:\n      type: <asset_type>\n      ...\n    asset2:\n      type: <asset_type>\n      ...\n    ...\n  \n  user2:\n    tariff_name: <tariff_type>\n    ...\n\n  ...\n\nThe overall structure has the following major characteristics:\n\nEach user is identified by a unique user ID (e.g., user1, user2)\nEach user has a specified tariff type under the tariff_name field, which determines the pricing structure applicable to that user in agreement to the tariff types available in the market section\nEach user can own multiple assets, each defined under its unique asset name (e.g., asset1, asset2), with each asset having a specified type (e.g., renewable, storage, load, etc.) and associated parameters relevant to that asset type\nEach user may own different types and numbers of assets, also of the same type, allowing for diverse configurations within the Energy Community to investigate technology options\nThe list of supported assets is listed in the following section of the documentation.","category":"section"},{"location":"configuration/users/#Example","page":"users Section","title":"Example","text":"An example for a domestic user having a photovoltaic (PV) system and a load profile is shown below:\n\nusers:\n  user1:\n    tariff_name: non_commercial\n    PV:\n      type: renewable\n      CAPEX_lin: 1700\n      OEM_lin: 30\n      lifetime_y: 25\n      max_capacity: 300\n      profile:\n        ren_pu: pv\n    load:\n      type: load\n      profile:\n        load: load_user1\n  ...","category":"section"},{"location":"model/intro_model/#Architecture-of-the-model","page":"Architecture of the model","title":"Architecture of the model","text":"","category":"section"},{"location":"model/intro_model/#Introduction","page":"Architecture of the model","title":"Introduction","text":"The optimization model implemented in EnergyCommunity.jl is based on a Mixed-Integer Linear Programming (MILP) model implemented in JuMP.jl, accounting for:\n\nTechnical operation of assets (loads, PV, storage, flexible resources).\nMarket interaction with the main grid (imports/exports, tariffs).\nEnergy shared among users of the community.\nConfiguration of the EC: non-cooperative, aggregated-non-cooperative, cooperative.\n\nIn the following, we provide a general description of the mathematical model, starting from the techno-economic model that is valid for all EC configurations, and then describing the specific models suited for the specific configurations.\n\nPlease refer to the following references for more details:\n\nD. Fioriti, G. Bigi, A. Frangioni, M. Passacantando and D. Poli, \"Fair Least Core: Efficient, Stable and Unique Game-Theoretic Reward Allocation in Energy Communities by Row-Generation,\" in IEEE Transactions on Energy Markets, Policy and Regulation, vol. 3, no. 2, pp. 170-181, June 2025, doi: 10.1109/TEMPR.2024.3495237.\nD. Fioriti, A. Frangioni, D. Poli, \"Optimal sizing of energy communities with fair revenue sharing and exit clauses: Value, role and business model of aggregators and users,\" in Applied Energy, vol. 299, 2021, 117328,doi: 10.1016/j.apenergy.2021.117328","category":"section"},{"location":"model/intro_model/#Techno-economic-model","page":"Architecture of the model","title":"Techno-economic model","text":"The techno-economic model of the Energy Community (EC) is based on the model depicted in the figure below, which highlights the general structure of components available by each user j in I, where I is the set of community members, and energy flows. In the following, we first describe the user's expenses and then the main constraints of the model.\n\n(Image: Scheme of the Energy Community)","category":"section"},{"location":"model/intro_model/#Energy-Community-configurations","page":"Architecture of the model","title":"Energy Community configurations","text":"The mathematical model implemented in EnergyCommunity.jl can be configured to represent different types of Energy Communities (ECs), namely:\n\nNon-cooperative EC (NC): In the NC configuration, each user j in I optimizes its own energy system independently, without considering energy sharing with other community members. The objective function for each user is to maximize its own Net Present Value (NPV) based on individual energy consumption, generation, and costs. Let SW^NC(J) = sum_j in J mathrmNPV_j be the sum of the Net Present Value for all users, then the optimization problem for the Non-Cooperative formulation is formulated as follows:\nbeginarrayll\nmax  SW^NC(I) = sum_j in I mathrmNPV_j \ntextst  textUsers power and energy system constraints\nendarray\nNote that as the problem is separable for each user j, it can be solved independently for each user. However, for simplicity, EnergyCommunity.jl implements the problem as a single optimization problem including all users as shown in the previous equation.\nAggregated Non-cooperative EC (ANC): In the ANC configuration, each user j in I still optimizes its own energy system independently, but the model allows for the aggregation of certain resources or costs at the community level. This can include shared infrastructure or collective purchasing of energy, leading to potential cost savings for individual users while still maintaining independent optimization. In mathematical terms, the social welfare SW^ANC(I) of the community is defined as the sum of the individual NPVs of each user plus an additional term mathrmNPV^sh_NC(I) that accounts for the benefits or costs associated with shared resources or collective actions that naturally occur. The actual optimization problem remains the same as in the Non-Cooperative case, but the overall social welfare is adjusted to reflect the aggregated aspects of the community.\nSW^ANC(I) = SW^ANC(I) + mathrmNPV^sh_NC\nCooperative EC (CO): In the CO configuration, all users j in I collaborate to optimize the energy system of the entire community as a whole. The objective function is to maximize the collective NPV of the community, taking into account the energy system of each user havign objective term NPV_j and the additional term mathrmNPV^sh related to the shared energy. This configuration promotes cooperation and can lead to more efficient energy management and cost savings for all members.\nbeginarrayll\nmax  SW^CO(I) = sum_j in I mathrmNPV_j + mathrmNPV^sh \ntextst  textUsers power and energy system constraints\n             textShared energy constraints\nendarray","category":"section"},{"location":"#Introduction","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"#What-is-EnergyCommunity.jl?","page":"Introduction","title":"What is EnergyCommunity.jl?","text":"EnergyCommunity is a package for the optimal design and dispatch of Energy Communities at different level of aggregation. Provided easy to read configuration files, EnergyCommunity.jl creates a mathematical optimization model using JuMP.jl and solves it using any optimization solver compatible with JuMP.jl. The JuMP mathematical model is also editable and customized.\n\nEnergyCommunity.jl automatically builds a Mixed-Integer Linear Programming model that represents the optimal dispatch and design of an Energy Community composed by an arbitrary number of users, as shown in the image.\n\n(Image: Scheme of the Energy Community)","category":"section"},{"location":"#Features","page":"Introduction","title":"Features","text":"Optimal dispatch and design of Energy Communities composed by an arbitrary number of users using Mixed-Integer Linear Programming;\nMultiple types of users: prosumers, consumers, and producers;\nSupport for multiple configurations of Energy Communities:\nNon-Cooperative (NC): no Energy Community is in place as each user optimizes its own costs independently from the others and no shared reward applies;\nAggregated-Non-Cooperative (ANC): an Energy Community is in place but users do not cooperate, so each user optimizes its own costs independently from the others and the shared reward applies for the shared energy that naturally flows among users;\nCOoperative (CO): an Energy Community is in place and users cooperate to minimize the overall costs and share the benefits;\nEach user may own different technologies: batteries, electric vehicles, photovoltaic systems, combined heat and power units, thermal storage systems, heat pumps, boilers, and more;\nEstimate fair reward distribution across users with TheoryOfGames.jl;\nSupport to save and load the model to disk;\nAutomatic generation of plots to visualize the results for each user and for the overall Energy Community.","category":"section"},{"location":"#Quick-start","page":"Introduction","title":"Quick start","text":"Optimizing energy communities with EnergyCommunity.jl is straightforward. After installing the package, you can create a configuration file (YAML or JSON format) describing the energy community and its users, and then run the optimization. Here is a simple example using a YAML configuration file:\n\nusing EnergyCommunity\nusing HiGHS, Plots, JuMP\n\n# create a sample Energy Community model input files in folder \"data\"\ncreate_example_data(\"data\")\n\n# define input configuration (available in the package)\ninput_file = \"./data/energy_community_model.yml\"\n\n# define pattern of plot by user: the \"{:s}\" will be filled with the name of the user\noutput_plot_combined = \"outputs/Img/plot_user_{:s}_EC.png\"\n\n# create the Energy Community model in Cooperation mode GroupCO()\nECModel = ModelEC(input_file, EnergyCommunity.GroupCO(), HiGHS.Optimizer)\n\n# build the model\nbuild_model!(ECModel)\n\n# optimize the model\noptimize!(ECModel)\n\n# create some plots\nplot(ECModel, output_plot_combined)","category":"section"},{"location":"#Resources-for-getting-started","page":"Introduction","title":"Resources for getting started","text":"Please, check out the examples in the example section and the files available in the example folder of the github repository.\n\nTo learn more about the Julia framework, please check out this simple introduction or more material in julialang.\n\nFor more material on the backbone optimization framework, please refer to documentation of JuMP.jl. JuMP is a domain-specific modeling language that allows mathematical optimization embedded in Julia.","category":"section"},{"location":"#Scientific-references","page":"Introduction","title":"Scientific references","text":"D. Fioriti, G. Bigi, A. Frangioni, M. Passacantando and D. Poli, \"Fair Least Core: Efficient, Stable and Unique Game-Theoretic Reward Allocation in Energy Communities by Row-Generation,\" in IEEE Transactions on Energy Markets, Policy and Regulation, vol. 3, no. 2, pp. 170-181, June 2025, doi: 10.1109/TEMPR.2024.3495237.\nD. Fioriti, A. Frangioni, D. Poli, \"Optimal sizing of energy communities with fair revenue sharing and exit clauses: Value, role and business model of aggregators and users,\" in Applied Energy, vol. 299, 2021, 117328,doi: 10.1016/j.apenergy.2021.117328","category":"section"},{"location":"configuration/general/#general-Section","page":"general Section","title":"general Section","text":"","category":"section"},{"location":"configuration/general/#Scope-and-overview","page":"general Section","title":"Scope and overview","text":"The general block contains meta-information governing the simulation setup, project structure, and global profiles shared across users.\n\nExample:\n\ngeneral:\n  init_step: 1\n  final_step: 1152\n  d_rate: 0.03\n  project_lifetime: 20\n  user_set: [user1, user2, user3]\n  profile:\n    time_res: time_res\n    energy_weight: energy_weight\n    reward_price: reward_price\n    peak_categories: peak_categories\n  optional_datasets:\n    - input_resource.csv\n    - market_data.csv\n    - flexibility_resource.csv\n\nThe example showcase the use of the tool for the simulation of 3 users (user1, user2, user3) over a project lifetime of 20 years, with an initial step of 1 and a final step of 1152. The discount rate is set to 3%. The profiles for time resolution, energy weight, reward price, and peak categories are defined under the profile section. Additionally, optional datasets such as input_resource.csv, market_data.csv, and flexibility_resource.csv are specified for inclusion in the simulation.\n\nNote: The optional_datasets section contains a list of additional CSV files that can be included in the simulation for enhanced data input. The string entries in all profile fields are interpreted as column names from the CSV files listed in the optional_datasets field.","category":"section"},{"location":"configuration/general/#Parameters-in-general-Section","page":"general Section","title":"Parameters in general Section","text":"using CSV, DataFrames, Latexify\ndf = CSV.read(\"../../src/configtables/general.csv\", DataFrame)\nmdtable(coalesce.(df, \"\"), latex=false, adjustment=:l)","category":"section"}]
}
