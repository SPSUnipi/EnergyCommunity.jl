var documenterSearchIndex = {"docs":
[{"location":"installation/#Installation-guide","page":"Installation guide","title":"Installation guide","text":"This guide explains how to install EnergyCommunity.jl and its dependencies.","category":"section"},{"location":"installation/#Install-Julia","page":"Installation guide","title":"Install Julia","text":"EnergyCommunity.jl is a Julia package. To use it, you need to install Julia. You can download Julia from the official website.","category":"section"},{"location":"installation/#Install-EnergyCommunity.jl","page":"Installation guide","title":"Install EnergyCommunity.jl","text":"To install EnergyCommunity.jl, you can use the Julia package manager. Open Julia and run the following commands:\n\njulia> import Pkg\n\njulia> Pkg.add(\"EnergyCommunity\")","category":"section"},{"location":"installation/#Install-a-solver","page":"Installation guide","title":"Install a solver","text":"EnergyCommunity.jl requires an optimization solver to solve the optimization problem. You can use any optimization solver compatible with JuMP.jl. For example, you can use the open-source solver HiGHS. To install HiGHS, run the following command:\n\njulia> Pkg.add(\"HiGHS\")\n\nIt is recommended to use a solver capable of Mixed-Integer Linear Programming. You can find a list of solvers compatible with JuMP.jl here.","category":"section"},{"location":"installation/#Install-input/output-packages","page":"Installation guide","title":"Install input/output packages","text":"EnergyCommunity.jl also supports input/output featurs, such as saving/loading a model to disk or plotting results. To install the plotting package Plots.jl, run the following command:\n\njulia> Pkg.add(\"Plots\")\n\nTo install FileIO.jl that is used to export the model to disk, run the following command:\n\njulia> Pkg.add(\"FileIO\")","category":"section"},{"location":"model/power_model/#User-power-model","page":"User power model","title":"User power model","text":"","category":"section"},{"location":"model/power_model/#User's-goal","page":"User power model","title":"User's goal","text":"","category":"section"},{"location":"model/power_model/#Net-Present-Value","page":"User power model","title":"Net Present Value","text":"The Net Present Value NPV_j of each user j accounts for the cash flows for every year y in Y, where Y is the set of years in the planning horizon, accounting for net revenues R_jy by exchanging energy with the grid, investment costs I_jy, peak charges PP_jy, operating costs OP_jy, replacement costs RP_jy, and residual value RV_jy at the end of the project, discounted at rate r:\n\nmathrmNPV_j = sum_y in Y frac R_jy - I_jy - OF_jy - OV_jy - PP_jy - RP_jy + RV_jy (1+r)^y","category":"section"},{"location":"model/power_model/#Net-Revenues-of-energy-flow-with-the-grid","page":"User power model","title":"Net Revenues of energy flow with the grid","text":"The net revenues are proportional to the energy withdrawn from the grid P^U-_jt, the energy injected into the grid P^U+_jt, and the consumption P^L_jt to the main grid, weighted by the respective prices pi^+_jt, pi^-_jt, and excise pi^ex_jt at each time period t in T, where t is the set of time periods in the planning horizon, and scaled by the time resolution Delta_t and the weighting factor m^T_t of each period to account for the use of representative days:\n\nR_jy = sum_t in T m^T_t Delta_t left( pi^+_jtP^U_jt+ - pi^-_jtP^U_jt- - pi^ex_jtP^L_jt right)","category":"section"},{"location":"model/power_model/#Investment-Costs","page":"User power model","title":"Investment Costs","text":"Investment charges are incurred only at the beginning of the project (y = 0) and account for the all assets A_j owned by the user j. The cost of each asset a in A_j is proportional to the nominal capacity x_aj of that asset and the per-unit cost c^I_aj:\n\nI_j0 = sum_ain A_j c^I_aj x_aj qquad I_jy=0  forall y0","category":"section"},{"location":"model/power_model/#Fixed-Operating-costs","page":"User power model","title":"Fixed Operating costs","text":"Yearly fixed operating costs OP_jy include costs proportional the nominal capacity x_aj of each asset by per-unit cost factor c^M_aj. Fixed operating costs do not apply to fuel-fired generators A^G_j, as their maintenance charges are proportional to the number of dispatched hours and accounted for in the variable operating costs.\n\nOF_jy = sum_ain A_j x_aj c^M_aj quad forall a in A_j  A^G_j","category":"section"},{"location":"model/power_model/#Variable-Operating-costs-(fuel-fired-assets)","page":"User power model","title":"Variable Operating costs (fuel-fired assets)","text":"Variable operating costs OV_jy account for the fuel costs and maintenance charges related to the operation of fuel-fired generators A^G_j and fuel-fired boilers A^boil_j owned by user j. The fuel consumption F_jgt of each generator g in A^G_j at time t is multiplied by the fuel cost pi^F_jg and scaled by the weighting factor m^T_t of each period to account for the use of representative days. The maintenance costs of generators are proportional to the number of hours the units have been dispatched and the per-unit maintenance cost c^M_gj. The fuel costs of boilers o in A^boil_j are proportional to the thermal power output P^boil_jot, the fuel price pi^F_jo, and inversely proportional to the product of the lower heating value PCI_jo and efficiency eta_jo of the boiler:\n\nOV_jy = sum_tin T m^T_t leftsum_g in A^G_j ( pi^F_jg F_jgt + Delta_t c^M_gj s_jgt) + sum_o in A^boil_j Delta_t pi^F_jo dfracP^boil_jotPCI_jo eta_jo  right","category":"section"},{"location":"model/power_model/#Peak-Power-Charges","page":"User power model","title":"Peak Power Charges","text":"The peak-power charges PP_jy describes charges related to the nominal capacity of the connection to the grid, that are modelled proportional the maximum peak power at the POD P^Umax_jw and the per-unit cost c^P_jw for each representative peak period w in W, where W is the set of peak periods, scaled by the weighting factor m^W_w of each period to account for the use of representative days:\n\nPP_jy = sum_win W m^W_w  c^P_jw  P^Umax_jw","category":"section"},{"location":"model/power_model/#Replacement-Costs","page":"User power model","title":"Replacement Costs","text":"The replacement charges RP_jy describe the costs for replacing assets during the project. When an asset a in A_j reaches its end of life N^Y_aj, that is mod(y N^Y_aj) = 0, the asset is replaced thus leading to additional expences. The replacement costs are modelled proportional the nominal capacity x_aj of each asset by per-unit cost factor c^I_aj, as for the investment costs:\n\nRP_jy = begincases\ndisplaystyle\nsum_ain A_j x_aj c^I_aj\n textif  mathrmmod(y N^Y_aj) = 0 \n0  textotherwise\nendcases","category":"section"},{"location":"model/power_model/#Residual-Value","page":"User power model","title":"Residual Value","text":"Finally, the residual value RV_jy accounts for the remaining value of assets at the end of the project (y = Y); for all other years RV_jy = 0. For each asset a in A_j, if the asset has not reached its end of life N^Y_aj, a fraction of the investment cost proportional to the remaining useful life is considered.\n\nRV_jY = sum_ain A_j x_aj c^I_aj frac N^Y_aj - mathrmmod(Y-1 N^Y_aj) N^Y_aj","category":"section"},{"location":"model/power_model/#Power-Balance","page":"User power model","title":"Power Balance","text":"The energy balance of the energy system at each user j and time t is guaranted by the following equation:\n\nP^U+_jt - P^U-_jt + sum_cin A^C_j(P^c-_jt - P^c+_jt) - P^R_jt + sum_g in A^G_jP^g_jt + sum_d in A^D_jP^textadj_jdt + sum_h in A^HP_jP^elHP_jht = - sum_f in A^F_j P^L_jft\n\nwhere:\n\nP^U+U-_jt+ is the power injected (+) into or withdrawn (-) from the grid by user j at time t measured at the Point of Delivery (PoD);\nP^c-c+_jt is the discharging power of converter c;\nP^R_jt is the total renewable generation;\nP^g_jt is the power generated by fuel-fired generator g;\nP^textadj_jdt is the net power exchanged by adjustable load d;\nP^HP_jht is the power consumed by heat pump h whose modelling is described in the section of thermal model;\nP^L_jt is the power consumption of user j at time t.\nA^CGRDF_j is the set of converters (C), fuel-fired generators (G), renewable assets (R) and dispatchable (D) and fixed (F) loads owned by user j;","category":"section"},{"location":"model/power_model/#Peak-Power-Definition","page":"User power model","title":"Peak Power Definition","text":"For each user j and window w, the peak-power P^Umax_jw is defined as the maximum power withdrawn or injected from the grid P^U_jt- over all time periods t in the representative peak-period window T_w:\n\nP^Umax_jw ge maxleft(P^U+_jt P^U-_jtright) quad forall t in T_w\n\nIn linear form, the max is implemented with the following two constraints:\n\nP^Umax_jw ge P^U_jt+ quad forall t in T_w\nP^Umax_jw ge P^U_jt- quad forall t in T_w","category":"section"},{"location":"model/power_model/#Renewable-Generation-Limit","page":"User power model","title":"Renewable Generation Limit","text":"For each user j and time step t, the total renewable generation P^R_jt is limited by the set A^R_j of renewable assets, their nominal capacity x_rj that is a variable optimized by the algorithm and the per-unit renewable production p^r_jt:\n\nP^R_jt le sum_rin A^R_j p^r_jt x_rj","category":"section"},{"location":"model/power_model/#Battery-and-Converter-Constraints","page":"User power model","title":"Battery and Converter Constraints","text":"Each battery b in A^B_j owned by user j, where A^B_j is the set of storage assets owned by user j, must have a corresponding converter c(b) in A^C_j, where A^C_j is the set of converters owned by user j. The converter c(b) is used to charge and discharge the battery b. \n\nFor battery b in A^B_j owned by user j, the energy E_jbt stored in the battery is regulated by the following equation, where P^c(b)+_jt is the charging power of the converter c(b), P^c(b)-_jt is the discharging power of the converter c(b), and eta_b is the round-trip efficiency of the battery b.\n\nE_jbt = E_jbt-1 - Delta_t fracP^c(b)+_jteta_b + Delta_t eta_b P^c(b)-_j t\n\nMaximum and minimum energy limits apply:\n\nbeta^min_bj x_bj le E_jbt le beta^max_bj x_bj\n\nPower limits on the converter c apply as follows, where x_cj is the nominal power capacity of the converter c owned by user j:\n\nMaximum charging P^c+_jt le x_cj\nMaximum discharging P^c-_jt le x_cj","category":"section"},{"location":"model/power_model/#Modular-units","page":"User power model","title":"Modular units","text":"Units where modularity option is enabled are modelled by introducing integer variables n_aj representing the number of installed modules of type A^M_j and constraints linking the total capacity to the number of modules and the capacity per module. n_aj is an integer variable representing the number of modules of asset a owned by user j, and overlineS^a_j is the capacity per module.\n\nx_aj = n_aj overlineS^a_j quad forall a in A^M_j","category":"section"},{"location":"model/power_model/#Fuel-Fired-Generators","page":"User power model","title":"Fuel-Fired Generators","text":"The dispatch of each fuel-fired generator g in A^G_j owned by user j is regulated by unit-commitment constraints and require modularity option, that is the fuel-fired generators are of standardized nominal capacity overlineS^a_j. Minimum and maximum power limitations apply. Accordingly, the generation P^g_jt is limited by the number of dispatched units s_jgt as shown below:\n\nbeta^min_jg overlineS^a_j x_gj le P^g_jt le beta^max_jg overlineS^a_j x_gj\n\nThe number of dispatched units is limited by the number of installed units n_gj:\n\ns_gj le n_gj\n\nThe fuel consumption F_jgt is proportional to the generated power P^g_jt by the using a piece-wise linear function of slope c^FSg_j and intercept c^FIg_j:\n\nF^g_jt = c^FSg_j P^g_jt + Delta c^FIg_j s_jgt","category":"section"},{"location":"model/power_model/#Deferrable-loads-(not-implemented-yet)","page":"User power model","title":"Deferrable loads (not implemented yet)","text":"Not implemented yet.","category":"section"},{"location":"model/power_model/#Adjustable-loads","page":"User power model","title":"Adjustable loads","text":"Adjustable loads represent appliances whose electrical consumption can be modulated in time within technical boundaries while still satisfying a mandatory energy trajectory over the planning horizon. Examples include electric vehicles (EVs) or flexible industrial processes. Adjustable loads do have power constraints and energy constraints. The latter ensures that the total energy consumed (or supplied) by the adjustable load over the planning horizon matches a predefined energy trajectory.\n\nEach adjustable load d in A^D_j among the adjustable loads A^D_j owned by the user j is indexed by can absorb (P^textadjN_jdt) or supply (P^textadjP_jdt) power in agreement to specific constraints, where overlineP^textwithdrawal_jdt and overlineP^textsupply_jdt are specific inputs (constants or time series) provided by the user. For simplicity, we denote P^textadj_jdt the net power exchanged by the adjustable load d at time t, defined as the difference between the power withdrawn and supplied.\n\n  0 le P^textadjN_jdt le overlineP^textwithdrawal_jdt\n  0 le P^textadjP_jdt le overlineP^textsupply_jdt\n  P^textadj_jdt = P^textadjN_jdt - P^textadjP_jdt\n\nThe energy trajectory is regulated by the exogenous energy inflow xi_jdt (positive for charging and negative for discharging) that defines the net energy flows to the component. The energy stored in the adjustable load E^textadj_jdt at each time t is modelled as follows, where eta^P_jd and eta^N_jd are the efficiencies related to power supply and withdrawal.\n\n  E^textadj_jdt = E^textadj_jdt-1 - Delta_t fracP^textadjP_jdteta^P_jd + Delta_t P^textadjN_jdteta^N_jd + xi_jdt\n\nMaximum and minimum energy limits also apply:\n\n  underlineE_jdt le E^textadj_jdt le overlineE_jdt\n\nThis component can be used to model both energy storage systems (e.g., EV batteries) and flexible loads with specific energy requirements. For example, a charging station for Electric Vehicles can be modelled as an adjustable load where power and energy limits are non-zero when vehicles are connected to the recharging station, and the energy trajectory xi_jdt corresponds to the required state of charge by a specific time (e.g., departure time). In particular, when an EV with a given state of charge connects to the station, xi_jdt in that time step can be positive and match that value, signaling the additional state of charge that is being connected. Conversely, when an EV leaves the station, the station is deprived of energy and thus xi_jdt becomes negative. Energy limits are adapted accordingly to model the total minimum and maximum state of charge of all EVs connected to the station at each time t.","category":"section"},{"location":"examples/cooperative/#Cooperative-Energy-Community","page":"Cooperative Energy Community","title":"Cooperative Energy Community","text":"This example is taken from the article Optimal sizing of energy communities with fair revenue sharing and exit clauses: Value, role and business model of aggregators and users by Davide Fioriti et al, url but for a subset of users\n\nThe energy community considered in this example consists of 3 users, where:\n\nall users can install PV system\nonly the first user cannot install batteries, whereas the others can\nthe third user can install also wind turbines\n\nImport the needed packages\n\nusing EnergyCommunity, JuMP\nusing HiGHS, Plots, FileIO\n\nCreate a base Energy Community example in the data folder; use the default configuration.\n\nfolder = joinpath(@__DIR__, \"data\")\ncreate_example_data(folder, config_name=\"default\")\n\nInput file to load the structure of the energy community based on a yaml file.\n\ninput_file = joinpath(@__DIR__, \"data/energy_community_model.yml\");\nnothing #hide\n\nOutput path of the summary and of the plots\n\noutput_file_isolated = joinpath(@__DIR__, \"./results/output_file_CO.xlsx\");\noutput_plot_isolated = joinpath(@__DIR__, \"./results/Img/plot_user_{:s}_CO.png\");\nnothing #hide\n\ndefine optimizer and options\n\noptimizer = optimizer_with_attributes(HiGHS.Optimizer, \"ipm_optimality_tolerance\"=>1e-6)\n\nDefine the Non Cooperative model\n\nCO_Model = ModelEC(input_file, EnergyCommunity.GroupCO(), optimizer)\n\nBuild the mathematical model\n\nbuild_model!(CO_Model)\n\nOptimize the model\n\noptimize!(CO_Model)\n\nget objective value\n\nobjective_value(CO_Model)\n\nCreate plots of the results\n\nplot(CO_Model, output_plot_isolated)\n\nPrint summaries of the results\n\nprint_summary(CO_Model)\n\nSave summaries\n\nsave_summary(CO_Model, output_file_isolated)\n\nPlot the sankey plot of resources\n\nplot_sankey(CO_Model)\n\nDataFrame of the business plan\n\nbusiness_plan(CO_Model)\n\nplot business plan\n\nbusiness_plan_plot(CO_Model)\n\nsave the model to a jld2 file\n\nsave(\"co_model.jld2\", CO_Model)\n\nread the loaded model from the jld2 file\n\nCO_Model_loaded = load!(\"co_model.jld2\", ModelEC())\n\nget the objective value of the loaded model\n\nobjective_value(CO_Model_loaded)\n\ninfo: Info\nView this file on Github.\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"theory_of_games/fair_allocation/#Fair-benefit-allocation","page":"Fair benefit allocation","title":"Fair benefit allocation","text":"","category":"section"},{"location":"theory_of_games/fair_allocation/#Scope-of-fair-allocation-in-energy-communities","page":"Fair benefit allocation","title":"Scope of fair allocation in energy communities","text":"EnergyCommunity.jl also provides tools for fair allocation of benefits among participants in an energy community supported by Game Theory. Fair allocation is crucial to ensure that all members are motivated to form, stay and contribute to the community's success. The package implements several well-known methods for fair allocation, including the Shapley value, the nucleolus, FairCore and FairLeastCore, among others, thanks to its interface with TheoryOfGames.jl. While the optimization model described in the previous sections focuses on minimizing the overall costs of the energy community, fair allocation methods ensure that the benefits derived from cost savings are distributed equitably among all participants. For more details, please refer to:\n\nD. Fioriti, A. Frangioni, D. Poli, \"Optimal sizing of energy communities with fair revenue sharing and exit clauses: Value, role and business model of aggregators and users,\" in Applied Energy, vol. 299, 2021, 117328,doi: 10.1016/j.apenergy.2021.117328\nD. Fioriti, G. Bigi, A. Frangioni, M. Passacantando and D. Poli, \"Fair Least Core: Efficient, Stable and Unique Game-Theoretic Reward Allocation in Energy Communities by Row-Generation,\" in IEEE Transactions on Energy Markets, Policy and Regulation, vol. 3, no. 2, pp. 170-181, June 2025, doi: 10.1109/TEMPR.2024.3495237.\n\nLet j in I be the set of participants (also known as \"grand coalition\") in the energy community (including the aggregator A), and let v(J) a generic function that describes the benefit of creating and participating in an energy community for any subgroup J subseteq I of participants. The goal of fair allocation methods is to distribute the total benefit v(I) among all participants in a way that is considered fair according to specific criteria defined by each method. In other words, the goal is to find an allocation vector phi_j    forall j in I where sum_j in I phi_j = v(I) and each phi_j represents the fair share of the benefit allocated to participant j. In the following section, we describe examples of supported fair allocation methods.","category":"section"},{"location":"theory_of_games/fair_allocation/#Benefit-function","page":"Fair benefit allocation","title":"Benefit function","text":"The benefit v(J) is typically calculated as the difference between the objective function SW^group_agg(J) obtained by a cooperative configuration (usually CO) and the value SW^group_base(J) obtained by a base configuration (typically NC). To account for the role of the aggregator, the behavior of the function depends on whether the aggregator A is part of the coalition J or not: when the aggregator is not included in the coalition, the benefit is calculated with respect to an alternative group SW^group_no-agg(J) (e.g., NC or ANC). Formally, the characteristic function v(J) is defined as follows:\n\nv(J) = begincases\n    SW^group_agg(J) - SW^group_base(J)  A in J \n    SW^group_no-agg(J) - SW^group_base(J)  A notin J\nendcases\n\nIn typical scenarios, the cooperative configuration is represented by CO, while the base configuration is NC. When a community is unable to create an EC with no external support, the alternative group without the aggregator can be represented by NC and the characteristic function simplifies to the following typical case:\n\nv(J) = begincases\n    SW^CO(J) - SW^NC(J)  A in J \n    0  A notin J\nendcases","category":"section"},{"location":"theory_of_games/fair_allocation/#Benefit-versus-users'-payoff","page":"Fair benefit allocation","title":"Benefit versus users' payoff","text":"As explained in the previous section, the benefit function v(J) quantifies the total advantage that a coalition of users J with respect to a base case allocation. Accordingly, the fair share of the benefit phi_j allocated to participant j represents the portion of the total benefit v(I) that is fairly assigned to that participant with respect to the base case configuration.\n\nTherefore, let's assume that each user j has a payoff mathrmNPV^base_j in the base case configuration (e.g., NC). The total payoff for user j after fair allocation of the benefit is given by the sum of the base case payoff and the allocated fair share of the benefit:\n\nmathrmNPV^fair_j = mathrmNPV^base_j + phi_j\n\nWhere:\n\nmathrmNPV^fair_j is the total payoff for user j after fair allocation.\nmathrmNPV^base_j is the payoff for user j in the base case configuration (usually NC).","category":"section"},{"location":"model/community_model/#Community-Shared-Energy-and-benefits","page":"Community Shared Energy and benefits","title":"Community Shared Energy and benefits","text":"In cooperative and aggregated-non-cooperative ECs, users can share energy among each other, leading to potential cost savings and increased efficiency. The shared energy exchanged among users is modelled by introducing additional variables and constraints that regulate the energy flows within the community.","category":"section"},{"location":"model/community_model/#Shared-benefits","page":"Community Shared Energy and benefits","title":"Shared benefits","text":"In mathematical terms, the shared energy benefits mathrmNPV^sh in cooperative ECs and mathrmNPV^sh_NC in aggregated-non-cooperative ECs are defined based on the discunted value of the yearly net benefit R^sh_y related to the energy shared.\n\nmathrmNPV^sh = sum_y in Y dfrac R^sh_y (1+r)^y\n\nR^sh_y is defined as proportional to the power P^sh_jt that is procuded and consumed among members of the community; pi^sh_jt is the per-unit reward for every unit of energy shared. Quantities are scaled by the time resolution Delta_t and weighted by factor m^T_t similalrly to other terms in the model.\n\nR^sh_y = sum_t in T m^T_t Delta_t pi^sh_jt P^sh_jt","category":"section"},{"location":"model/community_model/#Shared-power","page":"Community Shared Energy and benefits","title":"Shared power","text":"The shared power P^sh_jt for each user j and time t is limited by the surplus generation and demand measured at users' PoD:\n\nP^sh_jt = min leftlbrace sum_j in I P^U-_jt    sum_j in I P^U-_jt rightrbrace\n\nIn linear form, the min is implemented with the following two constraints:\n\nP^sh_jt le sum_j in I P^U-_jt\nP^sh_jt le sum_j in I P^U-_jt","category":"section"},{"location":"manual/#Manual","page":"Manual","title":"Manual","text":"","category":"section"},{"location":"manual/#Example","page":"Manual","title":"Example","text":"using JuMP, BilevelJuMP, Cbc\n\nmodel = BilevelModel(Cbc.Optimizer, mode = BilevelJuMP.SOS1Mode())\n\n@variable(Lower(model), x)\n@variable(Upper(model), y)\n\n@objective(Upper(model), Min, 3x + y)\n@constraints(Upper(model), begin\n    x <= 5\n    y <= 8\n    y >= 0\nend)\n\n@objective(Lower(model), Min, -x)\n@constraints(Lower(model), begin\n     x +  y <= 8\n    4x +  y >= 8\n    2x +  y <= 13\n    2x - 7y <= 0\nend)\n\noptimize!(model)\n\nobjective_value(model) # = 3 * (3.5 * 8/15) + 8/15 # = 6.13...\nvalue(x) # = 3.5 * 8/15 # = 1.86...\nvalue(y) # = 8/15 # = 0.53...\n\nThe option BilevelJuMP.SOS1Mode() indicates that the solution method used will be a KKT reformulation emplying SOS1 to model complementarity constraints and solve the problem with MIP solvers (Cbc, Xpress, Gurobi, CPLEX, SCIP).\n\nAlternatively, the option BilevelJuMP.IndicatorMode() is almost equivalent to the previous. The main difference is that it relies on Indicator constraints instead. This kind of constraints is available in some MIP solvers.\n\nA third and classic option it the BilevelJuMP.FortunyAmatMcCarlMode(), which relies on the Fortuny-Amat and McCarl big-M method that requires a MIP solver with very basic functionality, i.e., just binary variables are needed. The main drawback of this method is that one must provide bounds for all primal and dual variables. However, if the bounds are good, this method can be more efficient than the previous. Bound hints to compute the big-Ms can be passed with the methods: set_primal_(upper\\lower)_bound_hint(variable, bound), for primals; and set_dual_(upper\\lower)_bound_hint(constraint, bound) for duals. We can also call FortunyAmatMcCarlMode(primal_big_M = vp, dual_big_M = vd), where vp and vd are, repspectively, the big M fallback values for primal and dual variables, these are used when some variables have no given bounds, otherwise the given bounds are used instead.\n\nAnother option is BilevelJuMP.ProductMode() that reformulates the complementarity constraints as products so that the problem can be solved by NLP (Ipopt, KNITRO) solvers or even MIP solvers with the aid of binary expansions (see QuadraticToBinary.jl). Note that binary expansions require variables to have upper and lower bounds.\n\nFinally, one can use BilevelJuMP.MixedMode(default = mode) where mode is one of the other modes described above. With this method it is possible to set complementarity reformulations per constraint with BilevelJuMP.set_mode(ctr, mode).\n\nAn alternative to complementarity constraint reformulation is the Strong Duality reformulation which add the constraint enforcing primal dual equality. The option is BilevelJuMP.StrongDualityMode(eps) where eps is the tolance on the enforcing constraint.","category":"section"},{"location":"manual/#Note-on-[QuadraticToBinary.jl](https://github.com/joaquimg/QuadraticToBinary.jl)","page":"Manual","title":"Note on QuadraticToBinary.jl","text":"QuadraticToBinary.jl is a package that converts quadratic terms in constraints and objective. To do so the pack acts like a solver on top of the real solver and most data is forwarded directly to the solver itself. For many solvers it is enough to use:\n\nSOLVER = Xpress.Optimizer()\nQ_SOLVER = QuadraticToBinary.Optimizer{Float64}(SOLVER)\nBilevelModel(Q_SOLVER, mode = BilevelJuMP.ProductMode(1e-5))\n\nHowever, this might lead to some solver not supporting certain functionality like Cbc. In this case we need to:\n\nSOLVER = Cbc.Optimizer()\nCACHED_SOLVER = MOI.Utilities.CachingOptimizer(\n    MOI.Utilities.UniversalFallback(MOI.Utilities.Model{Float64}()), SOLVER)\nQ_SOLVER = QuadraticToBinary.Optimizer{Float64}(CACHED_SOLVER)\nBilevelModel(()->Q_SOLVER, mode = BilevelJuMP.ProductMode(1e-5))\n\nNote that we used ()->Q_SOLVER instead of just Q_SOLVER because BilevelModel requires as constructor and not an instance of an object.","category":"section"},{"location":"manual/#Advanced-Features","page":"Manual","title":"Advanced Features","text":"","category":"section"},{"location":"manual/#Lower-level-dual-variables","page":"Manual","title":"Lower level dual variables","text":"Suppose you have a constraint b in the lower level:\n\n@constraint(Lower(model), b, ...)\n\nIt is possible to access the dual variable of b to use it in the upper level:\n\n@variable(Upper(model), lambda, DualOf(b))","category":"section"},{"location":"manual/#Conic-lower-level","page":"Manual","title":"Conic lower level","text":"BilevelJuMP allows users to write conic models in the lower level. However, solving this kind of problems is much harder and requires complex solution methods. Mosek's Conic MIP can be used with the aid of QuadraticToBinary.jl.\n\nIt is also possible to solve Second Order Cone constrained models with Ipopt. In this case we need to add a special, non-standard bridge, to Ipopt as follows:\n\nIPO_OPT = Ipopt.Optimizer(print_level=0)\nIPO = MOI.Bridges.Constraint.SOCtoNonConvexQuad{Float64}(IPO_OPT)\nBilevelModel(()->IPO, mode = BilevelJuMP.ProductMode(1e-5))","category":"section"},{"location":"model/energy_model/#User-energy-model","page":"User energy model","title":"User energy model","text":"This section describes the mathematical model used to represent the energy system beyond power in EnergyCommunity.jl. The model integrates:\n\nHeat Pumps (HP): devices providing heating and cooling\nThermal Storage (TES): storage tanks with losses and capacity limits for heat and/or cool\nBoilers: fuel-fired boilers\nThermal Loads: time-varying heating/cooling demand","category":"section"},{"location":"model/energy_model/#Heat-Pumps","page":"User energy model","title":"Heat Pumps","text":"Each heat pump h in A^HP_j operated by user j consumes electricity P^elh_jt to provide thermal power P^HP_jht, where x_jh is the variable of the nominal electrical capacity of the heat pump.\n\n0 le P^elh_jt le x_jh\n\nThe heat pump can operate in either heating or cooling mode, determined by the variable mode: when mode is greater than or equal to +0.5, the heat pump operates in heating mode; when mode is less than or equal to –0.5, it operates in cooling mode.\n\nHeating power when mode ≥ +0.5\nCooling power when mode ≤ –0.5\n\nAccordingly, the thermal output P^HP_jht of the heat pump is defined based on the mode of operation using temperature-dependent COP/EER values:\n\nP^HP_jht =\nbegincases\n P^elh_jt cdot COP_jht  text(heating mode)\n- P^elh_jt cdot EER_jht  text(cooling mode)\nendcases\n\nThe performances of heat pump are modelled using a second-law efficiency multiplied by the Carnot efficiency:\n\nCOP_jht\n= eta^heat_IIjht\ncdot\nfracT_sinkT_sink - T_source(t)\n\nEER_jht\n= eta^cool_IIjht\ncdot\nfracT_source(t)T_sink - T_source(t)\n\nwhere:\n\neta^heat_IIjht and eta^cool_IIjht are the second-law efficiencies for heating and cooling, respectively.\nT_sink is the temperature of the heat sink (e.g., indoor temperature for heating, outdoor temperature for cooling).\nT_source(t) is the time-varying temperature of the heat source (e.g., outdoor temperature).","category":"section"},{"location":"model/energy_model/#Thermal-Storage-(TES)","page":"User energy model","title":"Thermal Storage (TES)","text":"Each thermal energy storage s in A^TES_j has volumetric capacity x_js and supports storing heat and/or cool depending on the input parameters and operation mode. The thermal energy E^TES_jst stored in the storage s at time step t is modelled depending on the specific heat capacity of the fluid cp_js, the reference temperature of the fluid in the storage in heating/cooling mode T^refheatcool_jst, and the input temperature of the fluid T^inheatcool_jst:\n\nWhen in heating mode (mode ≥ +0.5):\n\n0 le E^TES_jst le cp_js x_js left(T^refheat_jst - T^inheat_jst right)\n\nWhen in cooling mode (mode ≤ –0.5):\n\ncp_js x_js left(T^incool_jst - T^refcool_jst right) le E^TES_jst le 0\n\nTES loses heat proportionally by factor k_js to stored energy and to the temperature difference between the reference heating or cooling temperature of the fluid T^refheatcool_jst, in the storage and the unheated-zone temperature T^U_jst:\n\nWhen in heating mode (mode ≥ +0.5):\n\nL^TES_jst = k_js E^TES_jst-1 left(T^refheat_jst - T^U_jstright)\n\nWhen in cooling mode (mode ≤ –0.5):\n\nL^TES_jst = k_js E^TES_jst-1 left(T^U_jst - T^refcool_jstright)\n\nThe effective temperature T^U_jst is modelled as a fraction of the indoor–outdoor temperature gradient:\n\nT^U_jst = T^int_jst - b^tr_js left( T^int_jst - T^ext_jst right)\n\nwhere:\n\nT^int_jst = indoor reference temperature (user profile \"T_int\")\nT^ext_jst = external ambient temperature (user profile \"T_ext\")\nb^tr_js = thermal transmittance factor (\"b_tr_x\") controlling how much of the indoor–outdoor gradient affects the TES","category":"section"},{"location":"model/energy_model/#Boilers","page":"User energy model","title":"Boilers","text":"Boilers o in A^BOIL_j are fuel-fired heating units producing thermal power P^boil_jot. Their nominal capacity is represented by variable x_jo and limits the thermal power output:\n\n0 le P^boil_jot le x_jo","category":"section"},{"location":"model/energy_model/#Thermal-Energy-Balance","page":"User energy model","title":"Thermal Energy Balance","text":"For each user j at every time step t, the thermal balance equation ensures that thermal demand is met by thermal technologies:\n\nsum_s in A^TES_j left E^TES_jst - E^TES_jst-1 + L^TES_jst right\n+\nsum_l in A^TL_j\nP^th_jlt Delta_t\n=\nsum_h in A^HP_j P^HP_jht Delta t\n+\nsum_o in A^BOIL_j P^boil_jotDelta t\n\nwhere:\n\nA^TL_j is the set of thermal loads for user j\nP^th_jlt is the thermal power demand of load l at time t (positive for heating, negative for cooling)\nDelta_t is the time step duration\nL^TES_jst are the thermal losses from TES\nP^HP_jht is the thermal power provided by heat pumps\nP^boil_jot is the thermal power provided by boilers\nE^TES_jst is the energy stored in TES at time t","category":"section"},{"location":"API reference/#API-Reference","page":"API reference","title":"API Reference","text":"","category":"section"},{"location":"API reference/#Base.copy-Tuple{ModelEC}","page":"API reference","title":"Base.copy","text":"Base.copy(model_copy::ModelEC)\n\nCreate a copy of a ModelEC opject\n\nArguments\n\nmodel_copy::ModelEC: model to copy\n\n\n\n\n\n","category":"method"},{"location":"API reference/#Base.deepcopy-Tuple{ModelEC}","page":"API reference","title":"Base.deepcopy","text":"Base.deepcopy(model_copy::ModelEC)\n\nCreate a deepcopy of a ModelEC opject\n\nArguments\n\nmodel_copy::ModelEC: model to copy\n\n\n\n\n\n","category":"method"},{"location":"API reference/#Base.zero-Tuple{ModelEC}","page":"API reference","title":"Base.zero","text":"Base.zero(::ModelEC)\n\nFunction zero to represent the empty ModelEC\n\n\n\n\n\n","category":"method"},{"location":"API reference/#EnergyCommunity._jump_to_dict-Tuple{JuMP.Model}","page":"API reference","title":"EnergyCommunity._jump_to_dict","text":"_jump_to_dict\n\nFunction to turn a JuMP model to a dictionary\n\n\n\n\n\n","category":"method"},{"location":"API reference/#EnergyCommunity._print_summary-Tuple{IO, AbstractEC}","page":"API reference","title":"EnergyCommunity._print_summary","text":"_print_summary(io::IO, model::AbstractEC)\n\nPrint a plain-text summary of model to io.\n\n\n\n\n\n","category":"method"},{"location":"API reference/#EnergyCommunity._verify_data-Tuple{Dict}","page":"API reference","title":"EnergyCommunity._verify_data","text":"_verify_data(data::Dict)\n\nFunction to verify the data loaded from the disk (Not yet implemented)\n\n\n\n\n\n","category":"method"},{"location":"API reference/#EnergyCommunity._verify_users_data-Tuple{Dict}","page":"API reference","title":"EnergyCommunity._verify_users_data","text":"_verify_users_data(users_data::Dict)\n\nFunction to verify the users data loaded from the disk\n\n\n\n\n\n","category":"method"},{"location":"API reference/#EnergyCommunity.add_EC_economics_summary!-Tuple{Vector, AbstractEC}","page":"API reference","title":"EnergyCommunity.add_EC_economics_summary!","text":"add_EC_economics_summary!(output_list::Vector, ECModel::AbstractEC)\n\nFunction to create the output dataframe of the economics of the EC\n\n\n\n\n\n","category":"method"},{"location":"API reference/#EnergyCommunity.add_EC_peak_summary!-Tuple{Vector, AbstractEC}","page":"API reference","title":"EnergyCommunity.add_EC_peak_summary!","text":"add_EC_peak_summary!(output_list::Vector, ECModel::AbstractEC)\n\nFunction to create the output dataframe of peak power for the EC\n\n\n\n\n\n","category":"method"},{"location":"API reference/#EnergyCommunity.add_branching_priorities!-Tuple{AbstractEC, Any}","page":"API reference","title":"EnergyCommunity.add_branching_priorities!","text":"add_branching_priorities!(ECModel::AbstractEC, ::Any) end\n\nGeneral fallback for branching priorities\n\n\n\n\n\n","category":"method"},{"location":"API reference/#EnergyCommunity.add_info_solution_summary!-Tuple{Vector, AbstractEC}","page":"API reference","title":"EnergyCommunity.add_info_solution_summary!","text":"add_info_solution_summary!(output_list::Vector, ECModel::AbstractEC)\n\nUtility function to create the dataframe to report the status of the optimization. It adds a dataframe named info_solution to output_list with the solve time and the termination status of the optimization.\n\nArguments\n\noutput_list::Vector: The list of dataframes to be saved\nECModel::AbstractEC: The EC model to be built\n\n\n\n\n\n","category":"method"},{"location":"API reference/#EnergyCommunity.add_notations!-Tuple{AbstractEC, Any}","page":"API reference","title":"EnergyCommunity.add_notations!","text":"add_notations!(ECModel::AbstractEC, ::Any)\n\nGeneral fallback for notations\n\n\n\n\n\n","category":"method"},{"location":"API reference/#EnergyCommunity.add_users_design_summary!-Tuple{Vector, AbstractEC, AbstractVector}","page":"API reference","title":"EnergyCommunity.add_users_design_summary!","text":"add_users_design_summary!(output_list::Vector, ECModel::AbstractEC, user_set::AbstractVector)\n\nUtility function to create the output dataframe of design capacity. It adds a dataframe with the peak demand, yearly demand, and optimal size of the system for each user.\n\nArguments\n\noutput_list::Vector: The list of dataframes to be saved\nECModel::AbstractEC: The EC model to be built\nuser_set::AbstractVector: The user set to be considered\n\n\n\n\n\n","category":"method"},{"location":"API reference/#EnergyCommunity.add_users_economics_summary!-Tuple{Vector, AbstractEC, AbstractVector}","page":"API reference","title":"EnergyCommunity.add_users_economics_summary!","text":"add_users_economics_summary!(output_list::Vector, ECModel::AbstractEC, user_set::AbstractVector)\n\nFunction to create the output dataframe of the users' economics. It adds a dataframe with the NPV, CAPEX, OPEX, yearly revenues, and other economic indicators for each user.\n\nArguments\n\noutput_list::Vector: The list of dataframes to be saved\nECModel::AbstractEC: The EC model to be built\nuser_set::AbstractVector: The user set to be considered\n\n\n\n\n\n","category":"method"},{"location":"API reference/#EnergyCommunity.add_users_peak_summary!-Tuple{Vector, AbstractEC, AbstractVector}","page":"API reference","title":"EnergyCommunity.add_users_peak_summary!","text":"add_users_peak_summary!(output_list::Vector, ECModel::AbstractEC, user_set::AbstractVector)\n\nFunction to create the output dataframe of peak power. It adds a dataframe with the peak power of each user for each peak period.\n\nArguments\n\noutput_list::Vector: The list of dataframes to be saved\nECModel::AbstractEC: The EC model to be built\nuser_set::AbstractVector: The user set to be considered\n\n\n\n\n\n","category":"method"},{"location":"API reference/#EnergyCommunity.asset_names-Tuple{Any, ASSET_TYPE}","page":"API reference","title":"EnergyCommunity.asset_names","text":"Function to get the list of the assets for a user\n\n\n\n\n\n","category":"method"},{"location":"API reference/#EnergyCommunity.asset_names-Tuple{Any, Vector{ASSET_TYPE}}","page":"API reference","title":"EnergyCommunity.asset_names","text":"Function to get the list of the assets for a user in a list of elements\n\n\n\n\n\n","category":"method"},{"location":"API reference/#EnergyCommunity.asset_names-Tuple{Any}","page":"API reference","title":"EnergyCommunity.asset_names","text":"Function to get the list of the assets for a user\n\n\n\n\n\n","category":"method"},{"location":"API reference/#EnergyCommunity.asset_names_ex-Tuple{Any, Vector{ASSET_TYPE}}","page":"API reference","title":"EnergyCommunity.asset_names_ex","text":"Function to get the list of the assets for a user in a list of elements except a list of given types\n\n\n\n\n\n","category":"method"},{"location":"API reference/#EnergyCommunity.asset_type-Tuple{Any, Any}","page":"API reference","title":"EnergyCommunity.asset_type","text":"Function to get the asset type of a component\n\n\n\n\n\n","category":"method"},{"location":"API reference/#EnergyCommunity.build_base_model!-Tuple{AbstractEC, Any}","page":"API reference","title":"EnergyCommunity.build_base_model!","text":"build_base_model!(ECModel::AbstractEC, optimizer)\n\nCreates the base optimization model for all the EC models\n\nArguments\n\nECModel: EC model object\noptimizer: optimizer object; any optimizer from JuMP\nuse_notations: boolean; if true, the model will be created using the direct mode to create the JuMP model\n\nReturns\n\nIt returns the ECModel object with the base model created\n\n\n\n\n\n","category":"method"},{"location":"API reference/#EnergyCommunity.build_base_utility!-Tuple{AbstractEC, AbstractGroupANC}","page":"API reference","title":"EnergyCommunity.build_base_utility!","text":"build_base_utility!(ECModel::AbstractEC, base_group::AbstractGroupANC; base_model=nothing)\n\nWhen in the CO case the ANC model is used as base case, then this function builds the corresponding constraint\n\nArguments\n\nECModel::AbstractEC: Cooperative EC Model of the EC to study.\nbase_group::AbstractGroupANC: Type of the base case to consider\nbase_model::ModelEC: Model of the base case to consider\n\nReturns\n\nBaseUtility: JuMP expression of the base utility\n\n\n\n\n\n","category":"method"},{"location":"API reference/#EnergyCommunity.build_base_utility!-Tuple{AbstractEC, AbstractGroupNC}","page":"API reference","title":"EnergyCommunity.build_base_utility!","text":"build_base_utility!(ECModel::AbstractEC, base_group::AbstractGroupNC; base_model=nothing)\n\nWhen in the CO case the NC model is used as base case, then this function builds the corresponding constraint\n\nArguments\n\nECModel::AbstractEC: Cooperative EC Model of the EC to study.\nbase_group::AbstractGroupNC: Type of the base case to consider\nbase_model::ModelEC: Model of the base case to consider\n\nReturns\n\nBaseUtility: JuMP expression of the base utility\n\n\n\n\n\n","category":"method"},{"location":"API reference/#EnergyCommunity.build_base_utility!-Tuple{AbstractEC, Vararg{Any}}","page":"API reference","title":"EnergyCommunity.build_base_utility!","text":"build_base_utility!(ECModel::AbstractEC, no_aggregator_group::AbstractGroupANC)\n\nWhen in the CO case the ANC model is used as reference case for when the aggregator is not in the group, then this function builds the corresponding constraint\n\nNot implemented\n\n\n\n\n\n","category":"method"},{"location":"API reference/#EnergyCommunity.build_least_profitable!-Tuple{AbstractEC, AbstractGroup}","page":"API reference","title":"EnergyCommunity.build_least_profitable!","text":"build_least_profitable!(\n    ECModel::AbstractEC, base_group::AbstractGroup;\n    no_aggregator_group::AbstractGroup=GroupNC(),\n    add_EC=true,\n    relax_combinatorial=false,\n    use_notations=false,\n    base_model=nothing,\n)\n\nFunction to build the model to identify the least profitable coalition. This function builds the model in the ECModel object to identify the least profitable coalition using a MILP model.\n\nArguments\n\nECModel::AbstractEC: EC Model of the EC to study.\nbase_group::AbstractGroup: Type of the base case to consider\nno_aggregator_group::AbstractGroup=GroupNC(): Type of the base case to consider when no aggregator is in the coalition\nadd_EC::Bool=true: Flag to include the EC in the coalition\nrelax_combinatorial::Bool=false: Flag to relax the combinatorial part of the MILP model\nuse_notations::Bool=false: Flag to use notations in the model\nbase_model::ModelEC=nothing: Model of the base case to consider\n\n\n\n\n\n","category":"method"},{"location":"API reference/#EnergyCommunity.build_model!-Tuple{AbstractEC}","page":"API reference","title":"EnergyCommunity.build_model!","text":"build_model!(ECModel::AbstractEC; kwargs...)\n\nBuild the mathematical problem for the EC.\n\n\n\n\n\n","category":"method"},{"location":"API reference/#EnergyCommunity.build_model!-Tuple{AbstractGroup, AbstractEC, Any}","page":"API reference","title":"EnergyCommunity.build_model!","text":"build_model!(group_type::AbstractGroup, ECModel::AbstractEC, optimizer; use_notations=false)\n\nBuild function model for generic EnergyCommunity model. This functions triggers specific functions for the different aggregation types.\n\nIn particular, first the function build_base_model! is called to build the base model of the EC. Then, the function build_specific_model! is called to build the specific model of the EC dependin on the group type. Finally, the function set_objective! is called to set the objective of the EC, based on their group type.\n\n\n\n\n\n","category":"method"},{"location":"API reference/#EnergyCommunity.build_no_agg_utility!-Tuple{AbstractEC, AbstractGroupANC}","page":"API reference","title":"EnergyCommunity.build_no_agg_utility!","text":"build_no_agg_utility!(ECModel::AbstractEC, no_aggregator_group::AbstractGroupANC; base_model=nothing)\n\nWhen in the CO case the ANC model is used as reference case for when the aggregator is not in the group, then this function builds the corresponding constraint\n\nArguments\n\nECModel::AbstractEC: Cooperative EC Model of the EC to study.\nno_aggregator_group::AbstractGroupANC: Type of the base case to consider\nbase_model::ModelEC: Model of the base case to consider\n\nReturns\n\nSW: JuMP expression of the Social Welfare\n\n\n\n\n\n","category":"method"},{"location":"API reference/#EnergyCommunity.build_no_agg_utility!-Tuple{AbstractEC, AbstractGroupNC}","page":"API reference","title":"EnergyCommunity.build_no_agg_utility!","text":"buildnoaggutility!(ECModel::AbstractEC, noaggregator_group::AbstractGroupNC; kwargs...)\n\nWhen the NC case is the reference value when no aggregator is available, then no changes in the model are required\n\nArguments\n\nECModel::AbstractEC: Cooperative EC Model of the EC to study.\nno_aggregator_group::AbstractGroupNC: Type of the base case to consider\n\nReturns\n\nSW: JuMP expression of the Social Welfare; the same as in the input model\n\n\n\n\n\n","category":"method"},{"location":"API reference/#EnergyCommunity.build_no_agg_utility!-Tuple{AbstractEC, Any}","page":"API reference","title":"EnergyCommunity.build_no_agg_utility!","text":"build_no_agg_utility!(ECModel::AbstractEC, no_aggregator_group::Any)\n\nNot implemented case\n\n\n\n\n\n","category":"method"},{"location":"API reference/#EnergyCommunity.build_noagg_least_profitable!-Tuple{ModelEC}","page":"API reference","title":"EnergyCommunity.build_noagg_least_profitable!","text":"build_noagg_least_profitable(ECModel::ModelEC; use_notations=false, optimizer=nothing, base_model=nothing)\n\nFunction to create a specialized model to identify the least profitable coalition for an energy community of ANC type.\n\nArguments\n\nECModel::ModelEC: Model of the community\nuse_notations::Bool=false: Flag to use notations in the model\noptimizer::Optimizer=nothing: Optimizer to use\nbase_model::ModelEC=nothing: Model of the base case to consider\n\n\n\n\n\n","category":"method"},{"location":"API reference/#EnergyCommunity.build_specific_model!-Tuple{AbstractGroupANC, AbstractEC}","page":"API reference","title":"EnergyCommunity.build_specific_model!","text":"build_specific_model!(::AbstractGroupANC, ECModel::AbstractEC)\n\nSet the ANC-specific model for the EC\n\n\n\n\n\n","category":"method"},{"location":"API reference/#EnergyCommunity.build_specific_model!-Tuple{AbstractGroupCO, AbstractEC}","page":"API reference","title":"EnergyCommunity.build_specific_model!","text":"build_specific_model!(::AbstractGroupCO, ECModel::AbstractEC)\n\nSet the CO-specific model for the EC\n\n\n\n\n\n","category":"method"},{"location":"API reference/#EnergyCommunity.build_specific_model!-Tuple{AbstractGroupNC, AbstractEC}","page":"API reference","title":"EnergyCommunity.build_specific_model!","text":"build_specific_model!(::AbstractGroupNC, ECModel::AbstractEC)\n\nSet the NC-specific model for the EC. It adds the P_agg expression only being equal to the sum of the power supplied by the users to the grid.\n\nArguments\n\ngroup_type::AbstractGroupNC: The type of group model\nECModel::AbstractEC: The EC model to be built\n\nReturns\n\nECModel::AbstractEC: The EC model with the specific model built\n\n\n\n\n\n","category":"method"},{"location":"API reference/#EnergyCommunity.business_plan","page":"API reference","title":"EnergyCommunity.business_plan","text":"business_plan(ECModel::AbstractEC, profit_distribution=nothing, user_set_financial=nothing)\n\nFunction to describe the business plan\n\nArguments\n\nECModel::AbstractEC: Energy Community model\nprofit_distribution: (optional) DenseAxisArray with the profit distribution by user\nuser_set_financial: (optional) User set to be considered for the financial analysis\n\nReturns\n\nThe output value is a DataFrame with the business plan information\n\n\n\n\n\n","category":"function"},{"location":"API reference/#EnergyCommunity.business_plan_plot","page":"API reference","title":"EnergyCommunity.business_plan_plot","text":"business_plan_plot(ECModel::AbstractEC, ...)\n\nFunction to plot the business plan of the EnergyCommunity.\n\nArguments\n\nECModel::AbstractEC: Energy Community model\nprofit_distribution: (optional) Dictionary with the profit distribution by user\nuser_set_financial: (optional) User set to be considered for the financial analysis\nplot_struct: (optional) Dictionary with the structure of the plot. The keys are the labels of the bars and the values are a list of tuples with the sign and the name of the variable to be plotted. Example is Dict(\"CAPEX\" => [(-1, :CAPEX)]) for plotting the CAPEX with a negative sign.\nxlabel: (optional) Label for the x-axis\nylabel: (optional) Label for the y-axis\ntitle: (optional) Title of the plot\nlegend: (optional) Position of the legend\ncolor: (optional) Color of the bars\nxrotation: (optional) Rotation of the x-axis labels\nbar_width: (optional) Width of the bars\ngrid: (optional) Grid visibility\nframestyle: (optional) Style of the frame\nbarmode: (optional) Mode of the bars\nscaling_factor: (optional) Scaling factor for the values\nkwargs: (optional) Additional arguments to be passed to Plots.bar function\n\n\n\n\n\n","category":"function"},{"location":"API reference/#EnergyCommunity.calculate_demand-Tuple{AbstractEC}","page":"API reference","title":"EnergyCommunity.calculate_demand","text":"calculate_demand(ECModel::AbstractEC)\n\nFunction to calculate the demand by user\n\nArguments\n\nECModel: EC model object\n\nReturns\n\nIt returns the demand by user and the whole EC as a DenseAxisArray\n\n\n\n\n\n","category":"method"},{"location":"API reference/#EnergyCommunity.calculate_grid_export-Tuple{AbstractEC}","page":"API reference","title":"EnergyCommunity.calculate_grid_export","text":"calculate_grid_export(ECModel::AbstractEC; per_unit::Bool=true)\n\nCalculate grid export for the energy community and users. Output is normalized with respect to the demand when per_unit is true\n\nReturns\n\nIt returns a DenseAxisArray containing the power fed to the grid for each user and the whole aggregate\n\n\n\n\n\n","category":"method"},{"location":"API reference/#EnergyCommunity.calculate_grid_export-Tuple{AbstractGroupANC, AbstractEC}","page":"API reference","title":"EnergyCommunity.calculate_grid_export","text":"calculate_grid_export(::AbstractGroupANC, ECModel::AbstractEC; per_unit::Bool=true)\n\nCalculate grid export for the Aggregated Non Cooperative case. Output is normalized with respect to the demand when per_unit is true\n\nReturns\n\nIt returns a DenseAxisArray containing the power fed to the grid for each user and the whole aggregate\n\n\n\n\n\n","category":"method"},{"location":"API reference/#EnergyCommunity.calculate_grid_export-Tuple{AbstractGroupCO, AbstractEC}","page":"API reference","title":"EnergyCommunity.calculate_grid_export","text":"calculate_grid_export(::AbstractGroupCO, ECModel::AbstractEC; per_unit::Bool=true)\n\nCalculate grid export for the Cooperative case. Output is normalized with respect to the demand when per_unit is true\n\nReturns\n\nReturns a DenseAxisArray that contains the reliance on the grid supply for each user and the aggregation\n\n\n\n\n\n","category":"method"},{"location":"API reference/#EnergyCommunity.calculate_grid_export-Tuple{AbstractGroupNC, AbstractEC}","page":"API reference","title":"EnergyCommunity.calculate_grid_export","text":"calculate_grid_export(::AbstractGroupNC, ECModel::AbstractEC; per_unit::Bool=true)\n\nCalculate grid export for the Non-Cooperative case Output is normalized with respect to the demand when per_unit is true\n\nReturns\n\nReturns a DenseAxisArray that contains the reliance on the grid supply for each user and the aggregation\n\n\n\n\n\n","category":"method"},{"location":"API reference/#EnergyCommunity.calculate_grid_import-Tuple{AbstractEC}","page":"API reference","title":"EnergyCommunity.calculate_grid_import","text":"calculate_grid_import(ECModel::AbstractEC; per_unit::Bool=true)\n\nCalculate grid usage for the energy community and users. Output is normalized with respect to the demand when per_unit is true\n\nReturns\n\nIt returns a DenseAxisArray containing the power withdrawn from the grid for each user and the whole aggregate\n\n\n\n\n\n","category":"method"},{"location":"API reference/#EnergyCommunity.calculate_grid_import-Tuple{AbstractGroupANC, AbstractEC}","page":"API reference","title":"EnergyCommunity.calculate_grid_import","text":"calculate_grid_import(::AbstractGroupANC, ECModel::AbstractEC; per_unit::Bool=true)\n\nCalculate grid usage for the Aggregated Non Cooperative case. Output is normalized with respect to the demand when per_unit is true\n\nReturns\n\nIt returns a DenseAxisArray containing the power withdrawn from the grid for each user and the whole aggregate\n\n\n\n\n\n","category":"method"},{"location":"API reference/#EnergyCommunity.calculate_grid_import-Tuple{AbstractGroupCO, AbstractEC}","page":"API reference","title":"EnergyCommunity.calculate_grid_import","text":"calculate_grid_import(::AbstractGroupCO, ECModel::AbstractEC; per_unit::Bool=true)\n\nCalculate grid usage for the Cooperative case. Output is normalized with respect to the demand when per_unit is true\n\nReturns\n\nReturns a DenseAxisArray that describes the reliance on the grid withdrawal for each user and the aggregation\n\n\n\n\n\n","category":"method"},{"location":"API reference/#EnergyCommunity.calculate_grid_import-Tuple{AbstractGroupNC, AbstractEC}","page":"API reference","title":"EnergyCommunity.calculate_grid_import","text":"calculate_grid_import(::AbstractGroupNC, ECModel::AbstractEC; per_unit::Bool=true)\n\nCalculate grid usage for the Non Cooperative case. Output is normalized with respect to the demand when per_unit is true\n\nReturns\n\nReturns a DenseAxisArray that describes the reliance on the grid withdrawal for each user and the aggregation\n\n\n\n\n\n","category":"method"},{"location":"API reference/#EnergyCommunity.calculate_production-Tuple{AbstractEC}","page":"API reference","title":"EnergyCommunity.calculate_production","text":"calculate_production(ECModel::AbstractEC)\n\nFunction to calculate the energy production by user\n\nArguments\n\nECModel: EC model object\n\nReturns\n\nIt returns the production by user and the whole EC as a DenseAxisArray\n\n\n\n\n\n","category":"method"},{"location":"API reference/#EnergyCommunity.calculate_production_shares-Tuple{AbstractEC}","page":"API reference","title":"EnergyCommunity.calculate_production_shares","text":"calculate_production_shares(ECModel::AbstractEC; per_unit::Bool=true)\n\nCalculate energy ratio by energy production resource for a generic group Output is normalized with respect to the demand when per_unit is true\n\nArguments\n\nECModel: EC model object\nper_unit: boolean; if true, the output is normalized with respect to the demand\n\nReturns\n\nIt returns a DenseAxisArray describing the share of energy production by  energy resource by user and the entire system, optionally normalized with respect to the demand of the corresponding group, when per_unit is true\n\n\n\n\n\n","category":"method"},{"location":"API reference/#EnergyCommunity.calculate_self_consumption-Tuple{AbstractEC}","page":"API reference","title":"EnergyCommunity.calculate_self_consumption","text":"calculate_self_consumption(ECModel::AbstractEC; per_unit::Bool=true)\n\nCalculate the demand that each user meets using its own sources, or self consumption. Output is normalized with respect to the demand when per_unit is true\n\nArguments\n\nECModel: EC model object\nper_unit: boolean; if true, the output is normalized with respect to the demand\n\nReturns\n\nIt returns a DenseAxisArray describing the self consumption for each user and the aggregation, optionally normalized with respect to the demand of the corresponding group, when per_unit is true\n\n\n\n\n\n","category":"method"},{"location":"API reference/#EnergyCommunity.calculate_self_production-Tuple{AbstractEC}","page":"API reference","title":"EnergyCommunity.calculate_self_production","text":"calculate_self_production(ECModel::AbstractEC; per_unit::Bool=true)\n\nCalculate the self production for each user. Output is normalized with respect to the demand when per_unit is true\n\nArguments\n\nECModel: EC model object\nper_unit: boolean; if true, the output is normalized with respect to the demand\n\nReturns\n\nIt returns a DenseAxisArray describing the self production for each user and the aggregation, optionally normalized with respect to the demand of the corresponding group, when per_unit is true\n\n\n\n\n\n","category":"method"},{"location":"API reference/#EnergyCommunity.calculate_shared_consumption-Tuple{AbstractEC}","page":"API reference","title":"EnergyCommunity.calculate_shared_consumption","text":"calculate_shared_consumption(ECModel::AbstractEC; per_unit::Bool=true)\n\nCalculate the demand that each user meets using its own sources or other users. When onlyshared is false, also self consumption is considered, otherwise only shared consumption. Output is normalized with respect to the demand when perunit is true\n\nReturns\n\nIt returns a DenseAxisArray containing the time-dependent share of power withdrawn from the grid but consumed by another user for each user and the whole aggregate\n\n\n\n\n\n","category":"method"},{"location":"API reference/#EnergyCommunity.calculate_shared_consumption-Tuple{AbstractGroupANC, AbstractEC}","page":"API reference","title":"EnergyCommunity.calculate_shared_consumption","text":"calculate_shared_consumption(::AbstractGroupANC, ECModel::AbstractEC; per_unit::Bool=true, only_shared::Bool=false)\n\nCalculate the demand that each user meets using its own sources or other users for the Aggregated Non Cooperative case. In this case, there can be shared energy, non only self consumption. When onlyshared is false, also self consumption is considered, otherwise only shared energy. Shared energy means energy that is shared between  Output is normalized with respect to the demand when perunit is true\n\nReturns\n\nIt returns a DenseAxisArray containing the time-dependent share of power withdrawn from the grid but produced by another user for each user and the whole aggregate\n\n\n\n\n\n","category":"method"},{"location":"API reference/#EnergyCommunity.calculate_shared_consumption-Tuple{AbstractGroupCO, AbstractEC}","page":"API reference","title":"EnergyCommunity.calculate_shared_consumption","text":"calculate_shared_consumption(::AbstractGroupCO, ECModel::AbstractEC; per_unit::Bool=true, only_shared::Bool=false)\n\nCalculate the demand that each user meets using its own sources or other users for the Cooperative case. In the Cooperative case, there can be shared energy, non only self consumption. When onlyshared is false, also self consumption is considered, otherwise only shared energy. Shared energy means energy that is shared between  Output is normalized with respect to the demand when perunit is true\n\nReturns\n\nIt returns the shared consumption for each user and the aggregation\n\n\n\n\n\n","category":"method"},{"location":"API reference/#EnergyCommunity.calculate_shared_consumption-Tuple{AbstractGroupNC, AbstractEC}","page":"API reference","title":"EnergyCommunity.calculate_shared_consumption","text":"calculate_shared_consumption(::AbstractGroupNC, ECModel::AbstractEC; kwargs...)\n\nCalculate the demand that each user meets using its own sources or other users for the Non-Cooperative case. In the Non-Cooperative case, there is no shared energy, only self consumption. Shared energy means energy that is shared between  Output is normalized with respect to the demand when per_unit is true\n\nReturns\n\nIt returns the shared consumption for each user and the aggregation\n\n\n\n\n\n","category":"method"},{"location":"API reference/#EnergyCommunity.calculate_shared_production-Tuple{AbstractEC}","page":"API reference","title":"EnergyCommunity.calculate_shared_production","text":"calculate_shared_production(ECModel::AbstractEC; per_unit::Bool=true)\n\nCalculate the energy that each user produces and uses in its own POD or it is commercially consumed within the EC, when creaded. When onlyshared is false, also self production is considered, otherwise only shared energy. Output is normalized with respect to the demand when perunit is true\n\nReturns\n\nIt returns a DenseAxisArray containing the time-dependent share of power fed to the grid but consumed by another user for each user and the whole aggregate\n\n\n\n\n\n","category":"method"},{"location":"API reference/#EnergyCommunity.calculate_shared_production-Tuple{AbstractGroupANC, AbstractEC}","page":"API reference","title":"EnergyCommunity.calculate_shared_production","text":"calculate_shared_production(::AbstractGroupANC, ECModel::AbstractEC; per_unit::Bool=true, only_shared::Bool=false)\n\nCalculate the shared produced energy for the Aggregated Non Cooperative case. In this case, there can be shared energy between users, not only self production. When onlyshared is false, also self production is considered, otherwise only shared energy. Shared energy means energy that is shared between  Output is normalized with respect to the demand when perunit is true\n\nReturns\n\nIt returns a DenseAxisArray containing the time-dependent share of power fed to the grid but consumed by another user for each user and the whole aggregate\n\n\n\n\n\n","category":"method"},{"location":"API reference/#EnergyCommunity.calculate_shared_production-Tuple{AbstractGroupCO, AbstractEC}","page":"API reference","title":"EnergyCommunity.calculate_shared_production","text":"calculate_shared_production(::AbstractGroupCO, ECModel::AbstractEC; per_unit::Bool=true, only_shared::Bool=false)\n\nCalculate the shared produced energy for the Cooperative case. In the Cooperative case, there can be shared energy between users, not only self production. When onlyshared is false, also self production is considered, otherwise only shared energy. Shared energy means energy that is shared between  Output is normalized with respect to the demand when perunit is true\n\nReturns\n\nIt returns a DenseAxisArray that contains the shared energy for each user and the aggregation\n\n\n\n\n\n","category":"method"},{"location":"API reference/#EnergyCommunity.calculate_shared_production-Tuple{AbstractGroupNC, AbstractEC}","page":"API reference","title":"EnergyCommunity.calculate_shared_production","text":"calculate_shared_production(::AbstractGroupNC, ECModel::AbstractEC; kwargs...)\n\nCalculate the shared produced energy for the Non-Cooperative case. In the Non-Cooperative case, there is no shared energy between users, only self production. Output is normalized with respect to the demand when per_unit is true\n\nReturns\n\nIt returns a DenseAxisArray that contains the shared energy for each user and the aggregation\n\n\n\n\n\n","category":"method"},{"location":"API reference/#EnergyCommunity.calculate_tes_losses-Tuple{AbstractEC}","page":"API reference","title":"EnergyCommunity.calculate_tes_losses","text":"calculate_tes_losses(ECModel::AbstractEC)\n\nFunction to calculate the thermal energy losses by thermal storage by user\n\nArguments\n\nECModel: EC model object\n\nReturns\n\nIt returns the thermal energy losses by user /and the whole EC/ as a DenseAxisArray\n\n\n\n\n\n","category":"method"},{"location":"API reference/#EnergyCommunity.calculate_th_consumption-Tuple{AbstractEC}","page":"API reference","title":"EnergyCommunity.calculate_th_consumption","text":"calculate_th_consumption(ECModel::AbstractEC)\n\nFunction to calculate the economic thermal energy consumption by user\n\nArguments\n\nECModel: EC model object\n\nReturns\n\nIt returns the thermal economic consumption by user /and the whole EC/ as a DenseAxisArray\n\n\n\n\n\n","category":"method"},{"location":"API reference/#EnergyCommunity.calculate_th_demand-Tuple{AbstractEC}","page":"API reference","title":"EnergyCommunity.calculate_th_demand","text":"calculate_th_demand(ECModel::AbstractEC)\n\nFunction to calculate the thermal demand by user\n\nArguments\n\nECModel: EC model object\n\nReturns\n\nIt returns the thermal demand by user /and the whole EC/ as a DenseAxisArray\n\n\n\n\n\n","category":"method"},{"location":"API reference/#EnergyCommunity.calculate_th_production-Tuple{AbstractEC}","page":"API reference","title":"EnergyCommunity.calculate_th_production","text":"calculate_th_production(ECModel::AbstractEC)\n\nFunction to calculate the thermal energy production by user\n\nArguments\n\nECModel: EC model object\n\nReturns\n\nIt returns the thermal production by user /and the whole EC/ as a DenseAxisArray\n\n\n\n\n\n","category":"method"},{"location":"API reference/#EnergyCommunity.calculate_time_shared_consumption-Tuple{AbstractEC}","page":"API reference","title":"EnergyCommunity.calculate_time_shared_consumption","text":"calculate_time_shared_consumption(ECModel::AbstractEC)\n\nCalculate the time series of the shared consumed energy for the Energy Community.\n\nFor every time step and user, this time series highlight the quantity of load that is met by using shared energy.\n\nReturns\n\nIt returns a DenseAxisArray containing the time-dependent share of power withdrawn from the grid but produced by another user for each user and the whole aggregate\n\n\n\n\n\n","category":"method"},{"location":"API reference/#EnergyCommunity.calculate_time_shared_consumption-Tuple{AbstractGroupANC, AbstractEC}","page":"API reference","title":"EnergyCommunity.calculate_time_shared_consumption","text":"calculate_time_shared_consumption(::AbstractGroupANC, ECModel::AbstractEC; add_EC=true, kwargs...)\n\nCalculate the time series of the shared consumed energy for the Aggregated Non Cooperative case. In the Aggregated Non Cooperative case, there can be shared energy between users, not only self production.\n\nFor every time step and user, this time series highlight the quantity of load that is met by using shared energy.\n\nReturns\n\nIt returns a DenseAxisArray containing the time-dependent share of power withdrawn from the grid but produced by another user for each user and the whole aggregate\n\n\n\n\n\n","category":"method"},{"location":"API reference/#EnergyCommunity.calculate_time_shared_consumption-Tuple{AbstractGroupCO, AbstractEC}","page":"API reference","title":"EnergyCommunity.calculate_time_shared_consumption","text":"calculate_time_shared_consumption(::AbstractGroupCO, ECModel::AbstractEC; add_EC=true, kwargs...)\n\nCalculate the time series of the shared consumed energy for the Cooperative case. In the Cooperative case, there can be shared energy between users, not only self production.\n\nFor every time step and user, this time series highlight the quantity of load that is met by using shared energy.\n\nReturns\n\nIt returns a DenseAxisArray that quantifies the shared consumption for each user and the aggregation and time step\n\n\n\n\n\n","category":"method"},{"location":"API reference/#EnergyCommunity.calculate_time_shared_consumption-Tuple{AbstractGroupNC, AbstractEC}","page":"API reference","title":"EnergyCommunity.calculate_time_shared_consumption","text":"calculate_time_shared_consumption(::AbstractGroupNC, ECModel::AbstractEC; add_EC=true, kwargs...)\n\nCalculate the time series of the shared consumed energy for the Cooperative case. In the Cooperative case, there can be shared energy between users, not only self production.\n\nFor every time step and user, this time series highlight the quantity of load that is met by using shared energy.\n\nReturns\n\nIt returns a DenseAxisArray that quantifies the shared consumption for each user and the aggregation and time step\n\n\n\n\n\n","category":"method"},{"location":"API reference/#EnergyCommunity.calculate_time_shared_production-Tuple{AbstractEC}","page":"API reference","title":"EnergyCommunity.calculate_time_shared_production","text":"calculate_time_shared_production(ECModel::AbstractEC; kwargs...)\n\nCalculate the time series of the shared consumed energy for the Energy Community.\n\nFor every time step and user, this time series highlight the quantity of production that meets needs by other users.\n\nReturns\n\nIt returns a DenseAxisArray containing the time-dependent share of power fed to the grid but consumed by another user for each user and the whole aggregate\n\n\n\n\n\n","category":"method"},{"location":"API reference/#EnergyCommunity.calculate_time_shared_production-Tuple{AbstractGroupANC, AbstractEC}","page":"API reference","title":"EnergyCommunity.calculate_time_shared_production","text":"calculate_time_shared_production(::AbstractGroupANC, ECModel::AbstractEC; add_EC=true, kwargs...)\n\nCalculate the time series of the shared produced energy for the Aggregated Non Cooperative case. In the Aggregated Non Cooperative case, there can be shared energy between users, not only self production.\n\nFor every time step and user, this time series highlight the quantity of production that meets needs by other users.\n\nReturns\n\nIt returns a DenseAxisArray containing the time-dependent share of power fed to the grid but consumed by another user for each user and the whole aggregate\n\n\n\n\n\n","category":"method"},{"location":"API reference/#EnergyCommunity.calculate_time_shared_production-Tuple{AbstractGroupCO, AbstractEC}","page":"API reference","title":"EnergyCommunity.calculate_time_shared_production","text":"calculate_time_shared_production(::AbstractGroupCO, ECModel::AbstractEC; add_EC=true, kwargs...)\n\nCalculate the time series of the shared produced energy for the Cooperative case. In the Cooperative case, there can be shared energy between users, not only self production.\n\nFor every time step and user, this time series highlight the quantity of production that meets needs by other users.\n\nReturns\n\nReturns a DenseAxisArray that contains the shared production for each user and the aggregation and time step\n\n\n\n\n\n","category":"method"},{"location":"API reference/#EnergyCommunity.calculate_time_shared_production-Tuple{AbstractGroupNC, AbstractEC}","page":"API reference","title":"EnergyCommunity.calculate_time_shared_production","text":"calculate_time_shared_production(::AbstractGroupNC, ECModel::AbstractEC; add_EC=true, kwargs...)\n\nCalculate the time series of the shared produced energy for the Cooperative case. In the Cooperative case, there can be shared energy between users, not only self production.\n\nFor every time step and user, this time series highlight the quantity of production that meets needs by other users.\n\nReturns\n\nReturns a DenseAxisArray that contains the shared production for each user and the aggregation and time step\n\n\n\n\n\n","category":"method"},{"location":"API reference/#EnergyCommunity.check_valid_data_dict-Tuple{Dict}","page":"API reference","title":"EnergyCommunity.check_valid_data_dict","text":"check_valid_data_dict(raw_dict_data::Dict)\n\nCheck whether the dictionary data has the needed components. The dictionary must have the keys \"general\", \"users\", and \"market\".\n\n\n\n\n\n","category":"method"},{"location":"API reference/#EnergyCommunity.component-Tuple{Any, Any}","page":"API reference","title":"EnergyCommunity.component","text":"Function to get the components value of a dictionary\n\n\n\n\n\n","category":"method"},{"location":"API reference/#EnergyCommunity.components-Tuple{AbstractDict}","page":"API reference","title":"EnergyCommunity.components","text":"Function to get the components list of a dictionary\n\n\n\n\n\n","category":"method"},{"location":"API reference/#EnergyCommunity.create_example_data-Tuple{Any}","page":"API reference","title":"EnergyCommunity.create_example_data","text":"create_example_data(parent_folder, config_name::String = \"default\")\n\nCreate an example data for the Energy Community model. This function creates in the specified folder the necessary data to run the Energy Community model, based on the specified configuration name.\n\nArguments\n\nparent_folder: Parent folder where the example data will be created\nconfig_name: Configuration name to be used to create the example data   Supported values: \"default\"\n\n\n\n\n\n","category":"method"},{"location":"API reference/#EnergyCommunity.create_output_data-Tuple{ModelEC, Any}","page":"API reference","title":"EnergyCommunity.create_output_data","text":"create_output_data(ecm_copy::ModelEC, number_of_solutions)\n\nFunction to create output data after the optimization for TheoryOfGames.jl. This functions obtains multiple solutions out of the optimization.\n\nArguments\n\necm_copy::ModelEC: Model of the community\nnumber_of_solutions::Int: Number of solutions to return\n\nReturns\n\noutput_data::Vector{NamedTuple}: Output data\n\n\n\n\n\n","category":"method"},{"location":"API reference/#EnergyCommunity.data_sankey-Tuple{AbstractEC}","page":"API reference","title":"EnergyCommunity.data_sankey","text":"data_sankey(ECModel::AbstractEC; name_units=nothing, norm_value=nothing, market_color = palette(:rainbow)[2], community_color = palette(:rainbow)[5], users_colors = palette(:default))\n\nFunction to create the input data for plotting any Sankey diagram representing the energy flows across the energy community\n\nArguments\n\nECModel::AbstractEC: Energy Community model\nname_units: (optional) Labels used for the sankey diagram with the following order:   \"Market buy\", [users labels], \"Community\", \"Market sell\", [users labels]\nnorm_value: (optional) Normalization value for the flows\nmarket_color: (optional) Color of the market\ncommunity_color: (optional) Color of the community\nusers_colors: (optional) Colors of the users\n\nReturns\n\nsank_data: Dictionary containing the data to plot the Sankey diagram, in agreement to SankeyPlots.jl package\n\"source\": sources of the Sankey\n\"target\": targets of the Sankey\n\"value\": value of each flow\n\"labels\": labels of the Sankey\n\"colors\": colors of the Sankey\n\"layer\": layer of the Sankey\n\"order\": order of the Sankey\n\n\n\n\n\n","category":"method"},{"location":"API reference/#EnergyCommunity.delta_t_tes_lb-NTuple{4, Any}","page":"API reference","title":"EnergyCommunity.delta_t_tes_lb","text":"delta_t_tes_lb(users_data, u, s, t)\n\nFunction to compute the lower bound of the temperature difference for a thermal energy storage (TES) at time t. When the thermal load the TES is linked to is in cooling mode, the lower bound is the difference between the reference temperature (Trefcool) and the input temperature (Tinputcool) for cooling. When the load is in heating mode, the lower bound is 0.0. The corresponding thermal load is identified by the corr_asset field in the load component.\n\nArguments\n\nusers_data: dictionary with the users data\nu: user index\ns: name of the thermal energy storage\nt: time index\n\nReturns\n\n[°C] The lower bound of the temperature difference for the TES at time t\n\n\n\n\n\n","category":"method"},{"location":"API reference/#EnergyCommunity.delta_t_tes_ub-NTuple{4, Any}","page":"API reference","title":"EnergyCommunity.delta_t_tes_ub","text":"delta_t_tes_ub(users_data, u, s, t)\n\nFunction to compute the upper bound of the temperature difference for a thermal energy storage (TES) at time t. When the thermal load the TES is linked to is in heating mode, the upper bound is the difference between the reference temperature (Trefheat) and the input temperature (Tinputheat) for heating. When the load is in cooling mode, the upper bound is 0.0. The corresponding thermal load is identified by the corr_asset field in the first load component that contains the object.\n\nArguments\n\nusers_data: dictionary with the users data\nu: user index\ns: name of the thermal energy storage\nt: time index\n\nReturns\n\n[°C] The lower bound of the temperature difference for the TES at time t\n\n\n\n\n\n","category":"method"},{"location":"API reference/#EnergyCommunity.device_names-Tuple{Any}","page":"API reference","title":"EnergyCommunity.device_names","text":"Function to get the list of devices for a user\n\n\n\n\n\n","category":"method"},{"location":"API reference/#EnergyCommunity.explode_data-Tuple{AbstractEC}","page":"API reference","title":"EnergyCommunity.explode_data","text":"explode_data(ECModel::AbstractEC)\n\nReturn main data elements of the dataset of the ECModel: general parameters, users data and market data, retrieved from the data dictionary of the ECModel.\n\nArguments\n\nECModel::AbstractEC: Energy Community model\n\nReturns\n\ngeneral_data::Dict: General data of the ECModel\nusers_data::Dict: Users data of the ECModel\nmarket_data::Dict: Market data of the ECModel\n\n\n\n\n\n","category":"method"},{"location":"API reference/#EnergyCommunity.explode_data-Tuple{Any}","page":"API reference","title":"EnergyCommunity.explode_data","text":"Return main data elements of the dataset: general parameters, users data and market data\n\n\n\n\n\n","category":"method"},{"location":"API reference/#EnergyCommunity.field","page":"API reference","title":"EnergyCommunity.field","text":"Function get field that throws an error if the field is not found\n\n\n\n\n\n","category":"function"},{"location":"API reference/#EnergyCommunity.field_component-NTuple{4, Any}","page":"API reference","title":"EnergyCommunity.field_component","text":"Function to get the components value of a dictionary, with default value\n\n\n\n\n\n","category":"method"},{"location":"API reference/#EnergyCommunity.field_component-Tuple{Any, Any, Any}","page":"API reference","title":"EnergyCommunity.field_component","text":"Function to get the components value of a dictionary\n\n\n\n\n\n","category":"method"},{"location":"API reference/#EnergyCommunity.field_d","page":"API reference","title":"EnergyCommunity.field_d","text":"Function to safely get a field of a dictionary with default value\n\n\n\n\n\n","category":"function"},{"location":"API reference/#EnergyCommunity.finalize_results!-Tuple{AbstractGroupANC, AbstractEC}","page":"API reference","title":"EnergyCommunity.finalize_results!","text":"finalize_results!(::AbstractGroupANC, ECModel::AbstractEC)\n\nFunction to finalize the results of the Aggregated Non Cooperative model after the execution\n\n\n\n\n\n","category":"method"},{"location":"API reference/#EnergyCommunity.finalize_results!-Tuple{AbstractGroupCO, AbstractEC}","page":"API reference","title":"EnergyCommunity.finalize_results!","text":"finalize_results!(::AbstractGroupCO, ECModel::AbstractEC)\n\nFunction to finalize the results of the Cooperative model after the execution Nothing to do\n\n\n\n\n\n","category":"method"},{"location":"API reference/#EnergyCommunity.finalize_results!-Tuple{AbstractGroupNC, AbstractEC}","page":"API reference","title":"EnergyCommunity.finalize_results!","text":"finalize_results!(::AbstractGroupNC, ECModel::AbstractEC)\n\nFunction to finalize the results of the Non Cooperative model after the execution Many of the variables are set to zero due to the absence of cooperation between users\n\n\n\n\n\n","category":"method"},{"location":"API reference/#EnergyCommunity.general-Tuple{AbstractDict}","page":"API reference","title":"EnergyCommunity.general","text":"Function to get the general parameters\n\n\n\n\n\n","category":"method"},{"location":"API reference/#EnergyCommunity.generator_names-Tuple{Any}","page":"API reference","title":"EnergyCommunity.generator_names","text":"Function to get the list of generators for a user\n\n\n\n\n\n","category":"method"},{"location":"API reference/#EnergyCommunity.get_annotations-Tuple{AbstractEC}","page":"API reference","title":"EnergyCommunity.get_annotations","text":"get_annotations(ECModel::AbstractEC)\n\nGet annotations for Benders decomposition\n\n\n\n\n\n","category":"method"},{"location":"API reference/#EnergyCommunity.get_group_type-Tuple{AbstractEC}","page":"API reference","title":"EnergyCommunity.get_group_type","text":"get_group_type(ECModel::AbstractEC)\n\nReturns the EC group type\n\n\n\n\n\n","category":"method"},{"location":"API reference/#EnergyCommunity.get_subproblem_vars_by_user-Union{Tuple{T}, Tuple{JuMP.Containers.DenseAxisArray{T, N} where N, Any}} where T<:JuMP.VariableRef","page":"API reference","title":"EnergyCommunity.get_subproblem_vars_by_user","text":"get_subproblem_vars_by_user(var::Containers.DenseAxisArray{T}, u_name) where T <: VariableRef\n\nGet variables related to the user u_name for a DenseAxisArray\n\n\n\n\n\n","category":"method"},{"location":"API reference/#EnergyCommunity.get_subproblem_vars_by_user-Union{Tuple{T}, Tuple{JuMP.Containers.SparseAxisArray{T, N} where N, Any}} where T<:JuMP.VariableRef","page":"API reference","title":"EnergyCommunity.get_subproblem_vars_by_user","text":"get_subproblem_vars_by_user(var::Containers.SparseAxisArray{T}, u_name) where T <: VariableRef\n\nGet variables related to the user u_name for a SparseAxisArray\n\n\n\n\n\n","category":"method"},{"location":"API reference/#EnergyCommunity.get_user_set-Tuple{AbstractEC}","page":"API reference","title":"EnergyCommunity.get_user_set","text":"get_user_set(ECModel::AbstractEC)\n\nReturns the EC user set\n\n\n\n\n\n","category":"method"},{"location":"API reference/#EnergyCommunity.has_any_asset","page":"API reference","title":"EnergyCommunity.has_any_asset","text":"Function to check whether an user has any asset\n\n\n\n\n\n","category":"function"},{"location":"API reference/#EnergyCommunity.has_asset-Tuple{Any, ASSET_TYPE}","page":"API reference","title":"EnergyCommunity.has_asset","text":"Function to check whether an user has an asset type\n\n\n\n\n\n","category":"method"},{"location":"API reference/#EnergyCommunity.has_asset-Tuple{Any, AbstractString}","page":"API reference","title":"EnergyCommunity.has_asset","text":"Function to check whether an user has an asset given its name\n\n\n\n\n\n","category":"method"},{"location":"API reference/#EnergyCommunity.has_component-Tuple{Any, Any, Any}","page":"API reference","title":"EnergyCommunity.has_component","text":"Function to know if a dictionary has a particular component\n\n\n\n\n\n","category":"method"},{"location":"API reference/#EnergyCommunity.has_type-Tuple{AbstractDict}","page":"API reference","title":"EnergyCommunity.has_type","text":"Auxiliary function to check if the key 'type' is available in the dictionary d, otherwise false\n\n\n\n\n\n","category":"method"},{"location":"API reference/#EnergyCommunity.load!-Tuple{AbstractString, AbstractEC}","page":"API reference","title":"EnergyCommunity.load!","text":"load!(output_file::AbstractString, ECModel::AbstractEC)\n\nLoads the Energy Community model stored in the file specified by output_file and updates the relevant fields of ECModel. This function performs basic checks on the loaded data, verifying the existence of the necessary keys (\"data\", \"userset\", \"grouptype\", \"results\"), and restores the model components (such as data, users_data, and results) accordingly.\n\n\n\n\n\n","category":"method"},{"location":"API reference/#EnergyCommunity.market-Tuple{AbstractDict}","page":"API reference","title":"EnergyCommunity.market","text":"Function to get the market configuration\n\n\n\n\n\n","category":"method"},{"location":"API reference/#EnergyCommunity.market_profile_by_user-Tuple{AbstractEC, Any, Any}","page":"API reference","title":"EnergyCommunity.market_profile_by_user","text":"market_profile_by_user(ECModel::AbstractEC, u_name, profile_name)\n\nFunction to retrieve the market profile of each user, according to their market type (e.g. commercial, domestic, etc.)\n\nArguments\n\nECModel: EC model object\nu_name: user name\nprofile_name: profile name\n\nReturns\n\nIt returns the vector of data corresponding to the profile of the user according to the market type\n\n\n\n\n\n","category":"method"},{"location":"API reference/#EnergyCommunity.name-Tuple{AbstractEC}","page":"API reference","title":"EnergyCommunity.name","text":"name(model::AbstractEC)\n\nReturn the name of the model.\n\n\n\n\n\n","category":"method"},{"location":"API reference/#EnergyCommunity.name-Tuple{ModelEC}","page":"API reference","title":"EnergyCommunity.name","text":"name(model::ModelEC)\n\nReturn the name of the model.\n\n\n\n\n\n","category":"method"},{"location":"API reference/#EnergyCommunity.objective_by_user-Tuple{AbstractEC}","page":"API reference","title":"EnergyCommunity.objective_by_user","text":"objective_by_user(ECModel::AbstractEC; add_EC=true)\n\nReturns the objective function by user; when add_EC is true, the EC is added to the user set\n\n\n\n\n\n","category":"method"},{"location":"API reference/#EnergyCommunity.objective_by_user-Tuple{AbstractGroupANC, AbstractEC}","page":"API reference","title":"EnergyCommunity.objective_by_user","text":"Function to return the objective function by user in the Aggregated Non Cooperative case\n\n\n\n\n\n","category":"method"},{"location":"API reference/#EnergyCommunity.objective_by_user-Tuple{AbstractGroupCO, AbstractEC}","page":"API reference","title":"EnergyCommunity.objective_by_user","text":"Function to return the objective function by user in the Cooperative case\n\n\n\n\n\n","category":"method"},{"location":"API reference/#EnergyCommunity.objective_by_user-Tuple{AbstractGroupNC, AbstractEC}","page":"API reference","title":"EnergyCommunity.objective_by_user","text":"Function to return the objective function by user in the NonCooperative case\n\n\n\n\n\n","category":"method"},{"location":"API reference/#EnergyCommunity.parse_dataprofile-NTuple{4, Any}","page":"API reference","title":"EnergyCommunity.parse_dataprofile","text":"Function to throw error for unformatted data\n\n\n\n\n\n","category":"method"},{"location":"API reference/#EnergyCommunity.parse_dataprofile-Tuple{Any, Any, Any, AbstractString}","page":"API reference","title":"EnergyCommunity.parse_dataprofile","text":"Function to parse a string value of a profile to load the corresponding dataframe\n\n\n\n\n\n","category":"method"},{"location":"API reference/#EnergyCommunity.parse_dataprofile-Tuple{Any, Any, Any, Dict}","page":"API reference","title":"EnergyCommunity.parse_dataprofile","text":"Function to parse a personalized processing to generate the data When profile_value is a dictionary, then the user is asking a custom processing of data by a function\n\n\n\n\n\n","category":"method"},{"location":"API reference/#EnergyCommunity.parse_dataprofile-Union{Tuple{T}, Tuple{Any, Any, Any, AbstractVector{T}}} where T<:Real","page":"API reference","title":"EnergyCommunity.parse_dataprofile","text":"Function to parse a string value of a profile to load the corresponding dataframe\n\n\n\n\n\n","category":"method"},{"location":"API reference/#EnergyCommunity.parse_dataprofile-Union{Tuple{T}, Tuple{Any, Any, Any, T}} where T<:Real","page":"API reference","title":"EnergyCommunity.parse_dataprofile","text":"Function to parse a string value of a profile to load the corresponding dataframe\n\n\n\n\n\n","category":"method"},{"location":"API reference/#EnergyCommunity.parse_peak_quantity_by_time_vectors-NTuple{5, Any}","page":"API reference","title":"EnergyCommunity.parse_peak_quantity_by_time_vectors","text":"Function to parse the peak power categories and tariff\n\n\n\n\n\n","category":"method"},{"location":"API reference/#EnergyCommunity.plot_sankey-Tuple{AbstractEC, Dict}","page":"API reference","title":"EnergyCommunity.plot_sankey","text":"plot_sankey(ECModel::AbstractEC, sank_data::Dict; label_size = 10)\n\nFunction to plot the Sankey diagram representing the energy flows across the energy community. This function can be used to plot the sankey diagram of already processed data sank_data.\n\nArguments\n\nECModel::AbstractEC: Energy Community model\nsank_data::Dict: Dictionary containing the data to plot the Sankey diagram, in agreement to SankeyPlots.jl package\n\n\n\n\n\n","category":"method"},{"location":"API reference/#EnergyCommunity.plot_sankey-Tuple{AbstractEC}","page":"API reference","title":"EnergyCommunity.plot_sankey","text":"function plot_sankey(ECModel::AbstractEC; name_units=nothing, norm_value=nothing, market_color=palette(:rainbow)[2], community_color=palette(:rainbow)[5], users_colors=palette(:default), label_size=10)\n\nFunction to plot the Sankey diagram representing the energy flows across the energy community\n\nArguments\n\nECModel::AbstractEC: Energy Community model\nname_units: (optional) Labels used for the sankey diagram with the following order:   \"Market buy\", [users labels], \"Community\", \"Market sell\", [users labels]\nnorm_value: (optional) Normalization value for the flows\nmarket_color: (optional) Color of the market\ncommunity_color: (optional) Color of the community\nusers_colors: (optional) Colors of the users\nlabel_size: (optional) Size of the labels in the Sankey diagram\n\n\n\n\n\n","category":"method"},{"location":"API reference/#EnergyCommunity.prepare_summary-Tuple{AbstractGroupANC, AbstractEC}","page":"API reference","title":"EnergyCommunity.prepare_summary","text":"prepare_summary(::AbstractGroupANC, ECModel::AbstractEC;\n    user_set::Vector=Vector())\n\nSave base excel file with a summary of the results for the Aggregated Non Cooperative case\n\n\n\n\n\n","category":"method"},{"location":"API reference/#EnergyCommunity.prepare_summary-Tuple{AbstractGroupCO, AbstractEC}","page":"API reference","title":"EnergyCommunity.prepare_summary","text":"prepare_summary(::AbstractGroupCO, ECModel::AbstractEC; user_set::Vector=Vector())\n\nSave base excel file with a summary of the results for the Cooperative case\n\n\n\n\n\n","category":"method"},{"location":"API reference/#EnergyCommunity.prepare_summary-Tuple{AbstractGroupNC, AbstractEC}","page":"API reference","title":"EnergyCommunity.prepare_summary","text":"prepare_summary(::AbstractGroupNC, ECModel::AbstractEC, file_summary_path::AbstractString;\n    user_set::Vector=Vector())\n\nPrepare the dataframe lists to be saved in an excel file.\n\nArguments\n\ngroup_type::AbstractGroupNC: The type of group model\nECModel::AbstractEC: The EC model to be built\nfile_summary_path::AbstractString: The file path where to save the excel file\nuser_set::AbstractVector: The user set to be considered\n\nReturns\n\noutput_list::Vector: The list of dataframes to be saved in the excel file\n\n\n\n\n\n","category":"method"},{"location":"API reference/#EnergyCommunity.print_summary-Tuple{AbstractEC}","page":"API reference","title":"EnergyCommunity.print_summary","text":"print_summary(ECModel::AbstractEC; kwargs...)\n\nFunction to print a summary of the results of the model. The function dispatches the execution to the appropriate function depending on the Aggregation type of the EC\n\n\n\n\n\n","category":"method"},{"location":"API reference/#EnergyCommunity.print_summary-Tuple{AbstractGroupANC, AbstractEC}","page":"API reference","title":"EnergyCommunity.print_summary","text":"print_summary(::AbstractGroupANC, ECModel::AbstractEC)\n\nFunction to print the main results of the model\n\n\n\n\n\n","category":"method"},{"location":"API reference/#EnergyCommunity.print_summary-Tuple{AbstractGroupCO, AbstractEC}","page":"API reference","title":"EnergyCommunity.print_summary","text":"print_summary(::AbstractGroupCO, ECModel::AbstractEC)\n\nFunction to print the main results of the model\n\n\n\n\n\n","category":"method"},{"location":"API reference/#EnergyCommunity.print_summary-Tuple{AbstractGroupNC, AbstractEC}","page":"API reference","title":"EnergyCommunity.print_summary","text":"print_summary(::AbstractGroupNC, ECModel::AbstractEC)\n\nFunction to print the main results of the model\n\nArguments\n\ngroup_type::AbstractGroupNC: The type of group model\nECModel::AbstractEC: The EC model to be built\n\n\n\n\n\n","category":"method"},{"location":"API reference/#EnergyCommunity.profile-Tuple{Any, Any}","page":"API reference","title":"EnergyCommunity.profile","text":"Function to get a specific profile\n\n\n\n\n\n","category":"method"},{"location":"API reference/#EnergyCommunity.profile_component-Tuple{Any, Any, Any}","page":"API reference","title":"EnergyCommunity.profile_component","text":"Function to get a specific profile\n\n\n\n\n\n","category":"method"},{"location":"API reference/#EnergyCommunity.profiles-Tuple{AbstractDict}","page":"API reference","title":"EnergyCommunity.profiles","text":"Function to get the profile dictionary\n\n\n\n\n\n","category":"method"},{"location":"API reference/#EnergyCommunity.read_input-Tuple{AbstractString}","page":"API reference","title":"EnergyCommunity.read_input","text":"Function to read the input of the optimization model described as a yaml file\n\n\n\n\n\n","category":"method"},{"location":"API reference/#EnergyCommunity.reset_user_set!-Tuple{AbstractEC}","page":"API reference","title":"EnergyCommunity.reset_user_set!","text":"reset_user_set!(ECModel::AbstractEC)\n\nReset the EC user set to match the stored user_set of the ECModel data\n\n\n\n\n\n","category":"method"},{"location":"API reference/#EnergyCommunity.save_summary-Tuple{AbstractEC, AbstractString}","page":"API reference","title":"EnergyCommunity.save_summary","text":"save_summary(ECModel::AbstractEC, output_file::AbstractString; kwargs...)\n\nFunction to save a summary of the results of the model. The function dispatches the execution to the appropriate function depending on the Aggregation type of the EC\n\n\n\n\n\n","category":"method"},{"location":"API reference/#EnergyCommunity.set_group_type!-Tuple{AbstractEC, AbstractGroup}","page":"API reference","title":"EnergyCommunity.set_group_type!","text":"set_group_type!(ECModel::AbstractEC)\n\nSets the EC group type\n\n\n\n\n\n","category":"method"},{"location":"API reference/#EnergyCommunity.set_least_profitable_profit!-Tuple{AbstractEC, Any}","page":"API reference","title":"EnergyCommunity.set_least_profitable_profit!","text":"set_least_profitable_profit!(ECModel::AbstractEC, profit_distribution)\n\nFunction to set the profit distribution of the least profitable problem.\n\nArguments\n\nECModel::AbstractEC: Model of the community\nprofit_distribution::AbstractDict: Profit distribution per user\n\n\n\n\n\n","category":"method"},{"location":"API reference/#EnergyCommunity.set_objective!-Tuple{AbstractGroupANC, AbstractEC}","page":"API reference","title":"EnergyCommunity.set_objective!","text":"Function to set the objective function of the model of the Aggregated-Non-Cooperative model\n\n\n\n\n\n","category":"method"},{"location":"API reference/#EnergyCommunity.set_objective!-Tuple{AbstractGroupCO, AbstractEC}","page":"API reference","title":"EnergyCommunity.set_objective!","text":"set_objective!(::AbstractGroupCO, ECModel::AbstractEC)\n\nSet the objective for the cooperative approach\n\n\n\n\n\n","category":"method"},{"location":"API reference/#EnergyCommunity.set_objective!-Tuple{AbstractGroupNC, AbstractEC}","page":"API reference","title":"EnergyCommunity.set_objective!","text":"set_objective!(::AbstractGroupNC, ECModel::AbstractEC)\n\nFunction to set the objective function of the model of the Non-Cooperative model, which is to maximize the annual profits of all users.\n\nArguments\n\ngroup_type::AbstractGroupNC: The type of group model\nECModel::AbstractEC: The EC model to be built\n\nReturns\n\nECModel::AbstractEC: The EC model with the objective set\n\n\n\n\n\n","category":"method"},{"location":"API reference/#EnergyCommunity.set_user_set!-Tuple{AbstractEC, Any}","page":"API reference","title":"EnergyCommunity.set_user_set!","text":"set_user_set(ECModel::AbstractEC)\n\nSets the EC user set\n\n\n\n\n\n","category":"method"},{"location":"API reference/#EnergyCommunity.split_financial_terms","page":"API reference","title":"EnergyCommunity.split_financial_terms","text":"split_financial_terms(ECModel::AbstractEC, profit_distribution=nothing)\n\nFunction to describe the cost term distributions for each user. Each entry that follows is DenseAxisArray for an economic parameter by user.\n\nArguments\n\nECModel::AbstractEC: Energy Community model\nprofit_distribution: (optional) DenseAxisArray with the profit distribution by user\n\nReturns\n\nThe output value is a NamedTuple with the following elements:\n\nNPV: the NPV of each user given the final profit_distribution adjustment by game theory\nCAPEX: the annualized CAPEX\nOPEX: the annualized operating costs (yearly maintenance and yearly peak and energy grid charges)\nREP: the annualized replacement costs\nRV: the annualized recovery charges\nREWARD: the annualized reward distribution by user\nPEAK: the annualized peak costs\nEN_SELL: the annualized revenues from energy sales\nEN_BUY: the annualized costs from energy consumption and buying\nEN_NET: the annualized net energy costs\n\n\n\n\n\n","category":"function"},{"location":"API reference/#EnergyCommunity.split_yearly_financial_terms","page":"API reference","title":"EnergyCommunity.split_yearly_financial_terms","text":"splityearlyfinancialterms(ECModel::AbstractEC, profitdistribution)\n\nFunction to describe the cost term distributions by all users for year. It returns major economic inputs summed across users and the community by year.\n\nArguments\n\nECModel::AbstractEC: Energy Community model\nprofit_distribution: (optional) DenseAxisArray with the profit distribution by user\n\nReturns\n\nThe output value is a NamedTuple with the following elements:\n\nNPV: the NPV of each user given the final profit_distribution adjustment by game theory\nCAPEX: the CAPEX by year\nOPEX: the operating costs by year (yearly maintenance and yearly peak and energy grid charges)\nREP: the replacement costs by year\nRV: the recovery charges by year\nREWARD: the reward distribution by year\nPEAK: the peak costs by year\nEN_SELL: the revenues from energy sales by year\nEN_BUY: the costs from energy consumption and buying by year\nEN_NET: the net energy costs by year\nyear_set: the list of years under consideration\n\n\n\n\n\n","category":"function"},{"location":"API reference/#EnergyCommunity.to_least_profitable_coalition_callback-Tuple{AbstractEC, AbstractGroup}","page":"API reference","title":"EnergyCommunity.to_least_profitable_coalition_callback","text":"to_least_profitable_coalition_callback(\n    ECModel::AbstractEC,\n    base_group::AbstractGroup;\n    no_aggregator_group::AbstractGroup=GroupNC(),\n    optimizer=nothing,\n    raw_outputs=false,\n    number_of_solutions=1,\n    relax_combinatorial=false,\n    use_notations=false,\n    callback_solution=Dict(),\n    branching_priorities=true,\n    decompose_ANC=true,\n    decompose_rel_tolerance=0.05,\n    decompose_abs_tolerance=1e-2,\n    kwargs...\n)\n\nFunction that returns a callback function that, given as input a profit distribution scheme, returns the coalition that has the least benefit in remaining in the grand coalition. The returned function least_profitable_coalition_callback accepts an AbstractDict as argument that specifies the profit distribution by user that is used to compute the least benefit procedure.\n\nArguments\n\nECModel::AbstractEC: Cooperative EC Model of the EC to study. When the model is not cooperative an error is thrown.\nbase_group::AbstractGroup: Base group with respect the benefit is calculated\nno_aggregator_group::AbstractGroup=GroupNC(): Type of aggregation group of the community when no aggregator is available\noptimizer::Optimizer=nothing: Optimizer to use\nraw_outputs::Bool=false: Flag to return raw outputs; see return section for more details\nnumber_of_solutions::Int=1: Number of solutions to return from each iteration; when number_of_solutions <= 0 all solutions are returned\nrelax_combinatorial::Bool=false: Flag to relax the combinatorial part of the MILP model\nuse_notations::Bool=false: Flag to use notations in the model\ncallback_solution::Dict(): Dictionary of callbacks depending on the termination status of the optimization. Keys shall be of type JuMP.TerminationStatusCode, and outputs a function with as argument a ModelEC\nbranching_priorities::Bool=true: Option to specify if add the branching priorities\ndecompose_ANC::Bool=true: When True, if the noaggregatorgroup is ANC and, then the main optimization model is decomposed into two models: (a) when no Aggregator is in the coalition and (b) when the aggregator is in the coalition. In this case, (a) is optimized first and if the optimization is beyond a given threshold, the execution is terminated without optimizing (b). The threshold is provided as an optional input in the callback function returned by the function. Otherwise the optimization continues with (b).\ndecompose_rel_tolerance=0.05: Relative tolerance of the decompose_ANC procedure\ndecompose_abs_tolerance=1e-2: Absolute tolerance of the decompose_ANC procedure\n\nReturns\n\nleast_profitable_coalition_callback: Function that accepts as input an AbstractDict representing the benefit distribution by user\necm_copy: (when raw_outputs=true) ModelEC copy of the ECModel, used in the callback function\n\n\n\n\n\n","category":"method"},{"location":"API reference/#EnergyCommunity.to_objective_callback_by_subgroup-Tuple{AbstractEC}","page":"API reference","title":"EnergyCommunity.to_objective_callback_by_subgroup","text":"to_objective_callback_by_subgroup(ECModel::AbstractEC)\n\nFunction that returns a callback function that quantifies the objective of a given subgroup of users The returned function objective_func accepts as arguments an AbstractVector of users and returns the objective of the aggregation for any model\n\nArguments\n\nECModel::AbstractEC: Cooperative EC Model of the EC to study.   When the model is not cooperative an error is thrown.\n\nReturns\n\nobjective_callback_by_subgroup: Function that accepts as input an AbstractVector (or Set) of users and returns   as output the benefit of the specified community\n\n\n\n\n\n","category":"method"},{"location":"API reference/#EnergyCommunity.to_objective_callback_by_subgroup-Tuple{AbstractGroupANC, AbstractEC}","page":"API reference","title":"EnergyCommunity.to_objective_callback_by_subgroup","text":"to_objective_callback_by_subgroup(::AbstractGroupANC, ECModel::AbstractEC; base_model=nothing, kwargs...)\n\nFunction that returns a callback function that quantifies the objective of a given subgroup of users The returned function objective_func accepts as arguments an AbstractVector of users and returns the objective of the aggregation for Aggregated Non Cooperative models\n\nArguments\n\ngroup_type: The type of group model\nECModel: EC Model of the EC to study. When the model is not cooperative an error is thrown.\nbase_model: EC Model (optional). When provided, it represents the base model used to perform the calculations\n\nReturns\n\nIt returns a function that accepts as input an AbstractVector (or Set) of users and returns as output the benefit of the specified community\n\n\n\n\n\n","category":"method"},{"location":"API reference/#EnergyCommunity.to_objective_callback_by_subgroup-Tuple{AbstractGroupCO, AbstractEC}","page":"API reference","title":"EnergyCommunity.to_objective_callback_by_subgroup","text":"to_objective_callback_by_subgroup(::AbstractGroupCO, ECModel::AbstractEC)\n\nFunction that returns a callback function that quantifies the objective of a given subgroup of users The returned function objective_func accepts as arguments an AbstractVector of users and returns the objective of the aggregation for Aggregated Cooperative models\n\nArguments\n\ngroup_type: The type of group model\nECModel : Cooperative EC Model of the EC to study. When the model is not cooperative an error is thrown.\nno_aggregator_group (optional, default NonCooperative): EC group type when no aggregator is considered\n\nReturns\n\nIt returns a function that accepts as input an AbstractVector (or Set) of users and returns as output the benefit of the specified community\n\n\n\n\n\n","category":"method"},{"location":"API reference/#EnergyCommunity.to_objective_callback_by_subgroup-Tuple{AbstractGroupNC, AbstractEC}","page":"API reference","title":"EnergyCommunity.to_objective_callback_by_subgroup","text":"to_objective_callback_by_subgroup(::AbstractGroupNC, ECModel::AbstractEC)\n\nFunction that returns a callback function that quantifies the objective of a given subgroup of users The returned function objective_func accepts as arguments an AbstractVector of users and returns the objective of the aggregation for Non Cooperative models\n\nArguments\n\ngroup_type: The type of group model\nECModel : Cooperative EC Model of the EC to study. When the model is not cooperative an error is thrown.\n\nReturns\n\nIt returns a function that accepts as input an AbstractVector (or Set) of users and returns as output the benefit of the specified community\n\n\n\n\n\n","category":"method"},{"location":"API reference/#EnergyCommunity.to_utility_callback_by_subgroup-Tuple{AbstractEC, AbstractGroup}","page":"API reference","title":"EnergyCommunity.to_utility_callback_by_subgroup","text":"to_utility_callback_by_subgroup(\n    ECModel::AbstractEC, base_group_type::AbstractGroup;\n    no_aggregator_group::AbstractGroup=GroupNC(),\n    kwargs...\n)\n\nFunction that returns a callback function that quantifies the benefit of a given subgroup of users The returned function utility_func accepts as arguments an AbstractVector of users and returns the benefit with respect to the base case of the users optimized independently\n\nArguments\n\nECModel::AbstractEC: Cooperative EC Model of the EC to study.\nbase_group_type::AbstractGroup: Type of the base case to consider\nno_aggregator_group::AbstractGroup=GroupNC(): EC group type for when no aggregator is considered\n\nReturns\n\nutility_callback_by_subgroup::Function: Function that accepts as input an AbstractVector (or Set) of users and returns as output the benefit of the specified community\n\n\n\n\n\n","category":"method"},{"location":"API reference/#EnergyCommunity.user_names-Tuple{Any, Any}","page":"API reference","title":"EnergyCommunity.user_names","text":"Get the list of users\n\n\n\n\n\n","category":"method"},{"location":"API reference/#EnergyCommunity.users-Tuple{AbstractDict}","page":"API reference","title":"EnergyCommunity.users","text":"Function to get the users configuration\n\n\n\n\n\n","category":"method"},{"location":"API reference/#FileIO.load-Tuple{AbstractString, AbstractEC}","page":"API reference","title":"FileIO.load","text":"load(output_file::AbstractString, ECModel::AbstractEC)\n\nFunction to save the results and the model to the hard drive; ECModel is not modified. The function saves data, userset, grouptype and results of the ECModel in a dictionary and then saves the dictionary in the output_file.\n\n\n\n\n\n","category":"method"},{"location":"API reference/#FileIO.save-Tuple{AbstractString, AbstractEC}","page":"API reference","title":"FileIO.save","text":"save(output_file::AbstractString, ECModel::AbstractEC)\n\nFunction to save the results and the model to the hard drive. The function saves data, userset, grouptype and results of the ECModel in a dictionary and then saves the dictionary in the output_file.\n\n\n\n\n\n","category":"method"},{"location":"API reference/#JuMP.objective_function-Tuple{AbstractEC}","page":"API reference","title":"JuMP.objective_function","text":"objective_function(ECModel::AbstractEC)\n\nGets the objective function of the model\n\n\n\n\n\n","category":"method"},{"location":"API reference/#JuMP.objective_value-Tuple{AbstractEC}","page":"API reference","title":"JuMP.objective_value","text":"JuMP.objective_value(ECModel::AbstractEC)\n\nReturns the objective value of the EC model\n\n\n\n\n\n","category":"method"},{"location":"API reference/#JuMP.optimize!-Tuple{AbstractEC}","page":"API reference","title":"JuMP.optimize!","text":"JuMP.optimize!(ECModel::AbstractEC)\n\nSolve the optimization problem for the EC. It optimizes the model of the EC and stores the results in the results attribute of the ECModel.\n\n\n\n\n\n","category":"method"},{"location":"API reference/#JuMP.result_count-Tuple{AbstractEC}","page":"API reference","title":"JuMP.result_count","text":"JuMP.result_count(ECModel::AbstractEC)\n\nReturns the result count of the JuMP model of the EC model\n\n\n\n\n\n","category":"method"},{"location":"API reference/#JuMP.termination_status-Tuple{AbstractEC}","page":"API reference","title":"JuMP.termination_status","text":"termination_status(ECModel::AbstractEC)\n\nCalculates the optimization status of the model\n\n\n\n\n\n","category":"method"},{"location":"API reference/#RecipesBase.plot","page":"API reference","title":"RecipesBase.plot","text":"Plots.plot(ECModel::ModelEC, output_plot_file::AbstractString=\"\")\n\nFunction to plot the EC model\n\n\n\n\n\n","category":"function"},{"location":"API reference/#RecipesBase.plot-Tuple{AbstractGroupANC, AbstractEC, AbstractString}","page":"API reference","title":"RecipesBase.plot","text":"Plots.plot(::AbstractGroupANC, ECModel::AbstractEC, output_plot_file::AbstractString;\nuser_set::AbstractVector = Vector(), line_width = 2.0)\n\nFunction to plot the results of the Aggregated non cooperative configuration\n\n\n\n\n\n","category":"method"},{"location":"API reference/#RecipesBase.plot-Tuple{AbstractGroupCO, AbstractEC, AbstractString}","page":"API reference","title":"RecipesBase.plot","text":"Plots.plot(::AbstractGroupCO, ECModel::AbstractEC, output_plot_file::AbstractString;\nuser_set::AbstractVector = Vector(), line_width = 2.0)\n\nFunction to plot the results of the Cooperative EC\n\n\n\n\n\n","category":"method"},{"location":"API reference/#RecipesBase.plot-Tuple{AbstractGroupNC, AbstractEC, AbstractString}","page":"API reference","title":"RecipesBase.plot","text":"Plots.plot(::AbstractGroupNC, ECModel::AbstractEC, output_plot_file::AbstractString;\n    user_set::Vector=Vector(), line_width=2.0)\n\nFunction to plot the results of the user model\n\nArguments\n\ngroup_type::AbstractGroupNC: The type of group model\nECModel::AbstractEC: The EC model to be built\noutput_plot_file::AbstractString: The file path where to save the plots\nuser_set::Vector: The user set to plot\nline_width::Float64: The width of the lines in the plot\n\n\n\n\n\n","category":"method"},{"location":"API reference/#EnergyCommunity.AbstractEC","page":"API reference","title":"EnergyCommunity.AbstractEC","text":"AbstractEC\n\nAbstract type for an EnergyCommunity model.\n\n\n\n\n\n","category":"type"},{"location":"API reference/#EnergyCommunity.AbstractGroup","page":"API reference","title":"EnergyCommunity.AbstractGroup","text":"AbstractGroup\n\nAbstract type for the group model; it is the parent of the three types of group models: Cooperative, Non-Cooperative, and Aggregated Non-Cooperative.\n\n\n\n\n\n","category":"type"},{"location":"API reference/#EnergyCommunity.GroupANC","page":"API reference","title":"EnergyCommunity.GroupANC","text":"GroupANC <: AbstractGroupANC\n\nConcrete type for the Aggregated Non-Cooperative group model.\n\n\n\n\n\n","category":"type"},{"location":"API reference/#EnergyCommunity.GroupCO","page":"API reference","title":"EnergyCommunity.GroupCO","text":"GroupCO <: AbstractGroupCO\n\nConcrete type for the Cooperative group model.\n\n\n\n\n\n","category":"type"},{"location":"API reference/#EnergyCommunity.GroupNC","page":"API reference","title":"EnergyCommunity.GroupNC","text":"GroupNC <: AbstractGroupNC\n\nConcrete type for the Non-Cooperative group model.\n\n\n\n\n\n","category":"type"},{"location":"API reference/#EnergyCommunity.ModelEC","page":"API reference","title":"EnergyCommunity.ModelEC","text":"ModelEC(file_name::AbstractString, group_type, optimizer=nothing)\n\nLoad EnergyCommunity model from disk\n\nArguments\n\nfile_name::AbstractString: name of the file to load the data\ngroup_type: aggregation type of model\noptimizer: optimizer of the JuMP model\n\n\n\n\n\n","category":"type"},{"location":"API reference/#EnergyCommunity.ModelEC-2","page":"API reference","title":"EnergyCommunity.ModelEC","text":"ModelEC(data::Dict=ZERO_DD, group_type=GroupNC(), optimizer=nothing, user_set::Vector=Vector())\n\nConstructor of a ModelEC.\n\nArguments\n\ndata::Dict=ZERO_DD: All data; a dictionary with the keys \"general\", \"users\", and \"market\"\ngroup_type: aggregation type of model\noptimizer: optimizer of the JuMP model\nuser_set::Vector: desired user set\n\n\n\n\n\n","category":"type"},{"location":"API reference/#EnergyCommunity.ModelEC-3","page":"API reference","title":"EnergyCommunity.ModelEC","text":"ModelEC <: AbstractEC\n\nConcrete type for an EnergyCommunity model.\n\nAttributes\n\ndata::Dict: All data\ngen_data::Dict: general data\nmarket_data::Dict: market data\nusers_data::Dict: users data\ngroup_type: aggregation type of model\nuser_set::Vector: desired user set\nmodel::Model: JuMP model\noptimizer: optimizer of the JuMP model\nresults::Dict: results of the model in Dictionary format\n\n\n\n\n\n","category":"type"},{"location":"API reference/#EnergyCommunity.ModelEC-4","page":"API reference","title":"EnergyCommunity.ModelEC","text":"ModelEC(model_copy::ModelEC, group_type=nothing, optimizer=nothing, user_set=nothing)\n\nCopy constructor; it copies the data from model_copy and changes the group type, optimizer, and user set if specified.\n\nArguments\n\nmodel_copy::ModelEC: model to copy\ngroup_type=nothing: aggregation type of model; default is the same as model_copy\noptimizer=nothing: optimizer of the JuMP model; default is the same as model_copy\nuser_set=nothing: desired user set; default is the same as model_copy\n\n\n\n\n\n","category":"type"},{"location":"API reference/#TheoryOfGames.EnumMode-Tuple{AbstractEC, AbstractGroup}","page":"API reference","title":"TheoryOfGames.EnumMode","text":"TheoryOfGames.EnumMode(ECModel::AbstractEC, base_group::AbstractGroup; verbose::Bool=true, kwargs...)\n\nFunction to create the EnumMode item for the TheoryOfGames.jl package.\n\nArguments\n\nECModel::AbstractEC: Cooperative EC Model of the EC to study.\nbase_group::AbstractGroup: Type of the base case to consider\nverbose::Bool=true: Flag to print the results\nkwargs...: Additional arguments\n\nReturns\n\nenum_mode: TheoryOfGames.EnumMode object\n\n\n\n\n\n","category":"method"},{"location":"API reference/#TheoryOfGames.IterMode-Tuple{AbstractEC, AbstractGroup}","page":"API reference","title":"TheoryOfGames.IterMode","text":"TheoryOfGames.IterMode(\n    ECModel::AbstractEC,\n    base_group_type::AbstractGroup; \n    no_aggregator_type::AbstractGroup=GroupNC(),\n    optimizer=nothing,\n    number_of_solutions=0,\n    use_notations=false,\n    decompose_ANC=true,\n    decompose_abs_tolerance=1e-4,\n    decompose_rel_tolerance=1e-4,\n    kwargs...\n)\n\nFunction to create the IterMode item for the TheoryOfGames.jl package\n\nArguments\n\nECModel::AbstractEC: Cooperative EC Model of the EC to study.\nbase_group_type::AbstractGroup: Type of the base case to consider\nno_aggregator_type::AbstractGroup=GroupNC(): Type of the base case to consider when no aggregator is available\noptimizer::Optimizer=nothing: Optimizer to use\nnumber_of_solutions::Int=0: Number of solutions to return from each iteration; when number_of_solutions <= 0 all solutions are returned\nuse_notations::Bool=false: Flag to use notations in the model\ndecompose_ANC::Bool=true: When True, if the noaggregatorgroup is ANC and, then the main optimization model is decomposed into two models. See to_least_profitable_coalition_callback for more details\ndecompose_rel_tolerance=0.05: Relative tolerance of the decompose_ANC procedure\ndecompose_abs_tolerance=1e-2: Absolute tolerance of the decompose_ANC procedure\nkwargs...: Additional arguments\n\nReturns\n\niter_mode: TheoryOfGames.IterMode object\n\n\n\n\n\n","category":"method"},{"location":"theory_of_games/supported_allocations/#Supported-fair-allocation-methods","page":"Supported fair allocation methods","title":"Supported fair allocation methods","text":"","category":"section"},{"location":"theory_of_games/supported_allocations/#Supported-fair-allocation-methods-2","page":"Supported fair allocation methods","title":"Supported fair allocation methods","text":"All allocation methods supported by TheoryOfGames.jl are available in EnergyCommunity.jl. Some of the most relevant methods for energy communities include:\n\nShapley Value: This method allocates benefits based on each participant's marginal contribution to all possible coalitions. It ensures that participants are rewarded fairly according to their contributions.\nNucleolus: This method focuses on minimizing the maximum dissatisfaction among participants. It aims to find an allocation that is as fair as possible by reducing the largest grievances.\nFair Core: This method ensures that no participant receives less than what they would get by acting alone. It guarantees that the allocation is stable and acceptable to all members.\nFair Least Core: This method relaxes the core concept to allow for some level of dissatisfaction, aiming to find an allocation that is as fair as possible while still being feasible.","category":"section"},{"location":"theory_of_games/supported_allocations/#Shapely-Value","page":"Supported fair allocation methods","title":"Shapely Value","text":"The Shapley Value is one of the most widely used methods for fair allocation in cooperative game theory. It provides a way to distribute the total benefit of a coalition among its members based on their individual contributions. The Shapley Value for each participant j is calculated as follows:\n\nphi_j = sum_J subseteq I setminus j dfracJ (I - J - 1)I left( v(J cup j) - v(J) right)\n\nWhere:\n\nphi_j is the Shapley Value allocated to participant j.\nv(J) is the characteristic function representing the benefit of coalition J.\nJ is the number of participants in coalition J.\nI is the total number of participants in the grand coalition I.\n\nThe Shapley Value ensures that each participant is rewarded fairly based on their contributions to all possible coalitions, making it a robust method for fair allocation in energy communities. However, it requires the evaluation of the characteristic function for all possible coalitions, which can be computationally intensive for large communities, unless efficient algorithms or approximations are employed.","category":"section"},{"location":"theory_of_games/supported_allocations/#Nucleolus","page":"Supported fair allocation methods","title":"Nucleolus","text":"The Nucleolus is another important method for fair allocation in cooperative game theory. It aims to find the unique allocation that lexicographically maximizes the satisfaction of the least satisfied group of participants in joining and staying into the whole community, thus ensuring that the allocation is as fair as possible. The Nucleolus is determined by solving a series of linear programming problems that focus on minimizing the largest excesses (dissatisfactions) of coalitions. The Nucleolus allocation phi is found by iteratively solving the following optimization problem:\n\nbeginarrayll\nmax  theta \ntextst  sum_j in J phi_j - v(J) ge theta quad forall j notin Gamma \n             sum_j in J phi_j - v(J) ge bartheta_j quad forall j in Gamma \nendarray\n\nWhere:\n\ntheta is the maximum dissatisfaction to be minimized in the current iteration.\nbartheta_j are the dissatisfaction levels fixed from previous iterations for coalitions already considered in previous iterations.\nGamma is the set of coalitions whose dissatisfaction levels have been fixed in previous iterations.\n\nThe Nucleolus ensures that the allocation is stable and acceptable to all members by minimizing the maximum dissatisfaction among participants. It is unique, however , it can be computationally intensive to compute, especially for large communities, as it requires solving multiple linear programming problems iteratively and calculate the function v(J) for all coalitions.","category":"section"},{"location":"theory_of_games/supported_allocations/#Variance-Core-and-Variance-Least-Core","page":"Supported fair allocation methods","title":"Variance Core and Variance Least Core","text":"The Variance Core and Variance Least Core are methods that ensure stability and fairness in the allocation of benefits among participants in a cooperative game.\n\nThe Variance Core distributes benefits to minimize the variance of redistribution, provided that that each participant and group of participats receive no less than the benefits they provide. In mathematical terms, Variance Core identifies the allocation that minimizes the variance of the allocations while satisfying the core constraints.\n\nLet phi be the allocation vector for all participants, Variance Core allocation is determined by solving the following optimization problem:\n\nbeginarrayll\nmin  sum_j in I left( phi_j - dfracv(I)I right)^2 \ntextst  sum_j in J phi_j - v(J) ge 0 quad forall J subseteq I  \n             sum_j in I phi_j = v(I)\nendarray\n\nWhere:\n\nThe objective function minimizes the variance of the allocations among participants, promoting fairness.\nThe first constraint ensures that no coalition J receives less than its value.\nThe second constraint ensures that the total allocation equals the total value of the grand coalition.\n\nThe Variance Least Core is a variation of the Variance Core that allows for a minimum satisfaction level bartheta for each coalition, where bartheta represents the minimum additional benefit that each coalition should receive beyond its standalone value. Its value is computed by executing the first iteration of the Nucleolus algorithm. The Variance Least Core allocation is determined by solving the following optimization problem:\n\nbeginarrayll\nmin  sum_j in I left( sum_j in J dfracphi_j - v(I)  II right)^2 \ntextst  sum_j in J phi_j - v(J) ge bartheta quad forall J subseteq I \n             sum_j in I phi_j = v(I)\nendarray\n\nWhere:\n\nThe objective function minimizes the variance of the allocations among participants, promoting fairness.\nThe first constraint ensures that no coalition J receives less than its value plus the minimum satisfaction level bartheta.\nThe second constraint ensures that the total allocation equals the total value of the grand coalition.\n\nBoth the Variance Core and Variance Least Core aim to provide fair and stable allocations among participants, with the latter allowing for a degree of dissatisfaction to ensure feasibility in cases where the core may be empty.\n\nIn its form, the Variance Least Core is simpler than the Nucleolus, however, it still requires the evaluation of the characteristic function for all possible coalitions, which can be computationally intensive for large communities, unless efficient algorithms or approximations are employed. Alternative techniques adopting row-generation techniques are available in TheoryOfGames.jl to efficiently compute these allocations for larger games.\n\nSee more details about these allocation methods in the TheoryOfGames.jl documentation and the original references:\n\nD. Fioriti, G. Bigi, A. Frangioni, M. Passacantando and D. Poli, \"Fair Least Core: Efficient, Stable and Unique Game-Theoretic Reward Allocation in Energy Communities by Row-Generation,\" in IEEE Transactions on Energy Markets, Policy and Regulation, vol. 3, no. 2, pp. 170-181, June 2025, doi: 10.1109/TEMPR.2024.3495237.","category":"section"},{"location":"configuration/#Configuration","page":"Configuration","title":"Configuration","text":"To customize a EnergyCommunity.jl model, the main interface to represent a Energy Community system is by editing a configuration file using yaml format. For reference, the default sample configuration file is provided in the examples and easily installable by running the following command:\n\njulia> using EnergyCommunity\n\njulia> create_example_data(\".\", config_name=\"default\")\n\nThis code creates a folder named data in the current directory with the following files:\n\nenergy_community_model.yaml: a sample configuration file for a Energy Community system.\nmarket_data.csv: a csv file with quantities related to the market prices, such as time-varying electricity prices and more.\ninput_resource.csv: a csv file with data related to the demand by each user and specific renewable production by time step of the simulation.\nenergy_community_model_thermal.yaml: another sample configuration file for a Energy Community that contains also dispatchable fuel-fired generators.\n\nTo delve and explore the modelling of Energy Communities with EnergyCommunity.jl, we will use the energy_community_model.yaml file as a reference and better detailed in the following.","category":"section"},{"location":"examples/non_cooperative/#Non-Cooperative-Energy-Community","page":"Non Cooperative Energy Community","title":"Non Cooperative Energy Community","text":"This example is taken from the article Optimal sizing of energy communities with fair revenue sharing and exit clauses: Value, role and business model of aggregators and users by Davide Fioriti et al, url but for a subset of users\n\nThe energy community considered in this example consists of 3 users, where:\n\nall users can install PV system\nonly the first user cannot install batteries, whereas the others can\nthe third user can install also wind turbines\n\nImport the needed packages\n\nusing EnergyCommunity, JuMP\nusing HiGHS, Plots, FileIO\n\nCreate a base Energy Community example in the data folder; use the default configuration.\n\nfolder = joinpath(@__DIR__, \"data\")\ncreate_example_data(folder, config_name=\"default\")\n\nInput file to load the structure of the energy community based on a yaml file.\n\ninput_file = joinpath(@__DIR__, \"data/energy_community_model.yml\");\nnothing #hide\n\nOutput path of the summary and of the plots\n\noutput_file_isolated = joinpath(@__DIR__, \"./results/output_file_NC.xlsx\");\noutput_plot_isolated = joinpath(@__DIR__, \"./results/Img/plot_user_{:s}_NC.png\");\nnothing #hide\n\ndefine optimizer and options\n\noptimizer = optimizer_with_attributes(HiGHS.Optimizer, \"ipm_optimality_tolerance\"=>1e-6)\n\nDefine the Non Cooperative model\n\nNC_Model = ModelEC(input_file, EnergyCommunity.GroupNC(), optimizer)\n\nBuild the mathematical model\n\nbuild_model!(NC_Model)\n\nOptimize the model\n\noptimize!(NC_Model)\n\nget objective value\n\nobjective_value(NC_Model)\n\nCreate plots of the results\n\nplot(NC_Model, output_plot_isolated)\n\nPrint summaries of the results\n\nprint_summary(NC_Model)\n\nSave summaries\n\nsave_summary(NC_Model, output_file_isolated)\n\nPlot the sankey plot of resources\n\nplot_sankey(NC_Model)\n\nDataFrame of the business plan\n\nbusiness_plan(NC_Model)\n\nplot business plan\n\nbusiness_plan_plot(NC_Model)\n\nsave the model to a jld2 file\n\nsave(\"nc_model.jld2\", NC_Model)\n\nread the loaded model from the jld2 file\n\nNC_Model_loaded = load!(\"nc_model.jld2\", ModelEC())\n\nget the objective value of the loaded model\n\nobjective_value(NC_Model_loaded)\n\ninfo: Info\nView this file on Github.\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"model/intro_model/#Architecture-of-the-model","page":"Architecture of the model","title":"Architecture of the model","text":"","category":"section"},{"location":"model/intro_model/#Introduction","page":"Architecture of the model","title":"Introduction","text":"The optimization model implemented in EnergyCommunity.jl is based on a Mixed-Integer Linear Programming (MILP) model implemented in JuMP.jl, accounting for:\n\nTechnical operation of assets (loads, PV, storage, flexible resources).\nMarket interaction with the main grid (imports/exports, tariffs).\nEnergy shared among users of the community.\nConfiguration of the EC: non-cooperative, aggregated-non-cooperative, cooperative.\n\nIn the following, we provide a general description of the mathematical model, starting from the techno-economic model that is valid for all EC configurations, and then describing the specific models suited for the specific configurations.\n\nPlease refer to the following references for more details:\n\nD. Fioriti, G. Bigi, A. Frangioni, M. Passacantando and D. Poli, \"Fair Least Core: Efficient, Stable and Unique Game-Theoretic Reward Allocation in Energy Communities by Row-Generation,\" in IEEE Transactions on Energy Markets, Policy and Regulation, vol. 3, no. 2, pp. 170-181, June 2025, doi: 10.1109/TEMPR.2024.3495237.\nD. Fioriti, A. Frangioni, D. Poli, \"Optimal sizing of energy communities with fair revenue sharing and exit clauses: Value, role and business model of aggregators and users,\" in Applied Energy, vol. 299, 2021, 117328,doi: 10.1016/j.apenergy.2021.117328","category":"section"},{"location":"model/intro_model/#Techno-economic-model","page":"Architecture of the model","title":"Techno-economic model","text":"The techno-economic model of the Energy Community (EC) is based on the model depicted in the figure below, which highlights the general structure of components available by each user j in I, where I is the set of community members, and energy flows. In the following, we first describe the user's expenses and then the main constraints of the model.\n\n(Image: Scheme of the Energy Community)","category":"section"},{"location":"model/intro_model/#Energy-Community-configurations","page":"Architecture of the model","title":"Energy Community configurations","text":"The mathematical model implemented in EnergyCommunity.jl can be configured to represent different types of Energy Communities (ECs), namely:\n\nNon-cooperative EC (NC): In the NC configuration, each user j in I optimizes its own energy system independently, without considering energy sharing with other community members. The objective function for each user is to maximize its own Net Present Value (NPV) based on individual energy consumption, generation, and costs. Let SW^NC(J) = sum_j in J mathrmNPV_j be the sum of the Net Present Value for all users, then the optimization problem for the Non-Cooperative formulation is formulated as follows:\nbeginarrayll\nmax  SW^NC(I) = sum_j in I mathrmNPV_j \ntextst  textUsers power and energy system constraints\nendarray\nNote that as the problem is separable for each user j, it can be solved independently for each user. However, for simplicity, EnergyCommunity.jl implements the problem as a single optimization problem including all users as shown in the previous equation.\nAggregated Non-cooperative EC (ANC): In the ANC configuration, each user j in I still optimizes its own energy system independently, but the model allows for the aggregation of certain resources or costs at the community level. This can include shared infrastructure or collective purchasing of energy, leading to potential cost savings for individual users while still maintaining independent optimization. In mathematical terms, the social welfare SW^ANC(I) of the community is defined as the sum of the individual NPVs of each user plus an additional term mathrmNPV^sh_NC(I) that accounts for the benefits or costs associated with shared resources or collective actions that naturally occur. The actual optimization problem remains the same as in the Non-Cooperative case, but the overall social welfare is adjusted to reflect the aggregated aspects of the community.\nSW^ANC(I) = SW^ANC(I) + mathrmNPV^sh_NC\nCooperative EC (CO): In the CO configuration, all users j in I collaborate to optimize the energy system of the entire community as a whole. The objective function is to maximize the collective NPV of the community, taking into account the energy system of each user havign objective term NPV_j and the additional term mathrmNPV^sh related to the shared energy. This configuration promotes cooperation and can lead to more efficient energy management and cost savings for all members.\nbeginarrayll\nmax  SW^CO(I) = sum_j in I mathrmNPV_j + mathrmNPV^sh \ntextst  textUsers power and energy system constraints\n             textShared energy constraints\nendarray","category":"section"},{"location":"examples/aggregated_non_cooperative/#Aggregated-Non-Cooperative-Energy-Community","page":"Aggregated Non-Cooperative Energy Community","title":"Aggregated Non-Cooperative Energy Community","text":"This example is taken from the article Optimal sizing of energy communities with fair revenue sharing and exit clauses: Value, role and business model of aggregators and users by Davide Fioriti et al, url but for a subset of users\n\nThe energy community considered in this example consists of 3 users, where:\n\nall users can install PV system\nonly the first user cannot install batteries, whereas the others can\nthe third user can install also wind turbines\n\nImport the needed packages\n\nusing EnergyCommunity, JuMP\nusing HiGHS, Plots, FileIO\n\nCreate a base Energy Community example in the data folder; use the default configuration.\n\nfolder = joinpath(@__DIR__, \"data\")\ncreate_example_data(folder, config_name=\"default\")\n\nInput file to load the structure of the energy community based on a yaml file.\n\ninput_file = joinpath(@__DIR__, \"data/energy_community_model.yml\");\nnothing #hide\n\nOutput path of the summary and of the plots\n\noutput_file_isolated = joinpath(@__DIR__, \"./results/output_file_ANC.xlsx\");\noutput_plot_isolated = joinpath(@__DIR__, \"./results/Img/plot_user_{:s}_ANC.png\");\nnothing #hide\n\ndefine optimizer and options\n\noptimizer = optimizer_with_attributes(HiGHS.Optimizer, \"ipm_optimality_tolerance\"=>1e-6)\n\nDefine the Non Cooperative model\n\nANC_Model = ModelEC(input_file, EnergyCommunity.GroupANC(), optimizer)\n\nBuild the mathematical model\n\nbuild_model!(ANC_Model)\n\nOptimize the model\n\noptimize!(ANC_Model)\n\nget objective value\n\nobjective_value(ANC_Model)\n\nCreate plots of the results\n\nplot(ANC_Model, output_plot_isolated)\n\nPrint summaries of the results\n\nprint_summary(ANC_Model)\n\nSave summaries\n\nsave_summary(ANC_Model, output_file_isolated)\n\nPlot the sankey plot of resources\n\nplot_sankey(ANC_Model)\n\nDataFrame of the business plan\n\nbusiness_plan(ANC_Model)\n\nplot business plan\n\nbusiness_plan_plot(ANC_Model)\n\nsave the model to a jld2 file\n\nsave(\"anc_model.jld2\", ANC_Model)\n\nread the loaded model from the jld2 file\n\nANC_Model_loaded = load!(\"anc_model.jld2\", ModelEC())\n\nget the objective value of the loaded model\n\nobjective_value(ANC_Model)\n\ninfo: Info\nView this file on Github.\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"#Introduction","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"#What-is-EnergyCommunity.jl?","page":"Introduction","title":"What is EnergyCommunity.jl?","text":"EnergyCommunity is a package for the optimal design and dispatch of Energy Communities at different level of aggregation. Provided easy to read configuration files, EnergyCommunity.jl creates a mathematical optimization model using JuMP.jl and solves it using any optimization solver compatible with JuMP.jl. The JuMP mathematical model is also editable and customized.\n\nEnergyCommunity.jl automatically builds a Mixed-Integer Linear Programming model that represents the optimal dispatch and design of an Energy Community composed by an arbitrary number of users, as shown in the image.\n\n(Image: Scheme of the Energy Community)","category":"section"},{"location":"#Features","page":"Introduction","title":"Features","text":"Optimal dispatch and design of Energy Communities composed by an arbitrary number of users using Mixed-Integer Linear Programming;\nMultiple types of users: prosumers, consumers, and producers;\nSupport for multiple configurations of Energy Communities:\nNon-Cooperative: no Energy Community is in place as each user optimizes its own costs independently from the others and no shared reward applies;\nAggregated-Non-Cooperative (ANC): an Energy Community is in place but users do not cooperate, so each user optimizes its own costs independently from the others and the shared reward applies for the shared energy that naturally flows among users;\nCOoperative (CO): an Energy Community is in place and users cooperate to minimize the overall costs and share the benefits;\nEach user may own different technologies: batteries, electric vehicles, photovoltaic systems, combined heat and power units, thermal storage systems, heat pumps, boilers, and more;\nEstimate fair reward distribution across users with TheoryOfGames.jl;\nSupport to save and load the model to disk;","category":"section"},{"location":"#Quick-start","page":"Introduction","title":"Quick start","text":"Optimizing energy communities with EnergyCommunity.jl is straightforward. After installing the package, you can create a configuration file (YAML or JSON format) describing the energy community and its users, and then run the optimization. Here is a simple example using a YAML configuration file:\n\nusing EnergyCommunity\nusing HiGHS, Plots, JuMP\n\n# create a sample Energy Community model input files in folder \"data\"\ncreate_example_data(\"data\")\n\n# define input configuration (available in the package)\ninput_file = \"./data/energy_community_model.yml\"\n\n# define pattern of plot by user: the \"{:s}\" will be filled with the name of the user\noutput_plot_combined = \"outputs/Img/plot_user_{:s}_EC.png\"\n\n# create the Energy Community model in Cooperation mode GroupCO()\nECModel = ModelEC(input_file, EnergyCommunity.GroupCO(), HiGHS.Optimizer)\n\n# build the model\nbuild_model!(ECModel)\n\n# optimize the model\noptimize!(ECModel)\n\n# create some plots\nplot(ECModel, output_plot_combined)","category":"section"},{"location":"#Resources-for-getting-started","page":"Introduction","title":"Resources for getting started","text":"Please, check out the examples in the example section and the files available in the example folder of the github repository.\n\nTo learn more about the Julia framework, please check out this simple introduction or more material in julialang.\n\nFor more material on the backbone optimization framework, please refer to documentation of JuMP.jl. JuMP is a domain-specific modeling language that allows mathematical optimization embedded in Julia.","category":"section"}]
}
